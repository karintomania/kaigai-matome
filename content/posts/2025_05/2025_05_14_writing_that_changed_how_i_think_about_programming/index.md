+++
date = '2025-05-14T00:00:00'
months = '2025/05'
draft = false
title = 'プログラミング言語の見方が変わった！きっかけの文章'
tags = ["プログラミング言語", "型システム", "設計思想", "概念", "コンピュータサイエンス"]
featureimage = 'thumbnails/purple8.jpg'
+++

> プログラミング言語の見方が変わった！きっかけの文章

引用元：[https://news.ycombinator.com/item?id=43980760](https://news.ycombinator.com/item?id=43980760)




{{<matomeQuote body="これめちゃいいね！最近CSの研究結構やってるんだけど、いくつかまだ見たことないのがあったよ．ここに載ってないお気に入りをいくつかパッと思いついた限りでシェアさせてね．<br>－ Ian Piumartaの”Open，Extensible Object Models”（https://www.piumarta.com/software/id-objmodel/objmodel2.pdf）は、プログラマーに最大限の自由を許す最小限のオブジェクト指向メタオブジェクトシステムを作る話．メッセージ送信操作だけ定義してて、他は実行時に全部変えられるんだ．分厚い”Art of the Metaobject Protocol”本のより実践的な対になる感じ．<br>－ John Ousterhoutの”Scripting：Higher-Level Programming for the 21st Century”（https://web.stanford.edu/~ouster/cgi-bin/papers/scripting.pd...）－これは論文ってよりは記事かな．Tclの作者によるシステムプログラミング言語とスクリプティング言語の二分法について．一見当たり前だけど、そこから得られる教訓は広く応用が利くと思うんだ．みんな、高性能で生産性も最高の完璧なマルチパラダイム言語を探してるけど、コンパイルされて速くて扱いにくいシステム言語と、扱いやすくて柔軟なインタプリタ型のフロントエンドを組み合わせるのがベストなのかもしれない．よくあるのは、同じアプリにCとTclがあれば十分ってケース．また新しいプログラミング言語を書こうとしてる人は必読だね．<br>－ Niklaus WirthのProject Oberon（https://people.inf.ethz.ch/wirth/ProjectOberon/）は、ハイレベルなUIからカーネル、コンパイラ、RISCっぽいCPUアーキテクチャまで、システム全体を実装したもの．彼は有名な”plea for lean software”を書いてて、それを実際に実践したんだ．依存関係地獄とか、普通のコーダーによる高すぎる抽象化が蔓延するこの時代には失われた芸術だね．" userName="sph" createdAt="2025/05/14 09:02:44" color="#ff5733">}}




{{<matomeQuote body="うーん、Ousterhoutの二分法とその結論には同意できないな．<br>まず、彼の主張の理解として－言語はCみたいなシステム言語か、Tclやpythonみたいなスクリプティング言語のどっちか．システム言語は”強い”型があってデータ構造やアルゴリズム向け、スクリプティング言語は”型なし”で”糊付け”向けだってことだよね．<br>主な主張は、スクリプティング言語は”型なし”のおかげで糊付け作業でより簡潔で開発が速いってこと．<br>彼の例だと、Tclでボタンを作るコードがあるね．<br>button .b -text Hello！ -font {Times<br>16} -command {puts hello}<br>彼は続けてこう言ってるんだ．<br>C++とMicrosoft Foundation Classes（MFC）だと、３つのプロシージャで約25行のコードが必要だ．フォントの設定だけでMFCだと数行かかるんだ：<br>CFont *fontPtr = new CFont()；<br>fontPtr－＞CreateFont(16， 0， 0， 0， 700，<br>0， 0， 0， ANSI_CHARSET，<br>OUT_DEFAULT_PRECIS，<br>CLIP_DEFAULT_PRECIS，<br>DEFAULT_QUALITY，<br>DEFAULT_PITCH｜FF_DONTCARE，<br>“Times New Roman”)；<br>buttonPtr－＞SetFont(fontPtr)；<br>このコードの多くは強い型付けの結果だ［…］Tclでは、フォントの本質的な特性（Times書体、16ポイントのサイズ）は宣言や変換なしですぐに使える．さらに、Tclではボタンの振る舞いをボタンを作成するコマンドに直接含めることができる一方、C++やJavaでは別に宣言されたメソッドに置く必要がある．<br>引用終わり．<br>あれからずいぶん進歩したし、この二分法が誤りなのは例を見れば明らかだよ．Ousterhoutの見方は彼の限られた経験に色付けされてて、Tclの何が彼に気に入ったのかを誤解してるんだ．<br>構文について話そう．彼の提示した正確なTclコードだって、静的型解析をする言語でパースしてコンパイルできるはずだ．それはそうしてない、なぜなら彼はランタイムにしか型チェックしないインタプリタで実行してるからね．でもポイントは、コンパイルされるか解釈されるかは実装の詳細であって、構文とはほとんど関係ないってこと．彼が自分の構文を気に入ってるのは、彼の構文がC++より明らかに優れてるからであって、それ以上じゃない．<br>そして型について：彼は’型なし’言語は制約が少ないから開発が速いと主張してる．これは、もちろん、ナンセンスだよ．制約の量は問題に依存するのであって、言語に依存するわけじゃない．動的型付けが開発を速く感じさせるなら、それは制約に出くわすのを後回しにしてるだけだ．<br>プログラムが実行される前にすべての型エラーに遭遇することを保証する方が良いに決まってる．でも、どんな言語でも静的型解析ができるのに、なぜすべての言語がそうしないの？<br>だってそれは難しいからだ．型理論は複雑なんだ．すべての型システムが決定可能じゃないし、実践的な理由で決定可能なものを選ばなきゃいけない．決定可能なものは、アノテーションや複雑なアルゴリズム・意味論的な制約（例えばHindley-Milner）を要求するかもしれない．<br>PL設計者としては、ただ諦めてランタイムに型チェックするだけの方がずっと楽だ．そして、最優先事項が使える言語をすぐに組み込むことなら、それは非常に理にかなってる．でもそれが実際に優れているからだなんてフリはやめようよ．" userName="johnecheck" createdAt="2025/05/14 11:57:51" color="#785bff">}}




{{<matomeQuote body="僕の意見だけど、型なし言語は短いプログラムに最適だと思うな．だってプログラムの100％を理解できるから．型付き言語は、より大きなプログラムの複雑さを管理する方法なんだよ．<br>関連する例として、BASICプログラミング言語は、24行（ガラスTtyが表示できた行数）に収まるプログラムにすごく向いてるね．" userName="WalterBright" createdAt="2025/05/14 16:54:38" color="#ff5c5c">}}




{{<matomeQuote body="静的型付けのスペクトラムには、明確なコストとメリットのトレードオフがあるよね．みんなCoqを使ってるわけじゃないし．その一方で、”基本的な”静的型付けの負担は、型推論で成功してる現状を考えると、この時点では非常に低いよ［0］．<br>全ての動的型付けプログラミング言語が（オプショナル／段階的な）静的型付けシステムを追求してるみたいだし、もはや”純粋な”動的型付けPLはほとんど過去のものになった気がする．問題は、どのくらい、どんな種類の静的型付けをするかってことだね．そして、これはおそらくドメインによるだろうね（例えば、Rustとそのメモリ安全性への注力はGCを避けてて、それがライフタイムアノテーションを必須にしてる）．<br>0）型推論が万能だとは思わないよ．例えば、複雑な型システムがクレイジーな型を推論して、推論器が失敗した時にそれらをデバッグするのに詰まるような場合、あまり役に立たないね．" userName="foobazgt" createdAt="2025/05/14 19:54:41" color="#38d3d3">}}




{{<matomeQuote body="BASICの変数には型があるよ．BASICは元々印刷端末向けに設計されたから、24行の制限はなかったんだ．現代のBASICはもっと大きなプログラムを書くのにも向いてるよ．<br>今日のHNでもこんな記事見たよ：<br>”I Miss Visual Basic” <br>https://news.ycombinator.com/item？id=43988853<br>”The history and legacy of Visual Basic” https://news.ycombinator.com/item？id=43949855" userName="musicale" createdAt="2025/05/15 03:24:05" color="">}}




{{<matomeQuote body="僕が使ってたBASICは70年代のPDP-10のBASIC-10だったよ．オリジナルからそんなに改良されてなかったな．24行の件はガラスTtyの制限であって、BASICじゃないんだ．" userName="WalterBright" createdAt="2025/05/15 08:42:54" color="">}}




{{<matomeQuote body="関数が画面一つに収まるのは、今でも良いアイデアだと思うよ．<br>僕の言いたかったことは、テレタイプ式の印刷端末は、ビデオ表示端末みたいに垂直方向の空間に本質的な制限がないってことなんだ（そして、結局印刷はかなり長くなる可能性がある）．<br>でも今考えてみると、もしかしたらBASICの設計者たちは、初心者にとって、80カラム（シーケンス番号付きだと72カラム）のパンチカードの小さな束に収まるような短いFORTRANプログラムに匹敵する何かを書く方法を、午後一つか二つで簡単に学べるようにすることを考えてたのかもしれないね．" userName="musicale" createdAt="2025/05/17 02:39:39" color="">}}




{{<matomeQuote body="同意するよ、僕の経験則だと1k LoCを超えるなら静的型付き言語で構築するのが一番だね．長期間メンテするつもりのない20行程度のプログラムなら、PythonよりRustを選ぶことはまずないかな．" userName="Voultapher" createdAt="2025/05/15 06:59:01" color="">}}




{{<matomeQuote body="うん、20行のコードにborrow checkerを使う理由は全くないよね、borrow checkerを実験してる場合を除いては．" userName="WalterBright" createdAt="2025/05/15 17:02:51" color="">}}




{{<matomeQuote body="静的型付けは、型が制約を保証する非常に大きな硬い構造を構築できる．ただし、これらの制約は迅速な作業の妨げになる．関数のシグネチャを変更すると、その関数を呼び出すコードのすべての部分を最初に変更する必要がある．その後、コンパイルし、プログラムを再起動し、全体の硬い構造を再構築し、変更が期待通りに機能することを確認する必要がある．このプロセス全体に数分かかることがある．これらのエラーをコンパイル時に検出することで、より信頼性の高いコードになるという主張がある．<br>動的型付けには、コンパイル時にエラーを検出するのに役立つそのような制約はない．動的型付けを使用すると、より流動的に変更される有機的な構造を構築できる．関数シグネチャを変更しても、その関数を呼び出すすべてのコードを変更する必要はない．アプリケーションを再起動せずに、実行中のアプリケーションで関数を変更してテストできる．これには数秒しかかからない．動的型付けを使用すると、100倍速くイテレーションできる．迅速にイテレーションできるということは、テストがよりしっかり行われたコードになり、より信頼性の高いコードになることが多い．<br>どちらも価値がある．要件が頻繁に変更される開発段階やプロトタイプを構築する必要がある場合に、動的型付けは価値がある．コードがより成熟しており、変更が少なくなり、コードを本番環境に配置する必要がある場合に、静的型付けは価値がある．<br>理想的には両方を持つことだ．プログラムのより成熟した部分は静的型付けされ、より流動的な部分は動的型付けされる．" userName="dilipdasilva" createdAt="2025/05/14 20:06:31" color="#45d325">}}




{{<matomeQuote body="＞ 静的型付けだとカッチリした大規模構造が作れて、型のおかげで制約が守られるけど、その制約が素早い開発の邪魔になる。関数のシグネチャを変えると、呼び出してるコード全部直さなきゃいけないってさ。<br>これ、動的型付け言語の方が”素早い”ってのには断固反対だな〜特に小規模じゃない（つまりデカい）コードベースだとね。<br>動的型付け言語でそんな変更しても、フィードバックゼロだし、変更がどんだけ影響するかも分からない。実際、変更が本当に全部終わったのかすら分からないんだよ。<br>それに比べて、静的型付けだと即座にすごく役に立つフィードバックがあって、変更箇所まで教えてくれる。直す必要があるコードが全部特定されて、こっちに伝えてくれるからね。" userName="derriz" createdAt="2025/05/14 21:12:21" color="#ff5c5c">}}




{{<matomeQuote body="＞ これらのエラーをコンパイル時にキャッチすると、より信頼性の高いコードになるって主張ね。<br>俺にとって一番大事な理由は、静的型付けの方がコードがずっと自己文書化してくれること。関数が何を返してるか見れば分かるし、もし分からないものだったら型宣言を見に行けば、その型で何ができるか分かるんだ。<br>これは動的型付けとは全く違う。動的型付けだと、ドキュメントがすごく良くて最新であることを祈るしかないけど、これがそうじゃないことってしょっちゅうだからね。" userName="magicalhippo" createdAt="2025/05/15 03:55:51" color="#ff5733">}}




{{<matomeQuote body="コンパイラがやってくれるはずの作業（発見しにくいバグ追跡も含めて）に時間を使うのは、動的型付けのルーズな仕組みから得られた時間よりもはるかに多くの時間を無駄にしたよ。" userName="frumplestlatz" createdAt="2025/05/14 20:17:19" color="">}}




{{<matomeQuote body="＞ それからコンパイルして、プログラムを再起動して、硬い構造全体を再構築して、変更が期待通りに動くか確認しなきゃいけない。このプロセス全体で何分もかかることもある。<br>これ、俺の経験とは全然違うんだよ。Virgilは完全に静的型付け言語だけど、コンパイルは速い。Virgilコンパイラ（約50KLOC）で作業してる時、普通のワークフローはデバッグモードでインタープリタを使って、編集→実行のループを回すことなんだ。インタープリタはコンパイラ全体を読み込んで、型チェックして、俺の変更で実行するのに90ミリ秒しかかからない。最適化付きのコンパイルをループに入れても400ミリ秒だよ。<br>ターミナルタブ２つ切り替えるより時間かからないね。<br>これは静的型付け対動的型付けの問題じゃないんだ。めちゃくちゃ非効率な言語/ビルドシステム対効率的なやつの問題なんだよ。" userName="titzer" createdAt="2025/05/14 23:46:43" color="#ff5c5c">}}




{{<matomeQuote body="非効率な言語やビルドシステムは問題を悪化させる可能性はあるね。<br>１秒未満でコンパイルできる静的型付け言語はたくさんある。でも、関数のシグネチャを変えたら、呼び出し側全部直さなきゃいけないのは変わらない。<br>それから再コンパイルして、アプリケーションを再起動して、全データ構造を再構築しなきゃならない。<br>一部の静的言語はインタプリタモードでホットリロードを許してるけど、許される変更の種類は限られてる。<br>Common LispやSmalltalkみたいな動的言語だと、プログラム動かしたまま更新できる。イテレーションの速度は100倍速いよ、だって変更をテストできる状態にするために、アプリケーションを再起動して全データ構造を再構築する必要がないからね。" userName="dilipdasilva" createdAt="2025/05/15 23:09:36" color="#ff33a1">}}




{{<matomeQuote body="＞ プログラムが実行される前に全ての型エラーに遭遇することを保証する方が良い。<br>これ、ミッションクリティカルなソフトウェアを書いてるか、無限に時間がある場合しか通用しないよ。<br>あなたの議論は、納期があって出荷しなきゃいけない場合を考慮してないね。だから、型の完璧さなんてどうでもよくて、生産性を最適化するのが最優先なんだ。<br>パフォーマンスが重要な環境でさえ、スクリプト言語があまり向いてないのに、どうにか生産性のためにそれらに頼る理由があるんだよ。<br>例えばゲーム開発（Unreal EngineとそのBlueprintシステム、GodotとそのGDScript、C++とLuaを組み合わせた多数のゲームエンジン）。<br>もちろん、ゲーム開発者だって静的型付けで理想的なデータ構造を書いてゲームがクラッシュしないようにしたいのはやまやまだけど、彼らの目標は10年以内にゲームを出すことなんだ。だから、パフォーマンスが重要なエンジン部分に強い型付けを限定して、型理論の本なんか見ないでコアプロダクトの開発とイテレーションに集中できるんだ。<br>Mr. Ousterhoutの議論のポイントは、選択肢は二つしかないってことだよ。つまり、万能薬、つまり100％安全なのに実験やオプショナルな型付けもできて、C++並みの速さでネイティブコードにコンパイルできる生産性の高い強い型付け言語っていう神話を invent するか、これが不可能な夢物語だと受け入れて、問題に合ったツールを使う必要があるってことさ。<br>これは表面上は当たり前なんだけど、今でも議論の的になってる点だよね。" userName="sph" createdAt="2025/05/14 12:10:04" color="#785bff">}}




{{<matomeQuote body="＞ 結局、全部アセンブリ（実行される）か、インタープリタ（実行される）にコンパイルされる。アセンブリ最強だね。<br>ここでの本当の選択肢はこうだ：プログラマーのコードを事前にアセンブリにするか、ランタイムでそうするか（アセンブリがプログラマーのコードを解釈する）。あるいはJITコンパイルみたいな中間。<br>そして：どんなガードレールを設置するか。<br>だから、高レベル言語っていうのは、面倒で嫌なアセンブリコーディングをもっと palatable にする方法だと言えるね。<br>例えば、ただマシンがクラッシュする代わりにエラーレポートを出したりとか、サンドボックスを提供したりとか、プログラマーの思考に合う計算モデルを提供したりとか。<br>それらの間には、ただいくつか役に立つ抽象化が必要なんだ。できればシンプルで汎用性のあるやつ。<br>例えば、（ビットマップ）”スクリーン”は、ただの平らなメモリ空間（フレームバッファ）でもいい。あるいはピクセルの２次元配列で、おそらく”ピクセル”は別の場所で定義されてるとか。<br>プログラマーはGPUがどうやってそれらのピクセルを表示するように強制されるか気にしないし、低レベルコードは高レベルソフトウェアがそれらを生成するために何をするか気にしない。<br>そして、そういう抽象化は可能な限り少なく（ただし少なくしすぎないように！）持つことだ。<br>Tcl: ”全ては文字列”<br>Lisp: ”全てはリスト”<br>Unix(-like): ”全てはファイル”<br>とかね。<br>個人的には、表現力 / 少なくても役に立つ抽象化の数と、その実装サイズの比率で期待以上の働きをする言語に惹かれるね。Forth、Tcl、Luaなんかが思い浮かぶ。<br>まあ、それはただ俺の好みだけどね。開発者とその所属組織は自分たちで選択するんだ。" userName="RetroTechie" createdAt="2025/05/14 13:57:18" color="">}}




{{<matomeQuote body="＞ ここでの本当の選択肢はこうだ：プログラマーのコードを事前にアセンブリにするか、ランタイムでそうするか（アセンブリがプログラマーのコードを解釈する）。あるいはJITコンパイルみたいな中間。<br>言語が好むコンパイル/インタープリタモデルは、大まかに言って、その型システムや、開発速度、正確性、パフォーマンスのどれを重視するかとは直交するね。<br>それに、多くの言語は実際には様々なコンパイル/インタープリタモデルを使って実装できる。例えばCのインタープリタもあるし、Javaの事前機械語コンパイラもあるよ。" userName="MaxBarraclough" createdAt="2025/05/14 20:45:58" color="">}}




{{<matomeQuote body="＞ だから、高レベル言語っていうのは、面倒で嫌なアセンブリコーディングをもっと palatable にする方法だと言えるね。<br>うん、スクリプト言語のポイントはほとんどが動的型付けと動的バインディングだね。これはランタイムでバインディングを解決するってことで、実行が遅くなるってことだ。<br>銀の弾丸なんてない：速度が欲しいなら、速い機械語にコンパイルされる扱いにくい言語が必要だ。<br>使いやすさとか手間のかからなさが欲しいなら、遅い言語になるよ。" userName="sph" createdAt="2025/05/14 16:20:13" color="#45d325">}}




{{<matomeQuote body="動的な問題には、動的言語の方が間違いなく使いやすいね。<br>静的に分かりきってる問題には、必ずしも使いやすいわけじゃない。<br>静的言語は正確さと速度でメリットがある。<br>キーワードは「動的」だね。" userName="static_void" createdAt="2025/05/14 18:16:27" color="#38d3d3">}}




{{<matomeQuote body="経験が少ないって言葉は違ったかも。1998年に書いてるって考えると、視野が限られてたって言いたかったんだ。<br>前のコメントへの補足説明だね。意図が伝わるように訂正してる。" userName="johnecheck" createdAt="2025/05/15 01:42:54" color="">}}




{{<matomeQuote body="この議論でいつも分かんないのはさ、全部理解してないデータをどれくらい渡してるの？<br>あと、型使う人が結局リフレクションで型パターンマッチングするようになるけど、それってユーザーレベルから型システムに型付けを移しただけで、あんまりメリットない気がするんだよな。" userName="MadcapJake" createdAt="2025/05/14 13:44:33" color="">}}




{{<matomeQuote body="”全部理解してないデータをどれくらい渡してるの？”<br>いつでもでしょ。プログラムが大きくなると、どこで何が渡されてるか、全部把握なんて無理になるんだ。<br>”あと、型使う人が結局リフレクションでパターンマッチング…”<br>それはツールとして使う場合であって、デフォルトは型をちゃんと使うことじゃない？" userName="coldtea" createdAt="2025/05/14 14:57:36" color="#ff5733">}}




{{<matomeQuote body="”全部理解してないデータをどれくらい渡してるの？”<br>例えば、同僚が1週間頑張ってコミットした新しいコードを使う時とかね。" userName="nottorp" createdAt="2025/05/14 16:50:03" color="">}}




{{<matomeQuote body="ほとんどの人は型パターンマッチングにリフレクションを使ったりしないよ。だって、型が変わったときにバグを仕込んだ場所で、すごく分かりやすいエラーが出るんだから。" userName="duped" createdAt="2025/05/14 19:51:43" color="">}}




{{<matomeQuote body="でもさ、本当に制限が少ない言語もあるよ。Javaのごちゃごちゃに比べたら、Pythonで気にしなきゃいけないことはずっと少ないんだ。<br>問題を先送りしてるって言われるかもだけど（そうかもね）、多くのスクリプティング用途では全然アリだよ。" userName="7thaccount" createdAt="2025/05/14 12:12:18" color="">}}




{{<matomeQuote body="うーん、そうとも違うとも言えるかな。GCやRust借用チェッカーみたいに、言語で制限の違いはある。<br>でも、問題は擬似コードの時点で型があるんだから、コードにする時に型を合わせるのは一緒。エラーが実行時かコンパイル時かの違い。俺はコンパイル時エラーが好きだ。大規模開発では超重要。<br>PythonとJavaの心配事の違いは、型チェックのタイミングじゃないと思うな。" userName="johnecheck" createdAt="2025/05/15 10:33:29" color="#45d325">}}




{{<matomeQuote body="Pythonだとボイラープレートほぼゼロでタスクできる。ループとオブジェクト、ライブラリ呼び出しだけで。クラスも使わないこと多いし状態はグローバル。<br>Javaだと同じことするのにすごい量になるんだよ。儀式が多いよね。<br>GCの制限はあるけど、主にスクリプティングのニーズでPythonは優れてる。その分野でPythonが一般的でJavaがそうじゃないのは理由があるんだよ。" userName="7thaccount" createdAt="2025/05/15 13:49:21" color="#ff5c5c">}}




{{<matomeQuote body="”型なし言語は制限少ないから開発速い”？<br>コード書いてる時は分かんないことの方が多い。強い型付け言語は、何やりたいか分かってない段階で型に集中させられる。<br>データを型にはめるのは、データ構造が落ち着いてもう変わらないと確信できた時。<br>まず動くコードを書いて、次に正しく、速くって進める。弱い型付けはプロトタイピングに使って、後で型付けしてしっかり書くんだよ。" userName="yason" createdAt="2025/05/14 12:44:46" color="#38d3d3">}}




{{<matomeQuote body="どんな問題の解決策も型で記述されるんだよね。型チェックは実行時でもコンパイル時でもできるけど、意味あるプログラムには型がある。もし文字列を引数に取る関数があって、型システムがint渡しちゃうプログラム動かせるなら、それって「素早いイテレーション」できたの？早く動くのは確かだけど、結局「関数はstringなのにintが来た」って同じ型エラーにぶち当たるじゃん。大規模なコードだと、型チェック満たすのがイテレーションを遅くするって意見もあるだろうけど、静的型付けなら他の場所で引き起こした型エラーのリストを計算できるのは明らかにお役立ちだよ。" userName="johnecheck" createdAt="2025/05/15 01:57:14" color="#ff33a1">}}




{{< details summary="もっとコメントを表示（1）">}}

{{<matomeQuote body="言語っていつも独自の制約を導入するよね。Javaだとどんな数値型にも効く関数は作れなくて、型指定しなきゃダメ。でもHaskellならできる。HaskellだとListにテキトーなものは入れられないけど、Javaなら全部オブジェクトなら大丈夫。ああいう言語の制約は、それに合わせて設計したりコード書いたりしなきゃいけないから開発を遅くする。みんなは余計な設計やコードを、安全性が上がる良いトレードオフだって見てるけど、気軽にいじくり回したい時は速度を落とすんだよ。" userName="stonemetal12" createdAt="2025/05/14 14:16:10" color="#45d325">}}




{{<matomeQuote body="ぶっちゃけ、そんな大差ないんだよね。JavaでObjectにキャストする必要があるみたいに、HaskellではDynamicでラップできるんだ。リンク貼っとくね。" userName="tome" createdAt="2025/05/14 19:30:45" color="">}}




{{<matomeQuote body="二分論は断言できない。Typescript足したJSは複雑になるし。<br>コンパイル/解釈は実装詳細だけど、コンパイル言語は型を足す傾向あり構文も寄る。「型なしが速い」はトレードオフ。動的型付けでエラーを後回しにするのは問題探索時に超役立つんだ。不明確な問題に厳しい型制約は邪魔。<br>実行前エラー検出が良いのは、探索的開発を邪魔しない場合に限るよ。" userName="coldtea" createdAt="2025/05/14 14:47:52" color="#785bff">}}




{{<matomeQuote body="この投稿マジ好き。プログラミング言語読むとプログラミングの考え方変わるよね。TAPLの「安全な言語は、プログラミング中に自分で自分の足を撃てないようにする言語だ」って引用をよく思い出すんだ。<br>もっと言うと「安全な言語は、それ自身の抽象を保護する言語だ」。安全性っていうのは、言語やプログラマーが作った抽象の整合性を保証する能力のこと。例えば、配列を更新操作以外では変えられないようにするとか、そういうことだよ。リンクはこれ。" userName="kierangill" createdAt="2025/05/14 12:44:51" color="#38d3d3">}}




{{<matomeQuote body="ちょっと変わった開発方法で面白い話だけどさ…APLで超有名なAaron Hsuさんは、考えをまとめる時に万年筆でカリグラフィーみたいにコードを書きまくるらしいよ。俺も似たようなことやるけど、汚いBicボールペンでPythonオブジェクトのフローチャート書く感じ。なんか貧乏人のUMLみたいだよね。" userName="7thaccount" createdAt="2025/05/14 12:15:59" color="">}}




{{<matomeQuote body="俺も一番難しい問題にぶち当たると万年筆に頼るよ。あれ、完全に別の頭のスイッチ入れてくれるんだ。編集能力が限られてる分、より筋道だった線形的な思考を強いられるんだけど、英語とかコードとか数学とか図をシームレスに切り替えられる自由さもあって、創造性が開花するんだよね。" userName="cvoss" createdAt="2025/05/14 14:14:32" color="#ff5733">}}




{{<matomeQuote body="手書きと記憶力には関連性があるって証明されてるんだって。PCでメモるのは手すりに指紋残すみたいなもん。OCR技術がめっちゃ良くなって、手書きだけで完璧に保存・検索できるようになればいいのに。" userName="sph" createdAt="2025/05/14 16:32:46" color="">}}




{{<matomeQuote body="Rich Hickeyの講演（特に初期のやつ）を見るのもマジでおすすめだよ。あれ見たらプログラミングのこと、考え方マジで変わったもん。" userName="jwr" createdAt="2025/05/14 09:47:44" color="#38d3d3">}}




{{<matomeQuote body="”Simple made easy”は飛ばしていいよ。この10年間、カンファレンススピーカーがみんな引用するの聞き飽きたんだもん。お決まりになっちゃった。（もちろん冗談だよ。俺は”Hammock driven development”の方が断然好きだけど、あんまり会社向きじゃないね）" userName="sph" createdAt="2025/05/14 11:34:05" color="">}}




{{<matomeQuote body="そう言うけどさ、中堅エンジニアにもっと良いコードについて理解してほしいことがあるとすれば、それはSimpleとEasyの区別だね。" userName="cnity" createdAt="2025/05/14 12:28:37" color="">}}




{{<matomeQuote body="俺にとっては、Larry Wallの”Programming Perl”と並んでマジで一番影響あったね。" userName="cutler" createdAt="2025/05/15 00:01:21" color="#45d325">}}




{{<matomeQuote body="最近ここでclosureベースのインタプリタで高速化するいい投稿があったんだよ。<br>https://news.ycombinator.com/item?id=43595283<br>その技術でBrainfuckインタプリタをおもちゃで作ってみたら、結構速かったんだ。他で使うチャンスがあるかは分かんないけど、実験してみるのはとにかく役に立ったね。<br>https://github.com/skx/closure-based-brainfuck-vm" userName="stevekemp" createdAt="2025/05/14 15:15:37" color="">}}




{{<matomeQuote body="closureの配列と、function pointerとdataが交互に入ってる配列の違いにめっちゃ興味あるんだよね。後者はほとんどの言語だとあんまり自然じゃないから、Cみたいなのがないと意味通じないんだけど。でも勘だけど、static functionとdataが同じ配列にある方が、cacheとの相性いいんじゃないかなって思う。" userName="codr7" createdAt="2025/05/14 17:36:02" color="">}}




{{<matomeQuote body="AbdulazizがKuwaitに戻ってから静かになっちゃったのは残念だね。2009年にMaxine VMで俺たちのインターンだったんだよ。めっちゃいい奴で、あの論文はマジで宝物だよ！" userName="titzer" createdAt="2025/05/14 12:42:22" color="">}}




{{<matomeQuote body="知ってるよ :( でもパン屋さん始めて、うまくやってるみたい。だから、ある意味、彼は夢を叶えてるんだね" userName="tekknolagi" createdAt="2025/05/14 12:46:49" color="">}}




{{<matomeQuote body="この人好きだから、悪く言うつもりは全然ないんだけどさ、これらの（元の記事で紹介されてる）内容ってPL（プログラミング言語）じゃなくて全部compiler（GCのやつ以外ね）についての話なんだよ。それはそれで別にいいんだけど（俺compiler好きだし）、とにかくPLについては全く関係ないんだ。" userName="almostgotcaught" createdAt="2025/05/14 12:40:40" color="">}}




{{<matomeQuote body="誰かさ、これのさ、もっと高レベルな言語、例えば JavaScriptとか.NETとかで書いてくれないかなー。この記事書いた人、すごい賢いんだろうけど、俺たちが普段扱ってるレベルよりずっと低レベル（高レベル？）でやってるんだよね。" userName="deanebarker" createdAt="2025/05/14 10:35:39" color="">}}




{{<matomeQuote body="pytypeってさ、byterunに部分的に基づいてるんだよ。開発に携わってバイトコードインタプリタのこといっぱい学べたし、pythonで翻訳したやつで先に遊んでたから、cpythonのソースコードもずっと理解しやすくなったんだよね。" userName="zem" createdAt="2025/05/16 12:30:49" color="#45d325">}}




{{<matomeQuote body="microgradについてなんだけど、Githubリポジトリのソースコード以外に、もっとドキュメントとかある？" userName="AlphaGeekZulu" createdAt="2025/05/14 06:32:42" color="">}}




{{<matomeQuote body="彼（Andrej Karpathy）がさ、youtubeでそれどうやって作ったかのシリーズ出してるよ！" userName="1_08iu" createdAt="2025/05/14 06:51:26" color="#ff5733">}}

{{</details>}}



[記事一覧へ]({{% ref "/posts/" %}})
