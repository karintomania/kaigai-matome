+++
date = '2025-06-03T00:00:00'
months = '2025/06'
draft = false
title = 'プログラミング言語のエラー処理 構文サポートの有無で何が変わる？'
tags = ["プログラミング言語", "エラー処理", "Go", "言語設計", "トレードオフ"]
featureimage = 'thumbnails/light_colour1.jpg'
+++

> プログラミング言語のエラー処理 構文サポートの有無で何が変わる？

引用元：[https://news.ycombinator.com/item?id=44171677](https://news.ycombinator.com/item?id=44171677)




{{<matomeQuote body="この記事のスレッドでGoチームができたはずだって簡単に提案してる人が多いけど、記事にあるGo2エラーハンドリングのwiki（https://go.dev/wiki/Go2ErrorHandlingFeedback）とか、GitHubのissue検索（https://github.com/golang/go/issues?q=+is%3Aissue+label%3Aer...）を見てみてほしいな。<br>君が提案してること、絶対初めてじゃないし、すごく深く検討されてたことがよくあるんだ。<br>Goチームの誠実なアプローチには感謝してるし、毎日仕事でGoを使うのを楽しんでるよ。" userName="threemux" createdAt="2025/06/03 17:24:17" color="">}}




{{<matomeQuote body="フィードバックの元になってる設計ドラフトにはC++, Rust, Swiftの話は出てるけど、君がリンクした膨大なフィードバック文書には、Haskell/Scala/OCamlで使われるdo記法/for-comprehensions/monadic-letみたいなのは見つけられなかったな。<br>GitHubのコメントが多いissueの最初の数ページにもそういうのはなかった。<br>Goチームを言語設計の魔法使いみたいに言ってるけど、他の人が簡単に提案してることも検討済みだろうってのはどうかな。<br>GoチームはJavaと同じ失敗（静的型付けなのにパラメトリック多相がないこと）をしてるのを忘れちゃいけない。<br>これがエラーハンドリング問題の根源で、彼らはもう匙を投げてる感じだね。" userName="hackingonempty" createdAt="2025/06/03 18:51:25" color="">}}




{{<matomeQuote body="どこかで答えが出てるかもしれないけど、Goで特に問題になるのはなんでかなって興味あるんだ。<br>他のほとんどの言語はもっと良い方法を持ってるのにね。<br>色々なアプローチがあるのに…問題は単に決められないとか、みんなを満足させられないってこと？<br>それともGoっていう言語に特有の、他の言語の解決策がうまくいかない理由があるのかな？" userName="anentropic" createdAt="2025/06/03 18:45:12" color="">}}




{{<matomeQuote body="これはGoへの批判でよくあるパターンだね。<br>Go開発者より自分の方がプログラミング言語について知ってると思い込んでるアマチュアの人たち。<br>でも実際はほとんどの場合、彼らの方が比較にならないほど知ってるんだ。<br>アマチュアはナイーブに、機能がたくさん詰まった言語が一番だと思ってて、特に自分のお気に入りの機能があればそう思う。<br>まるで、初めてナイフを作るアマチュアが日本のシェフナイフを見て、物足りないと思って、指溝とか隠しコンパートメント、ライター、Bluetoothスピーカー付きの3Dプリンター製ハンドルで「もっと良いの作れる！」って考えるみたいな感じだね。" userName="philosophty" createdAt="2025/06/03 20:03:45" color="">}}




{{<matomeQuote body="ちなみに、僕はプログラミング言語をいくつか設計したことがあるし、人気のある言語のうち2つの設計に少し貢献したことがあるよ。<br>Goの設計の選択肢の多くは理解できるし、知的に魅力的だと思うけど、実際にはあんまり好きじゃない傾向にあるんだ。<br>でも、Goのエラーハンドリングについての不満は、`if err != nil`自体じゃないんだ。<br>それは冗長だけど読みやすい。<br>僕の不満は：<br>1. エラーと一緒に無効な値を返すこと。<br>2. エラーが主にログ目的だと想定して、ハンドリングできるエラーを開発するにはかなり頑張らないといけないように設計されてること。" userName="Yoric" createdAt="2025/06/03 23:24:23" color="#ff33a1">}}




{{<matomeQuote body="＞ エラーと一緒に無効な値を返すこと。<br>特にドキュメントで指定されてない限り、非nilエラーは他の戻り値を全て無効にするから、非nilエラーと一緒に“無効な値”があるっていう感覚は実際にはないんだ。<br>＞ エラーが主にログ目的だと想定して、ハンドリングできるエラーを開発するにはかなり頑張らないといけないように設計されてること。<br>Goの仕様や意図、そして一般的に実践されているGoのエラーハンドリングを誠実に分析したら、どうやったらこの結論に至るのか僕には分からないな。" userName="kiitos" createdAt="2025/06/04 03:40:31" color="#45d325">}}




{{<matomeQuote body="Goにはコントロールフローを隠さないみたいな特定の目標があるんだ。<br>これは、これまでの人々が考えた方法だと、そういう目標に反することになるだろうね。" userName="ok_dad" createdAt="2025/06/03 18:49:06" color="">}}




{{<matomeQuote body="Try（?演算子）がどうやって隠されたコントロールフローになるのか分からないな。<br>それは簡潔だけど、隠されてはいないよ。" userName="tialaramex" createdAt="2025/06/03 18:52:59" color="">}}




{{<matomeQuote body="僕もGoはジェネリクスを最初から入れるべきだったと思うよ。<br>でも、Javaと同じ失敗をしたって君が簡単に言うのは、彼らがRustやSwiftのような失敗をして、型システム 때문에 악몽 같은 컴파일 시간이 걸리게 된 것을 간과하고 있네（ここは原文にない韓国語が入ってしまっているので修正）。<br>でも、Javaと同じ失敗をしたって君が簡単に言うのは、彼らがRustやSwiftのような失敗をして、型システム 때문에 악몽 같은 컴파일 시간이 걸리게 된 것을 간과してるね。<br>（再度修正）<br>でも、Javaと同じ失敗をしたって君が簡単に言うのは、彼らがRustやSwiftのような失敗をして、型システム 때문에 엄청난 컴파일 시간이 걸리게 된 것을 간과してるね。<br>（再度修正）<br>でも、Javaと同じ失敗をしたって君が簡単に言うのは、彼らがRustやSwiftのような失敗をして、型システムのために悪夢のようなコンパイル時間がかかるようになったことを無視してるね（日本語に修正）。<br>ほとんど全ての言語機能には難しいトレードオフがあるんだ。<br>彼らはイテレーション時間を最優先機能として、そういう言語を設計したんだよ。<br>紙の上で言語を見る人にとっては、その機能を過小評価するのはすごく簡単だけど、ユーザーと話したり、彼らが作業するのを見ると、速いフィードバックループが、君が想像できるどんなに素晴らしい型システム機能よりも彼らを生産的にするんだって気づくんだ。" userName="munificent" createdAt="2025/06/03 22:49:02" color="#45d325">}}




{{<matomeQuote body="僕の意見：それは構造化されたコントロールフロー（つまり分岐がある）のように振る舞うけど、構造化されたコントロールフロー（つまり分岐があるように見えない、中括弧がない）のようには見えないからだよ。<br>Goのプログラミング言語には他にこういうケースは一つもないと思う。<br>例えば、条件付き三項演算子すら持ってないんだ。" userName="jchw" createdAt="2025/06/03 19:25:14" color="">}}




{{<matomeQuote body="Goのエラー処理、エラーがnilじゃなかったら他の戻り値は全部無効になるんだって。でも型を満たすために何か返さなきゃいけないのがヤダって意見と、実際によく使うerrors.Newとかは条件分岐しにくいって指摘があるね。Goはエラーも型定義してキャストしろってことらしいけど、それがまた大変だし。Goのエラー処理はログ向けで、ちゃんとハンドリングできるエラーを作るのは大変だって設計思想に見える、って批判に、いやそれはGoの意図と違うし実態とも違うだろ、って反論もあるよ。" userName="packetlost" createdAt="2025/06/04 05:04:45" color="#38d3d3">}}




{{<matomeQuote body="GoチームがJavaと同じ失敗をしたなんて言うなって話で、Goはずっとジェネリクス取り組んでたけど、Javaみたいにならない良いデザイン見つけるのに苦労しただけなんだって。Javaチーム自身も、Goに「ウチらみたいになるなよ」って忠告したらしいよ。" userName="9rx" createdAt="2025/06/03 19:03:07" color="">}}




{{<matomeQuote body="Goは型アサーション（`switch x.(type)`とか）を全然推奨してない、あれは非常手段だって。エラーで特にそうだってさ。あと、エラー条件で分岐する必要なんてほとんどないって意見も。90%は`err != nil`で十分、9%はerrors.Isでいけるし、それはfmt.Errorfでも可能だよって。" userName="kiitos" createdAt="2025/06/04 06:55:47" color="#ff33a1">}}




{{<matomeQuote body="この記事、頭良い人たちが何年も議論して書いたのに、HaskellのMaybeとかEitherモナドに全く触れてないのが不思議だって。エラーを伝播させるのにすごくエレガントで関数型的な方法なのに、Haskellでは当たり前なのに、なんでGoコミュニティの誰も知らないし評価しないんだ？って疑問を呈してる。記事の存在自体は評価しつつ、なんでこの解決策を飛ばすんだ、って混乱してるみたい。" userName="yusina" createdAt="2025/06/03 19:39:35" color="">}}




{{<matomeQuote body="明白な解決策はJavaみたいなtry-catchだろって意見。この記事で全然触れられてないけど、それってtry-catchなら無かったような欠点を挙げることで、try-catchの良さを認めたくないから隠してるんだろ…ってちょっと穿った見方をしてるね。" userName="_kidlike" createdAt="2025/06/04 05:01:02" color="">}}




{{<matomeQuote body="型アサート/switchはerrors.Isを自分で実装する時に使うんだよ、特にカスタムエラータイプ作る時はね。errors.Newを直接使うと文字列比較になっちゃうのは事実。<br>あと、90%は`err != nil`で十分って言うけど、IO扱うアプリならもっと頻繁に特定エラーでの分岐が必要だろって反論。HTTPとかファイルシステムとか、タイムアウトでリトライとかしたいでしょ、って具体的な例を挙げて、単純なnilチェックだけじゃダメな場合が多いって言ってるよ。" userName="packetlost" createdAt="2025/06/04 08:07:31" color="#785bff">}}




{{<matomeQuote body="try/catch（例外）は嫌だって意見。理由として、どこでエラーが飛ぶか分かりにくい、スタック巻き戻しで制御フローが複雑になる、IOエラーみたいな普通のエラーには向かない（関数が例外投げるか分かりにくい）などを挙げてる。Javaのchecked exceptionはみんな嫌がるし、Goのエラーもこの点では似た欠点があるけど、RustのResultやC++のstd::expectedみたいにエラーを値として扱う方向は良いし、Goも例外よりマシだってさ。Goに例外がないのは間違いじゃなくて意図的だ、と締めくくってる。" userName="jchw" createdAt="2025/06/04 05:59:34" color="#785bff">}}




{{<matomeQuote body="Goにも例外（panic/recover）はあるし、標準ライブラリ（例えばencoding/json）でも使われてるよって指摘。普通の用途では使われないけど、トレードオフを受け入れれば有効な方法だって。RubyでRuby on Railsが出てエラー処理の考え方が変わったみたいに、Goも将来変わるかもね、って言ってるよ。" userName="9rx" createdAt="2025/06/04 17:29:41" color="">}}




{{<matomeQuote body="いや、同意できないな。“例外”って何を指すかって議論になるけど、専門用語っていろんな意味で使われるんだよ（例えば、CPUの例外処理はプログラミングの“例外処理”と関係ない）。現代のプログラミング言語の例外処理は、その処理専用の構造化された制御フローがあるタイプのことを指すと思うんだ。Goにはpanicとrecoverを使ったスタック巻き戻しがあるけど、あれはただの普通の関数で、tryもcatchもthrowも、それに相当するものもない。C言語にもsetjmp＼longjmpがあって似たように使えるけど、それも例外処理とは呼ばないと思う。<br>でも、どっちの専門用語が主観的に正しいかって長い議論をしても得るもの少ないから、この件は意見が違うってことで合意しないとね。ただ、俺がどういう考えから来てるか説明したかっただけだよ。" userName="jchw" createdAt="2025/06/04 19:58:31" color="#ff5733">}}




{{<matomeQuote body="＞ みんなを満足させる／決められないのが問題なのか？<br>この記事読んでるって？ 実はそう（？）なんだよ。<br>＞ 何年も何年も試行錯誤してきて、Goチームからの本格的な提案が3つ、そして文字通り数百（！）ものコミュニティからの提案、そのほとんどが似たようなアイデアだったけど、どれも十分な（ましてや圧倒的な）支持を得られなかった。それで今、俺たちが直面してる問題はこれ：どう進めるべきか？そもそも進めるべきなのか？<br>＞ 俺たちは違うと思う。<br>これはGoの設計者の問題なんだよ。理想とする完璧な解決策がないから、実現可能な解決策を受け入れられないって意味でね。<br>そして、そんな解決策は絶対に見つからない。<br>____<br>俺は20以上の言語を使ってきたし、自分で言語を作ろうとしたこともあるけど、これは本当に未解決の問題で、最善の方法はどれか一つを選んで、他のケースでは大きなコストがかかることを受け入れるしかないんだ。だけど、Goの現在の方法（C言語の方法からほんの少し改善されただけ）が最悪だってことは知られてるし、他のどんな方法でも確実にマシなんだ（ここまで来ると、Goだけがこんな道を選んだ唯一の狂人だと思うよ！）でも、どんなシナリオでも完璧な方法は存在しないだろうね。" userName="mamcx" createdAt="2025/06/04 01:38:24" color="">}}




{{<matomeQuote body="＞ Errors.Newでエラーを定義すると文字列比較を使う<br>Errors.Newを使う場合、人間が読めるメッセージを提供するのが前提だ。つまり、このメッセージは変わる可能性がある。この文字列比較に頼るのは、後で壊れる元になるレシピだ。でも、たとえそれがうまくいったとしても、関数が返す正確なエラー文字列をドキュメントに残す必要がある。そんな情報がドキュメントに含まれてる関数を、お前は見たことがあるか？<br>switch x.(type)に関しては、unwrapみたいな機能は一切サポートしてない。だから、スタックの誰かが途中でfmt.Errorfを挟んだら、それで失敗するんだ。つまり、スタックの関数全部が、エラーが発生したときに何をしてたかを詳細に説明するような注釈を絶対に追加しないって約束する必要がある。これは残念だよ、だってfmt.Errorfは良いプラクティスだってよく言われるのに。" userName="Yoric" createdAt="2025/06/04 08:32:45" color="#ff5c5c">}}




{{<matomeQuote body="＞ Goのエラーが言語とそのドキュメントでどのように指定／意図されているか、あるいは実際にGoでエラー処理が一般的にどのように存在しているかについて、誠実な分析で、どうしたらこんな結論に至るのか理解できない。<br>俺の主張を詳しく説明させてくれ。<br>おおまかに言って、プログラミングには3種類のエラーがある：<br>1. クラッシュする以外何もできないエラー。<br>2. ログを出す以外何もできないエラー。<br>3. 何か対処できるエラー（例えば、後でリトライする、エラーに応じて別のサブシステムを停止する、何か別の方法を試す、ユーザーに間違ったURLを入力したことを知らせる、これを詳細なHTTPエラーに変換するなど）。<br>ケース1はpanicで対応できる。ケース2はerrors.Newとfmt.Errorfで対応できる。ケース3はerror（特別なインターフェース）を実装してUnwrap（インターフェースではない）を使い、errors.Asを使うことで対応できる。<br>ケース3はちょっと冗長で扱いにくいけど（Unwrapはインターフェースじゃないから静的にアサートできない、だから自分でインターフェースを書く必要がある）、これで作業はできる。だけど、思い出してみてくれ、GoにはUnwrapやerrors.Asは最初からなかった。言語ができて最初の8年間、これをやる方法は全くなかったんだ。だからエコシステム全体（stdlib含む）は、それをやらないように学んだんだ。<br>結果として、適当なライブラリ（stdlibの大部分含む）を見てみれば、まさにそういうのが見つかる。errors.Newやfmt.Errorfで返す関数、あるいはただerrをそのまま渡す関数で、エラーを処理する能力を何も加えていない。あるいは、カスタムエラーを返す関数（良いこと）でも、それをドキュメントに残さなかったり（悪いこと）、プライベートにしてたり（悪いこと）する。<br>同じくらい悪いことに、（限られたサンプルだけど）話を聞いたGo開発者の多くは、カスタムエラーの定義をブラックマジックだと思ってるらしい。これはかなり悲しいと思うね、だってそれはAPI設計の核となる部分なのに。<br>それに比べて、if err != nilは問題じゃないと思うんだ。コード中の繰り返しのパターンは、経験豊富な開発者にとってはちょっとした煩わしさだけど、初心者にとっては歓迎されるお馴染みの風景だよ。" userName="Yoric" createdAt="2025/06/04 08:26:48" color="#ff5733">}}




{{<matomeQuote body="＞ Javaが犯した大失敗<br>素人向けに、Java genericsの何が悪いのか教えてくれ。（C# genericsにも同じ問題は当てはまるのか？）俺はC++からJavaに来たけど、Java genericsは結構使いやすいと思ったんだ。「PL（プログラミング言語）の人たち」がどう言おうと興味ないね。彼らは自分の推してる誰も使ってない言語以外の全ての汎用／パラメータ多相の実装を嫌ってるからな。俺は、素人が学ぶのが簡単でうまく使える、実用的なことに興味があるんだ。<br>＞ Javaチーム自身がGoチームにその間違いをしないように警告した<br>そのソースはあるのか？" userName="throwaway2037" createdAt="2025/06/04 03:22:55" color="">}}




{{<matomeQuote body="＞ しかし、Goの現在のやり方（Cの方法からわずかな改善）が最悪であり、他のどの方法も本当に優れていることが知られている […]<br>これは、これほど主観的なことに対して大胆な発言だな。エラー処理の現状維持を提案する案が、Goの提案の中で最も好意的に投票されたものの一つであるhttps://github.com/golang/go/issues/32825 であることは注目に値するよ。<br>Goの言語設計は人気投票や民主主義じゃない（投票権を誰に与えるか明確じゃないからな、というのもある）。だが、数千もの絵文字投票があって、その90%が賛成してるような他の提案は、まず見つからないだろうね。<br>批判は理解できるし、ある程度は同意するよ。だが、その批判を客観的かつ普遍的なものとして断言するのは、情報不足だ。" userName="Merovius" createdAt="2025/06/04 11:05:07" color="#ff5733">}}




{{<matomeQuote body="＞ 「例外」って何を指すかで議論できる<br>議論の余地があるか？俺が出会った全ての定義によれば、例外とは、コンパイラがコンパイル時に十分な能力でエラーを判断できなかった場合に、実行時情報（スタックトレースなど）を含むデータ構造のことだ。それ以外の意味は、道理からいってありえない。<br>もちろん、俺たちが本当に話してるのは「例外ハンドラー」であって「例外」じゃないんだけどね。<br>＞ tryもcatchもthrowも、それに相当するものもない<br>名前の上で、そして合理的な同等性において、それらはありうるんだよ：https://go.dev/play/p/RrO1OrzIPNe<br>でも、それが何をもたらすのか俺にはよく分からないんだがね。機能的には何も変わってないだろ。だから、構文の重要性には納得できないんだ。<br>考えてみてくれ。Goは簡単にtry { throw() } catch (err) {} を try(func() { throw() }).catch(func(err) {}) に置き換える構文糖衣を提供できるんだ。それはあらゆる点で、お前の要求を本当に満たすだろう。だが、その単純な置換操作の具体的に何が「例外」（つまり例外ハンドラー）だと言えるんだい？<br>＞ Cにもsetjmp＼longjmpがあって似たように使えるけど、それも例外処理とは呼ばない<br>同意だ。setjmp＼longjmpを使って独自の例外を仕込むことは考えられるだろうが、それは言語機能ではない。しかし、Goには組み込みで例外の構造がある。" userName="9rx" createdAt="2025/06/04 20:30:09" color="#38d3d3">}}




{{<matomeQuote body="`errors.Is` って実装が文字列比較なんだって。`errors.New` で作ったエラー型とカスタムエラー型で挙動が変わるらしいよ（stdlibがカスタム型を定義する場合もね）。" userName="packetlost" createdAt="2025/06/04 14:34:25" color="">}}




{{<matomeQuote body="Rustはチェックリスト作って全部潰してから機能安定化するじゃん。Goは完璧な提案があっても決められなくて、エラー処理みたいな誰でも困る問題も解決できないままなんだよね。これじゃあプロセスが茶番だって言われても仕方ないよ。" userName="pie_flavor" createdAt="2025/06/03 17:06:40" color="#ff5c5c">}}




{{<matomeQuote body="Rustが読みにくいとか構文が一貫性ないって評判なのって、design by committee だからだよ。" userName="arccy" createdAt="2025/06/03 18:05:54" color="">}}




{{<matomeQuote body="「完全で完璧な提案」なんて主観じゃん。Goのエラー処理って、Goのデザイン思想と開発者にとって一番マシな選択肢なんだよ。V言語みたいなスタイルもいいけど、実際に実装するのは大変だろうしね。" userName="GoatInGrey" createdAt="2025/06/03 18:31:22" color="#ff5733">}}




{{<matomeQuote body="いやいや、Goの現状は全然マシじゃないって。Rustみたいにボイラープレートのための演算子が必要だよ。Coxの提案とか他のも良かったのに、何もやらないのは良いことじゃない。問題を解決せず、意図的にブロックしてるだけじゃん。" userName="pie_flavor" createdAt="2025/06/03 18:48:22" color="#45d325">}}




{{< details summary="もっとコメントを表示（1）">}}

{{<matomeQuote body="エラー処理が「全部ボイラープレート」なわけじゃないし、Rustの決定がGoに当てはまるわけでもないよ。今のGoのエラー処理はちゃんと機能してるし、Goの元々の設計思想から見れば、他の提案よりマシなんだってば。" userName="kiitos" createdAt="2025/06/03 20:46:53" color="#ff33a1">}}




{{<matomeQuote body="`foo, err := someExpr`<br>`if err != nil {`<br>    `return nil, err`<br>`}`<br>このコードが全部ボイラープレートなんだって！Rustは`?`でこれを解決したじゃん。Goの今の状態は`?`導入前のRustよりひどいよ。Goのデザイン思想的にこれで良いって言う人がいるけど、Goだって`iota`とか`http.HandleFunc`とか便利機能あるじゃん。Goの間違いを認めない人多いけど、後から間違いってわかること結構あるんだよね。" userName="pie_flavor" createdAt="2025/06/04 01:35:11" color="#ff33a1">}}




{{<matomeQuote body="Goって物事を明示的にする言語じゃん。公開のために大文字にするのって、Pythonが`_`で隠すのとそんな変わらないと思うけど。" userName="arccy" createdAt="2025/06/03 21:29:16" color="">}}




{{<matomeQuote body="Rustの`for`キーワードが、`impl T for for＜’a＞ fn(&’a u8) {}`みたいに色んな意味で使われてて、普通のforループと違うのが変じゃない？個々は分かるんだけど、組み合わせると読みにくいんだよね。" userName="dlisboa" createdAt="2025/06/03 19:16:56" color="">}}




{{<matomeQuote body="Goのエラー処理コードは定型文って言われてるけど、実際は`fmt.Errorf`みたいに文脈加えるから定型文じゃないよ。`？`みたいな短縮記法が良いってのも客観的じゃないし、現状が良いって人もいるんだ。Goに文句言いたい人がboilerplateって言ってるだけだよ。`？`と`iota`とかが似てるって意見は意味不明。" userName="kiitos" createdAt="2025/06/04 02:24:19" color="#38d3d3">}}




{{<matomeQuote body="前は反対だったけど、この議論に同意するようになってきたよ。例えば、Rustの新しい`implicit lifetime capturing`の構文 `fn f(x: &()) -＞ impl Sized + use＜’_＞ { x }` は変だし、記号だらけ。Rustチームが元々考えてたのと違うみたいだしね。" userName="j-krieger" createdAt="2025/06/03 22:30:09" color="">}}




{{<matomeQuote body="GoもRustもエラーに文脈加えるべきだけど、実際は誰もやってないんだよね。Rustはライブラリで対応できる。Goの便利な関数も、ちょっと複雑になると冗長になる。`fmt.Errorf`は実行時検査できないから、真面目にやるなら独自のエラー型が必要だよ。" userName="pie_flavor" createdAt="2025/06/04 02:38:47" color="#ff33a1">}}




{{<matomeQuote body="Goの大文字小文字ルールやPythonのアンダースコアによるプライベート指定ってひどいデザインだと思うんだ。覚えないといけない隠し機能みたいで、マジで余計な負担だよ。名前はシンプルにすればいいのに。" userName="callc" createdAt="2025/06/03 22:20:29" color="">}}




{{<matomeQuote body="Rustが最初から賢いって言うなら、もう議論にならないね。`fmt.Errorf(”annotation: %w”, err)`で十分、`errors.Is`で元のエラー調べられるんだから、カスタムエラー型なんて大抵いらないんだよ。" userName="kiitos" createdAt="2025/06/04 02:50:09" color="">}}




{{<matomeQuote body="Goの唯一の問題がエラー処理だって？違うよ。調査だと13％しか挙げてないし、今のままで良いって人もいるんだ。ほら、ここに公式のサーベイ結果もあるよ。<br>https://go.dev/blog/survey2024-h1-results" userName="hu3" createdAt="2025/06/03 17:13:15" color="#38d3d3">}}




{{<matomeQuote body="Rustを少し触った程度の俺には、`&()`とかライフタイムの`’_`とか、`use`キーワードが何だか全く分からん。他の記号とかは分かるんだけどね。Rustの公式ドキュメントも読んだけど、ちんぷんかんぷんだよ。" userName="joshuamorton" createdAt="2025/06/03 23:16:25" color="">}}




{{<matomeQuote body="そうそう、`return fmt.Errorf(”annotation: %w”, err)`は、ただの`return err`をログ向けにしただけ。エラーをラップするのは実行時に調べるためだよ。" userName="geoka9" createdAt="2025/06/04 18:19:39" color="">}}




{{<matomeQuote body="Rustの`.await`はさ、フィールドアクセスみたいに見えるのに、実際は全然違う動きをするんだよね。" userName="arccy" createdAt="2025/06/03 18:28:58" color="">}}




{{<matomeQuote body="3つの構文（trait実装、forall lifetime、forループ）は、どれも「それの全てにこれをする」って根っこは同じ考え方なんだよ。" userName="steveklabnik" createdAt="2025/06/03 19:36:43" color="">}}




{{<matomeQuote body="設計にはトレードオフがあるんだ。Rustのawaitと?演算子の場合、await foo()? は曖昧だけど、foo()?.await とか foo().await? は順番が分かりやすい。`.await`はフィールドに見えるけど実際問題ないし、視覚的に分かりにくい優先順位とかを避けられたんだ。この構文は成功してて、みんなもっとこんなpostfix形式のキーワードやマクロが欲しいって言ってるよ。" userName="pornel" createdAt="2025/06/04 01:25:25" color="#ff5733">}}




{{<matomeQuote body="これはRustのunit型（()）への参照だよ。Javaのvoidみたいにほとんど役に立たないけど、Rustプログラマーなら分かる短くて簡単な型だから例に使われたんだと思う。実際はこんなコードは書かないよ。" userName="Macha" createdAt="2025/06/04 00:24:32" color="">}}




{{<matomeQuote body="孤立して見ると論理的だっていうのは分かるけど、人は文脈の中で構文を読むもんなんだ。構文トークンをバラバラに読むわけじゃない。だから文脈が全然違うと、読者にとっての根底の考え方だって同じじゃないんだよ。" userName="dlisboa" createdAt="2025/06/03 19:59:06" color="">}}




{{<matomeQuote body="Goのfmt.Errorf はエラーをラップして、その場で関連するコンテキストを追加してるんだ。ただ「ログ向き」ってだけじゃなくて、実は重要なメタデータなんだよ。" userName="kiitos" createdAt="2025/06/06 22:03:30" color="">}}




{{<matomeQuote body="プログラミング言語ってのは設計されたシステムで、全体的に意味が通ってなきゃダメなんだ。「ただ機能リストにチェックつけるだけで追加されるもんじゃない」んだよ。" userName="kiitos" createdAt="2025/06/03 20:43:18" color="">}}




{{<matomeQuote body="これが残りの87%も楽しんでるって意味じゃないんだよ。正直、次の調査では「今のエラー処理のアプローチに満足してますか」って質問を入れてほしいね。" userName="joaohaas" createdAt="2025/06/03 22:55:59" color="">}}




{{<matomeQuote body="エディタによっては`something.await`って書くと勝手に`(await something)`に変えてくれるスニペットあるらしいよ。<br>それならもう最初からその構文で良くね？って俺は思うな。" userName="Macha" createdAt="2025/06/04 12:51:24" color="">}}




{{<matomeQuote body="Rustって新しいキーワード作るより、既存のキーワードを分かりやすいコンテキストで使い回すのが好きなんだってさ。<br>新しいキーワード作ると昔のコード動かなくなったり、同じ名前の変数使ってた人が困ったりするから大変なんだって。" userName="NobodyNada" createdAt="2025/06/03 19:42:50" color="">}}




{{<matomeQuote body="Goでさ、エラーが返ってこないこと<br>を期待する珍しい関数書いた時があったんだよね。<br>そしたら普通と逆で`if err == nil { // エラーを返す }`って書く必要があって。<br>でも普段`if err != nil`に慣れすぎてて、間違えて書いちゃって全然気づかなくてさ。<br>こういう滅多にないケースは、よく使う書き方と区別できる糖衣構文とかあれば助かるのにって思ったよ。" userName="_jab" createdAt="2025/06/03 17:13:18" color="#ff5c5c">}}




{{<matomeQuote body="俺は`if err == nil`って書くときはいつも`// inverted`ってコメント付けて、普通の`if err != nil`と区別するようにしてるよ。<br>言語でサポートしてくれたら一番だけど、とりあえずこれで少しは目立つようになるよ。" userName="adamrt" createdAt="2025/06/03 17:33:58" color="">}}




{{<matomeQuote body="俺も似たようなことしてるよ。コメント残すんだけど、なんで反転させてるのか理由もちょこっと書くんだ。<br>大体「リトライする必要ないから早く抜けるため」とか理由がはっきりしてるからさ。<br>久しぶりにコード読んだ時に、いちいちロジック考え直さなくて済むから助かるんだよね。" userName="hnlmorg" createdAt="2025/06/03 18:49:36" color="">}}




{{<matomeQuote body="Goのことは全然知らないんだけど、`nil == err`みたいに逆さまに書けば目立つんじゃない？昔の経験からだけどさ。" userName="macintux" createdAt="2025/06/03 18:43:21" color="">}}




{{<matomeQuote body="今`nil == err`って書いて試してみたけど、コンパイラもフォーマッタもgolangci-lintも全部通ったよ。有効みたいだね。" userName="haiku2077" createdAt="2025/06/03 20:28:36" color="">}}




{{<matomeQuote body="これ「Yoda conditions」って言うんだ。<br>詳しくはここ見てみて。<br>https://en.wikipedia.org/wiki/Yoda_conditions<br>代入文をifの条件にできちゃう言語で特に役に立つんだよね。" userName="_whiteCaps_" createdAt="2025/06/03 22:00:14" color="#785bff">}}




{{<matomeQuote body="ありがとう、その「Yoda conditions」って名前知らなかったよ。すごく分かりやすい名前だね。" userName="macintux" createdAt="2025/06/03 23:26:08" color="">}}




{{<matomeQuote body="もうちょっとエレガントじゃないかな（俺の主観だけどね）って書き方としては、`if !(err != nil)`ってのもできるよ。" userName="umanwizard" createdAt="2025/06/05 11:52:54" color="">}}

{{</details>}}




{{< details summary="もっとコメントを表示（2）">}}

{{<matomeQuote body="もちろん’if fruit != ”Apple” { ... }’でも全く同じ状況だよな。これを改善する一般的な解決策ってあるの？エラー問題としてだけ見るのはちょっと違う気がするな。だってエラーって他の状態と何も特別違うことなんてないんだし。" userName="9rx" createdAt="2025/06/03 18:15:57" color="">}}




{{<matomeQuote body="その現状がif文の根本的な欠陥をより目立たせるのかもしれないけど、結局問題はif文自体があまり良くないってことなんだよ。それを改善しようと努力するなら、なんでエラーという特定の型だけなの？" userName="9rx" createdAt="2025/06/03 18:46:06" color="">}}




{{<matomeQuote body="それはエラーという型が他のどんな型よりも圧倒的に flawed な方法で使われてるからだよ。他の型でも同じように一貫して最後の返り値で使われるなら、それらにもやる理由はある。実際、Rustの?演算子はまさにそれをやってる。Goだと(T, E)で動くような感じかな。でも3つ以上の返り値だと問題になるけど、非エラー値を一つの型にまとめればボイラプレートは減るだろうね。" userName="saghm" createdAt="2025/06/04 03:33:09" color="">}}




{{<matomeQuote body="狭いケースだけじゃなく全ケースで解決すべきでしょ。(T, bool)もよく見るしなんで他の型も含まないの？コンピュータにエラー概念はない、人間の構築物だよ。Goはzero value言語だからRustのResultは合わないよ。もしそうするなら全く新しい言語を設計することになる。それに3つ以上の返り値の場合((T AND U) XOR E)じゃうまくいかない。(T, bool, error)みたいのもあるしね。" userName="9rx" createdAt="2025/06/04 05:31:46" color="#38d3d3">}}




{{<matomeQuote body="全ケース解決は明らかに無理だよ。Goの設計上難しいし採用されない。一般的な解決策なんて非現実的だ。それが狭いケースを解決する議論の根拠だよ。(T, E)に構文提供するのは人間にとっては改善だよ。一般的に解決しなくても人間の問題を軽減するためならやる価値はあるんだ。" userName="saghm" createdAt="2025/06/04 11:55:35" color="#ff33a1">}}




{{<matomeQuote body="全ケース解決無理ならGoでは無理だね。言語変えるくらいなら他の言語使えよ。GoにはJavaみたいな例外(panic)がある。エラーの狭いケースはこれで十分だよ。問題はエラーじゃなくて全ての型にわたる一般的なケースがダメなことだ。" userName="9rx" createdAt="2025/06/04 12:53:58" color="">}}




{{<matomeQuote body="「Javaスタイルの例外」ってpanicのこと？Syntaxの問題じゃない？根本的な問題を完全に解決するより小さな改善でいいんだよ。あなたは根本的な変更を嫌がるのに根本的な解決が必要だって言ってるのが変。私が言ってるのは根本的な問題を完全に解決しない小さな変更でも現状よりマシになるからやる価値があるってことなんだ。" userName="saghm" createdAt="2025/06/06 11:43:34" color="#45d325">}}




{{<matomeQuote body="Goのエラー処理構文、他言語と大差ないし、それほど悪くないと思うけど？<br>Iteratorと違って、元々みんなが使ってたわけじゃないのに、わざわざ新しい構文作る意味ある？<br>正直言って、もし本当に便利なら、多少構文がイマイチでもみんな使うはずだよ。<br>Goのエラー処理が普及しないのは、Javaの例外みたいに、構文じゃなくて根本的な問題があるからじゃないかな。Javaみたいな特別なケース用のは既にあるしね。" userName="9rx" createdAt="2025/06/06 14:46:48" color="">}}




{{<matomeQuote body="新しい構文に反対。もしできたら、今の `if err == nil { return ... }` って書き方がコードを汚すことになるじゃん？今のやり方で十分だよ。あれが嫌いなのはGo初心者だけ。Goをよく知ってる人は、あの明確で読みやすいエラー処理が好きだよ。" userName="purpleidea" createdAt="2025/06/03 22:08:10" color="#45d325">}}




{{<matomeQuote body="珍しいケースは見た目で分かるってば。`==` と `!=` は全然違うじゃん。<br>多分この人、テスト書くの忘れてて、それをツールのせいにしてるだけじゃないの？" userName="9rx" createdAt="2025/06/04 16:49:29" color="">}}




{{<matomeQuote body="Hacker Newsでこんな話もあるよ→https://news.ycombinator.com/item?id=44172285<br>`if err != nil` が普通すぎて気づかないって。`==`と`!=`はそんなに明確に違わないってことじゃん。<br>テストはあくまでツールだし、テストで問題見つけても、コード読み間違えてデバッグに時間かかることはあるよ。構文ハイライターとかで「ここ普通じゃないよ？」って教えてくれるとデバッグしやすいかもね。" userName="scubbo" createdAt="2025/06/04 18:15:26" color="#ff5c5c">}}




{{<matomeQuote body="「明らかに違う」って言うのを鵜呑みにするのはどうなの？ネットの情報全部が本当じゃないよ。コードなしで議論しても意味ないって。<br>このGoのコード見てよ→https://go.dev/play/p/xEnGTmJ_57g 出力見れば問題点くらい分かるはずじゃない？もっと現実的なコードで話そうぜ。" userName="9rx" createdAt="2025/06/04 19:03:14" color="#ff5c5c">}}




{{<matomeQuote body="ちょっと意地悪な意見だけどね。IDEとフォントを使えば、`if err != nil` って部分を特別な記号（リガチャ）みたいにレンダリングして、目立たなくすることだってできるよ。そしたら、`if err == nil` みたいに違う書き方が逆に目立つようになるじゃん。" userName="derefr" createdAt="2025/06/03 20:50:10" color="">}}




{{<matomeQuote body="コメント7のアイデア、新しい構文（`try` 関数とか）にも同じように使えるんじゃない？<br>エディタが頑張ってくれるなら、最初からもっと短い新しい構文にしちゃえばいいじゃん。Rustの`.await`だって、エディタのおかげで構造体フィールドと間違えないんでしょ？" userName="saghm" createdAt="2025/06/04 03:38:22" color="#ff33a1">}}




{{<matomeQuote body="いい点だね。エディタで `if err ... {` みたいに、エラーチェックの部分を折りたたんで表示するのも解決策になるかも。" userName="skybrian" createdAt="2025/06/03 18:01:35" color="">}}

{{</details>}}



[記事一覧へ]({{% ref "/posts/" %}})
