+++
date = '2025-04-09T00:00:00'
months = '2025/04'
draft = false
title = 'デキるプログラマーが絶対にやらないこと判明！一流エンジニアの共通点とは？'
tags = ["プログラミング", "デバッグ", "問題解決", "情報収集", "スキルアップ"]
featureimage = 'thumbnails/blue_green2.jpg'
+++

> デキるプログラマーが絶対にやらないこと判明！一流エンジニアの共通点とは？

引用元：[https://news.ycombinator.com/item?id=43629307](https://news.ycombinator.com/item?id=43629307)

{{<matomeQuote body="ビジネスで一番大事なのは、多分、当てずっぽうでやらないことだよね。半導体製造で問題解決能力をめっちゃ鍛えたんだ。ここでは、悪い仮定を置くとコストがマジでヤバいことになるから。原因を100%特定できないと、すぐ全てがダメになる。もし原因が特定できないなら、解決しなきゃいけない問題が2つになっちゃうんだ。<br>原因分析を邪魔するような不透明さがあると思ったら、すぐに全部捨てちゃう。だから、標準じゃない技術スタックは極力使わないようにしてる。サードパーティのGitHubリポジトリに深入りするのはマジ勘弁。プロジェクトのスタイルとかモチベーションとか規模感が違いすぎて、マジでサイケデリックな体験になるからね。<br>常にめっちゃ正確であることが、評判を築く一番の近道かも。担当する問題の価値が高ければ高いほど、その効果は指数関数的に上がっていくよ。" userName="bob1029" createdAt="2025-04-09T10:31:15" color="#ff5c5c">}}

{{<matomeQuote body="フレームワークとかライブラリを使わないで、ほとんどのものを自分で作ると、いつもめっちゃ反発されるんだよね。<br>でも、ほとんどのフレームワークとかライブラリって、監査に耐えられるほど堅牢じゃないし、エンタープライズレベルの互換性も保証されてないし、想定外のパフォーマンス問題が起きないとも限らないし。<br>たまに、SQLiteみたいなサードパーティのライブラリは使うけど。「依存しないよりも依存した方が complications が少ない」ってレベルに達するフレームワークとかライブラリってマジで少ないんだよね。" userName="Taek" createdAt="2025-04-09T11:44:44" color="">}}

{{<matomeQuote body="それ賢いね。<br>もし、キミがそういうレベルの堅牢さがマジで必要な会社で働いてるなら、ね。でも、ほとんどの会社はそうじゃないし、そういう会社で働いてる人の多くは「もっとマシな」「もっと重要な」会社で働きたいと思ってるから、必要でもないのに必要だってフリをするんだよね。<br>キミみたいな人が、最先端企業のミッションクリティカルなチームにいたらマジで神。プロジェクトとか会社の成功に大きく貢献するだろうね。でも、誰も知らない会社のCRUDアプリのために独自のORMを作ろうとするヤツは、みんなの時間を無駄にしてるだけ。" userName="pc86" createdAt="2025-04-09T13:52:37" color="">}}

{{<matomeQuote body="＞「誰も知らない会社のCRUDアプリのために独自のORMを作ろうとするヤツは、みんなの時間を無駄にしてるだけ」”<br>昔、オフザシェルフのORMが採用されたプロジェクトに参加したんだけど、開発が進むにつれて、深刻な設計上の欠陥が明らかになったんだよね。API互換性を保った独自のORMを作ろうとした人がいたから（別に喜んでやってたわけじゃないと思うけど）、プロジェクトは救われた。<br>昔の話だけどね。今のORMライブラリはもっとマシになってると思う。でも、SQLiteレベルのライブラリであることを確認してから使うっていうアドバイスは、シンプルなCRUD ORMにも当てはまると思うよ。特にね。" userName="9rx" createdAt="2025-04-09T14:52:02" color="#ff5c5c">}}

{{<matomeQuote body="キミの例みたいに、ORMの特定のエッジケースに遭遇して、それが完全に合理的だと思えるケースもあるけど、実際には「ライブラリを使えば数週間か数日で実装できるものを、何か月もかけて構築する言い訳」として使われるケースが95件くらいあるんだよね。しかも、そういうエッジケースに遭遇すると、「ORMを捨てる」んじゃなくて「そのクラスのクエリにはORMを使わない」ってことになる。<br>昔.NETを使ってた頃のEntity Frameworkで気に入ってたのは、ORMの機能を簡単に抜け出せること。EF固有の関数の中からでも抜け出せるし、少しずつ設定が違うインスタンスを複数持つこともできたんだ（やったことはないけど）。" userName="pc86" createdAt="2025-04-09T15:33:58" color="">}}

{{<matomeQuote body="俺が一番使ってる製品の最初の設計者はEntityFrameworkを選んだんだ。SQL文を見るまで1年半くらい使ってたんだけど、ひどいUNIONの塊だった。簡単なはずのことが10倍も複雑になってた。<br>Dapperと手書きSQL、シンプルなマイグレーションバージョン管理システム、検証付きのデータベースシードに徐々に置き換えていったんだ。それが終わったら、標準的なSSDで起動時間が10秒以上、CFastで約30秒短縮された。データベース接続をSQLite標準ライブラリに置き換えるだけでも2秒短縮できた。<br>EntityFrameworkは便利かもしれないけど、ソフトウェアの起動時間が重要な場合はパフォーマンスが不足してる。" userName="yndoendo" createdAt="2025-04-11T14:27:41" color="">}}

{{<matomeQuote body="Entity Frameworkは他のORMとは別格で、例外はほんのわずかだね。RailsのActiveRecordすらおもちゃみたい。EFは登場時から今ある多くの成熟したORMよりずっと先を行ってたと思うし、95%って数字も納得。でも、EFとかごく一部の成熟したORM以外だと、95%は50%くらいに見えるかも。新しいORMはCRUD以外ほぼ役に立たないし、CRUD部分もPostgREST/Supabase/Hasuraで置き換え可能だと思う。全体的な感覚には同意するけど、最近のORMとかライブラリを過信してる気がする。Entity Framework、ASP.NET、Rails、Postgres、SQLiteの1%にも満たないものばかりだよ。" userName="whstl" createdAt="2025-04-09T22:47:12" color="#785bff">}}

{{<matomeQuote body="Supabaseで対応できない簡単なCRUDのユースケースはまだ見つからないな。ほぼ設定なしで使えるよ。高度な使い方にはPostgresの知識が必要だけど、全体的には素晴らしいプロダクトだよ。authとかblob storageもSupabaseに任せればさらに良いね。Clerkをauthに使ってるけど、他のSupabase製品も使ってて、小規模なユースケースには最適だよ。細かくデータベースの権限を設定する必要が出てきたらどうなるかはわからないけど。" userName="pc86" createdAt="2025-04-10T12:39:07" color="#785bff">}}

{{<matomeQuote body="それな、うちの会社でもSupabaseをいくつか使ってるよ。Supabaseをそのまま受け入れれば、かなり楽できるし、時間もお金も節約できる。ORMの話と同じで、エッジケースはSupabaseを捨てずに、個別に処理すればいいんだよね。" userName="whstl" createdAt="2025-04-10T14:17:26" color="#ff5733">}}

{{<matomeQuote body="話が逸れるけど、ORMって設計上の欠陥の塊だよね。技術的負債そのもので、PoCには使えるけど、目標スケールに達したら作り直す必要がある。リレーショナルデータとオブジェクトベースのデータの間には根本的なミスマッチがある。ORMはいくつかの問題を解決できるけど、他の問題を無視する必要がある。ORMは難しいトレードオフについて意見を持つのがせいぜいって感じ。" userName="awkward" createdAt="2025-04-09T17:47:46" color="">}}

{{<matomeQuote body="現実的には避けられないよね。アプリ全体でリレーションを維持してたとしても、サードパーティのAPIとかネットワークサービスを呼び出す必要があって、リレーションとオブジェクトのマッピングが必要になる。特にネットワークサービスはn+1問題を避けるためにオブジェクトを優先するからね。アプリでオブジェクトとリレーションをマッピングするかどうかは、多くの場合選べない。自分でやるか、ツールキットを使うかって話になる。" userName="9rx" createdAt="2025-04-09T18:00:37" color="#38d3d3">}}

{{<matomeQuote body="ORMなしのDBクエリは事実上サービスだよね。DBレイヤーでリレーションを隠蔽して、オブジェクト指向のコードでリレーションをモデル化する必要をなくす。つまり、ORMを完全に避ければ、オブジェクトとリレーションをマッピングするかどうかの問題はなくなる。その質問をしてる時点で詰んでるかもね。" userName="seadan83" createdAt="2025-04-09T18:25:24" color="">}}

{{<matomeQuote body="クエリとORMは全然違う概念だよ。Object-relation mappingは、リレーション（またはテーブル）とオブジェクトのマッピングに関すること。ORMとActiveRecordパターンを混同してるのかな？ActiveRecordはクエリビルディングとORMを組み合わせたものだよ。" userName="9rx" createdAt="2025-04-09T18:42:59" color="">}}

{{<matomeQuote body="ORMとActiveRecordで混乱してたけど、DDDを学んでエンタープライズアーキテクチャにたどり着いて、データの操作に関するデザインパターンを理解できた。多くのWebフレームワークはQuery BuilderとActiveRecordしかないよね。" userName="skydhash" createdAt="2025-04-09T21:52:22" color="">}}

{{<matomeQuote body="まず定義だけど、ORMとActive Record PatternはWikipediaを見てね。<br>Active RecordはORMの一種だと思う。Active Recordの話は置いといて、オブジェクトのマッピングとリレーショナルデータベースのマッピングには根本的なミスマッチがある。データベースをサービスとして使えないってことだよ。データベースとのやり取りはORMを通して行う必要がある。APIがSQLで動いてると、データベースが変わってもAPIを使う側は変更しなくていい。でも、ORMがオブジェクトを公開してると、属性のロードが変わると、それを使う全てに影響が出る。ORMの世界ではN+1問題とかNullPointerExceptionが起きやすい。<br>＞Wikipediaにも書いてあるけど、オブジェクトとリレーショナルデータベースは違う。<br>つまり、オブジェクトの世界でできることをデータベースで全て1:1でできるわけじゃない。だからORMはデータベースを単なるデータストアとして扱う必要がある。クエリで例を示すね。<br>Hibernateのクエリコードを見てみよう。<br>ORMだと全てのMoviesをロードして繰り返す必要があるかも。最高収益の映画監督を取得したいなら、ORMはオブジェクトじゃなくてAPIコールとして扱う必要がある。" userName="seadan83" createdAt="2025-04-10T02:42:59" color="#ff33a1">}}

{{<matomeQuote body="＞ To illustrate, let's pull some query code [3] from Java's Hibernate, a prototypical ORM.<br>ORMとentity managerは違うよ。entity managerはquery builderといくつかの機能が組み合わさったもの。あなたのコードはquery builderに焦点を当ててるね。entity managerはactive recordとは違うけど、query buildingとORMの境界はもっと明確だよ。ORMは名前の通り、Object-Relation Mappingだよ。" userName="9rx" createdAt="2025-04-10T05:54:44" color="">}}

{{<matomeQuote body="マジそれなー。ほとんどのデータベースとプログラミング言語の間にある、めっちゃ大きな溝を埋めてくれてるんだよね。ただ、根本的に妥協の産物ってのがネックなんだよなー。規模が大きくなったり複雑になったりすると問題が出てくるのは当然。違う妥協点を探すために一から作り直すのも、現実的じゃないし。" userName="awkward" createdAt="2025-04-09T18:23:49" color="">}}

{{<matomeQuote body="＞根本的に妥協の産物ってことだよね”<br>だから最近のアプリは、できるだけリレーションを使い倒して、どうしても必要なとこだけオブジェクトにマッピングする傾向にあるんだな。<br>＞違う妥協点を探すのは現実的じゃない”<br>マッピングを遅らせるメリットはそこだよなー。マッピングが必要な範囲が限定されて、特定しやすくなる。全部に対応できる巨大なフレームワークを作る必要がなくなるし。必要なものだけ作ればいいから、トレードオフも最適化しやすい。ORMライブラリを使うのは時間の無駄になるかもね。" userName="9rx" createdAt="2025-04-09T18:35:48" color="#ff5c5c">}}

{{<matomeQuote body="＞リレーショナルデータとオブジェクト指向データの間に、根本的なミスマッチがたくさんある”<br>経験上、一番の問題は、OOP言語が循環参照を表現できないことだと思うわ。シリアライズが必要になるまで、みんな気づかないんだよね。<br>https://github.com/dotnet/runtime/issues/29900" userName="bob1029" createdAt="2025-04-09T20:44:39" color="#ff5733">}}

{{<matomeQuote body="どっちもアリだと思う。状況によって最適な解は違うし。プロジェクトが始まったばかりの頃は、ざっくりとしたアイデアしかないから、パフォーマンスよりも変更のしやすさが重要になる。でも、プロジェクトが進むにつれて、一番の問題点が見えてきて、ORMレイヤーで解決できるって結論になることもあるよね。最初から分かってたとしても、初期段階の開発者は、理想のデザインについて違う考えを持ってる場合が多いし。" userName="diggan" createdAt="2025-04-09T22:20:35" color="#ff33a1">}}

{{< details summary="もっとコメントを表示（1）">}}
{{<matomeQuote body="＞最近のORMライブラリは、昔より良くなってる”<br>そうは思わないなー。昔のORMは機能豊富だけど、最近のORM、特に新しい言語のORMは、ActiveRecordとかEntity Frameworkに比べると、機能が少ない気がする。" userName="whstl" createdAt="2025-04-09T22:35:49" color="">}}

{{<matomeQuote body="SQLiteレベルのオープンソースプロジェクトって、マジで少ないと思う。ハードル高すぎ。" userName="__mharrison__" createdAt="2025-04-09T17:05:08" color="">}}

{{<matomeQuote body="ORMは信用できない。シンプルなCRUDプロジェクトなら、DALを用意して、明示的にメソッドを書いた方が絶対良い。" userName="aftbit" createdAt="2025-04-09T19:54:36" color="">}}

{{<matomeQuote body="＞DALを用意して、明示的にメソッドを書いた方が良い”<br>それってちょっと違う気がする。ORMライブラリを使う場合でも、DALは必要でしょ。DALから独自のオブジェクトを出力すれば、それってORMの発明だよ。リレーションを出力するのもアリだけど、結局オブジェクトにマッピングする必要がある。例えば、サードパーティとの連携とか。複雑なアプリケーションでは、ORMは避けられない。" userName="9rx" createdAt="2025-04-09T20:27:13" color="#ff5733">}}

{{<matomeQuote body="オブジェクトって、単なるデータコンテナ以上の意味があるよね。言語によってはクラスとかオブジェクトで表現されてるけど、属性を持つこと以外は、オブジェクトっぽい機能は必要ない。マップとかハッシュとかの方が使いやすい場合もある。クエリビルダーとネイティブなデータ型を組み合わせるのが理想。" userName="necovek" createdAt="2025-04-09T21:30:07" color="#45d325">}}

{{<matomeQuote body="＞オブジェクトは単なるデータコンテナ以上の意味がある”<br>確かに。厳密に言えば、リレーションはタプルの集合だけど、SQLデータベースを使ってる時点で、その考え方はもう古い。クラスのインスタンスも、基本的なプロパティを持っていれば、リレーションとみなせる。データの意味は変わってないからね。でも、オブジェクトへのマッピングは必要になる。複雑なアプリなら、サードパーティとの連携で絶対に必要になる。" userName="9rx" createdAt="2025-04-09T21:39:00" color="#ff5733">}}

{{<matomeQuote body="安全第一の組み込みソフトで1～2年働くの、マジでエンジニアのためになると思うんだよねー。ミスったら命に関わるレベルのやつ。全員が気に入るかは知らんけど、経験にはなるっしょ。そーゆー経験したら、もうちょい普通のソフト開発でもYOLO精神なくなるんじゃね？" userName="ryandrake" createdAt="2025-04-09T14:44:11" color="#785bff">}}

{{<matomeQuote body="若手の頃に止まっちゃいけないシステムに関わったのが、良い習慣につながったなー。品質がそこまで求められない場面でも役に立ってるし。基本的なことだけど、リターンコード毎回チェックしたり、全ての分岐をテストしたり、外部環境がちゃんと動くか確認したり。今じゃもう体に染み付いてるから、適当なpythonスクリプト書くときでもやっちゃうんだよね。デバッグ時間も考えると、YOLOしてる人より効率良いと思うし。データ基盤でも同じようなことあるよね。" userName="jandrewrogers" createdAt="2025-04-09T16:22:51" color="#45d325">}}

{{<matomeQuote body="マジで同意！有名なアルゴリズムの実装とかは信用できるけどね。でもね、意外と自作した方が安く済むこと多いんだよね。何年か経ってからシステム見直すと、パッケージ使ったコードの方がバグとかセキュリティの穴が多いんだわ。修正コスト考えると、マジで自作の方が安いこともある。専門的なことでも、ベンダーに頼むより自作の方が安いとかあるしねー。機会費用もあるけど。" userName="jppope" createdAt="2025-04-09T12:09:16" color="#ff33a1">}}

{{<matomeQuote body="最近のライブラリ、マジで質低すぎてもうビビるわ。ライブラリ業界も競争激化してて、ビジネスになっちゃってるからね。正しさとか品質よりも、とにかく早く出して、チュートリアルとか本とかGitHubのスポンサーシップとかで稼ぐのが目的になっちゃってる。セキュリティもそうだけど、開発体験もクソ。ドキュメント少なすぎ、基本的なケースすらカバーしてないとかザラ。新しい開発者は新しいライブラリしか知らないから、基礎がなってないんだよね。React使いなのにHTMLフォームをライブラリなしで使えないとかありえん。" userName="whstl" createdAt="2025-04-09T13:09:56" color="#45d325">}}

{{<matomeQuote body="＞最近のライブラリの質の低さにショックを受けてるって？<br>そりゃそうでしょーよ。医療とかDoD以外のソフト業界は、品質なんて気にせずにとにかく早く機能提供することしか考えてないんだから。" userName="GiorgioG" createdAt="2025-04-09T13:23:56" color="">}}

{{<matomeQuote body="それ言い過ぎじゃね？結局、みんな積み重ねでしょ。Math.Abs()とかソケットライブラリとか、信用して使ってるわけだし。フレームワークはできるだけ避けるけどね。スクリプト言語で自分で書いた方がマシなやつとか。RESTの呼び出しとか非同期関数とかの裏にある、何層ものソフトとかハードは？PixijsとかChart.jsとかJqueryとかMoment.jsとかBootstrap 4とか、良いライブラリもあるし。自分で作ったことあるやつもあるけど、使い慣れたツールキットがある方が時間節約になるよ。問題は、もう死んでるか、開発が活発なライブラリにハマることかな。" userName="noduerme" createdAt="2025-04-09T12:24:27" color="">}}

{{<matomeQuote body="Momentはブラウザのタイムゾーン以外をコントロールできるからまだ使うけどねー。Momentの代わりになるおすすめある？JavaScript Temporalに期待してる。" userName="aabaker99" createdAt="2025-04-09T13:54:47" color="">}}

{{<matomeQuote body="＞非標準技術は使わないってのは共感できる。<br>最後の行まではね。Not Invented Here症候群で、根本原因の解析を邪魔するようなスタックになったコードベース見たことないわ。昔、C++の会社で、自作のスレッドセーフな文字列クラスがあって、ひどいことになったけどね。成熟した技術はたくさんあるし、自分の発明が、何千もの目が入ったフレームワーク/ライブラリ/データベースと同じくらいバグがないなんてありえないでしょ、どんなにスキルがあっても。" userName="skrebbel" createdAt="2025-04-09T14:46:08" color="#45d325">}}

{{<matomeQuote body="リファレンス読めってことね！でもいきなりガッツリ読むより、まず1時間くらい試行錯誤するのが好きなんだよね。Stackoverflowとか見て、ちょこっと触ってからリファレンスに戻るみたいな。なんでかって言うと、実際に触ってみないとリファレンスのコンテキストが理解できないことが多いから。特に新しい言語とかAPI学ぶ時はそう。チュートリアルとか quickstart やって、自分でちょっと変えてみて、それからリファレンス読むと理解度が全然違うんだよね。Intellisenseみたいな機能があるとマジ助かる。お試し段階でドキュメントがチラッと見えるのはホント便利。" userName="gwbas1c" createdAt="2025-04-09T12:36:22" color="#ff5c5c">}}

{{<matomeQuote body="＞リファレンス読めってことね！<br>＞推測すんなって！<br>＞新しいもの使うとき、まず1時間くらい推測するのが好きなんだよね。Stackoverflowとか見て、ちょこっと触ってからリファレンスに戻るみたいな。<br>”それは確かにそうだね。ダメなプログラマーはStackoverflowだけ見て永遠に推測してるイメージ。何が起きてるのか全然わかってないのに、とりあえず色々試して、たまたま上手くいくまでゴチャゴチャにする。この記事はそういう人たちへのアンチテーゼだと思うよ。" userName="palmotea" createdAt="2025-04-09T12:46:36" color="">}}

{{<matomeQuote body="良いインターフェースを設計できる人と、良いドキュメントを作れる人って、すごい相関関係があるんだよね。つまり、推測がうまくいかない時、リファレンスも不正確だったり、必要な情報が伝わらなかったりしてダメなことが多いってこと。ユーザーがどう製品を認識するかを考えるスキルが必要だから当然だよね。実際に、リファレンスを理解できないと思ってたら、バグだったり、変更でリファレンスが無効になってたりすることってよくあるんだよな。最近は、ユーザーのこと考えてない人が作った製品は、推測がダメならソースコード見に行くか、コードがなかったらシステムを直接調べるようにしてる。そっちの方が早いし、自然言語で説明するよりも、何が起きてるか良く理解できる。" userName="9rx" createdAt="2025-04-09T13:41:07" color="#45d325">}}

{{<matomeQuote body="Windows開発について色々言いたいことはあるけど、90年代のMSDNリファレンスはマジで良かった。Win32とかMFCとかね。PetzoldとかProsiseの本もあれば、オンラインに行かなくても大体のAPIの疑問は解決できた。なのに、それでも適当に探り当てようとしたり、先輩に聞くエンジニアもいたんだよね（先輩はいつも「ドキュメント読んだ？」って聞いてたけど）。言い訳できないレベルでドキュメントが優秀だったんだよな。Win32の闇の部分もあったけど、99%のdeveloperはそんなとこ触る必要なかったし。" userName="ryandrake" createdAt="2025-04-09T14:53:24" color="#38d3d3">}}

{{<matomeQuote body="良かったけど、完璧ではなかったよ。「MSDNにはXって書いてあるけど、実際の挙動はYだから、コードにはZがある」みたいなコメント残した記憶あるもん。毎日そんなことがあったわけじゃないけどね。" userName="d0mine" createdAt="2025-04-09T19:13:29" color="">}}

{{<matomeQuote body="＞良いインターフェースを設計できる人と、良いドキュメントを作れる人って、すごい相関関係があるんだよね。つまり、推測がうまくいかない時、リファレンスも不正確だったり、必要な情報が伝わらなかったりしてダメなことが多いってこと。ユーザーがどう製品を認識するかを考えるスキルが必要だから当然だよね。<br>話してる推測の種類が違うと思う。俺が言ってるのは、何も知らないのにネットで拾った”何か”を理解せずに試すみたいな、アホな推測のこと。そういう人は、どんなに優れたインターフェースと最高のドキュメントがあっても同じことするんだよね。それに、最高のインターフェースでも、全部が見つけられるわけじゃないし。" userName="palmotea" createdAt="2025-04-09T13:53:10" color="#38d3d3">}}


{{< /details >}}
{{< details summary="もっとコメントを表示（2）">}}
{{<matomeQuote body="＞ネットで拾った”何か”を理解せずに試すみたいな。<br>最初はそれもありだよね。でも、それで上手くいかなかったらそこで止まっちゃダメ。次はインターフェースをよく見て、ヒントがないか探すべき。良い設計なら大抵ヒントがあるはず。<br>＞最高のインターフェースでも、全部が見つけられるわけじゃないし<br>テストスイートがあるじゃん。ユーザーへの完全な意図と使用方法をドキュメントするためだよ。そのためにリファレンス見ないでしょ。それに、自己検証できるから、「俺のせい？リファレンスが間違ってる？」みたいなことにならない。" userName="9rx" createdAt="2025-04-09T14:04:11" color="">}}

{{<matomeQuote body="＞＞ネットで拾った”何か”を理解せずに試すみたいな。<br>＞最初はそれもありだよね。でも、それで上手くいかなかったらそこで止まっちゃダメ。<br>ありえないでしょ。コピーペーストコーディングのこと言ってるんでしょ？Google検索して、Stackoverflowで一番最初の回答をコピペ。その後で、そのdevに何をしたのか、なぜ動くのか聞いても、本人もわかってないから答えられないんだよ。<br>＞インターフェースをよく見て、ヒントがないか探すべき。<br>そういう人は絶対にそれやらない。<br>＞テストスイートがあるじゃん。<br>「コードはself-documentingだからコメントなんていらない」みたいな雰囲気を感じる。賛成できないな。コードやテストよりも、文章の方がコードに関する多くのことを表現できると思う。<br>確かにコードは実装されたことを知るには一番信頼できるけど、理由とかコンセプトを知るには向いてない。" userName="palmotea" createdAt="2025-04-09T15:12:33" color="#ff33a1">}}

{{<matomeQuote body="＞ありえないでしょ。<br>なんで？動けば良くない？みんながみんな最高のプログラマー目指してるわけじゃないし。<br>＞本人もわかってないから答えられないんだよ。<br>特定の人のことを考えてるのはわかるけど、大体どう実装するか知ってるから、大体どう動くかくらいわかるでしょ。誰かのコードが既にやってくれてるなら、それ以上考える必要ないし。最初はそこから入っても全然アリ。<br>＞理由とかコンセプトを知るには向いてない<br>テストで”why”を捉えてないなら、一体何をテストしてるの？”what”は実装で既に捉えられてるじゃん。それを二回書く必要ない。それよりも、変更するたびにテストが壊れる状況の方が最悪。テスト書くのはマジで難しいけど、リファレンス書くのと同じくらい難しい。でも、スキルのない人が作ったものを使うしかないなら、どうしようもない。" userName="9rx" createdAt="2025-04-09T15:25:56" color="">}}

{{<matomeQuote body="＞＞ありえないでしょ。<br>＞なんで？動けば良くない？みんながみんな最高のプログラマー目指してるわけじゃないし。<br>なるほどね。ドキュメント読まずに推測したり、Google検索してStackoverflowの最初の回答をコピペするようなプログラマーは、まあまあなプログラマーってことね。良いプログラマーになりたくないなら、今のままで良いんじゃない？<br>＞テストで”why”を捉えてないなら、一体何をテストしてるの？<br>コードで”why”を捉えることはできないよ。テストは”what”のデモンストレーションでしょ。" userName="palmotea" createdAt="2025-04-09T20:19:42" color="#785bff">}}

{{<matomeQuote body="＞最高のプログラマーって実はそこそこのプログラマーだったりするよね。<br>まあ、それは人によるんじゃない？「最高の」プログラマーを決めるために、自分がやってることをリストにして当てはめようとする人は、当てはまらない人を排除しがちだよね。<br>ビジネスの人は、誰かのコードをうまく使って早く製品を届ける人を「最高」って思うかもね。<br>＞コードで理由を説明できないなら、言葉でも無理じゃん。意味なくね？<br>いや、そんなことないと思うよ。<br>＞テストは「何」のデモだよ。<br>確かに、APIドキュメントに入れる「例」テストみたいなのはあるけど、それは一部でしょ。ほとんどのテストは違うよ。もしそうなら、やり方が間違ってるか、後でテストを使う人に不親切だよ。<br>俺のリストでは、次の人のことを考えるのが「最高」のプログラマーとそこそこのプログラマーの違いかな。" userName="9rx" createdAt="2025-04-09T20:47:33" color="">}}

{{<matomeQuote body="わかる。まず仮説を立てて、コードで確認して、また繰り返す。これって当たり前だと思ってたけど、意外とそうでもないんだね。エンジニアリングって科学的な方法論に従うはずなのに。仮説を立てて検証しないと、科学的じゃないじゃん。まあ、仮説と推測の違いを細かく言うなら別だけど、推測ってプログラミングのめっちゃ大事な要素だよ。<br>Peter Naurの「Programming as Theory Building」ってエッセイがめっちゃ参考になるんだよね。40年前のだけど、プログラミングの本質を捉えてる。プログラミングで作られる価値って、ソースコードじゃなくて、システムについての共通の理論なんだよね。仮説なしに十分な理論を構築できるとは思えない。" userName="perrygeo" createdAt="2025-04-09T15:18:53" color="#ff5733">}}

{{<matomeQuote body="コードを書く前に仮定を立ててチェックすることで、後から都合の良いように解釈することを防げるんだよね。間違った予測は理解を深めるのに役立つし、学びに繋がる。" userName="d0mine" createdAt="2025-04-09T19:20:14" color="#ff33a1">}}

{{<matomeQuote body="だから、何でもchatGPTに聞くより、Googleで検索するんだよね。Stack Overflowとかのコメントやスレッドで、面白い情報が見つかることが多いんだ。" userName="ctxc" createdAt="2025-04-09T13:27:09" color="">}}

{{<matomeQuote body="最近は、まず自分でやってみて、それをLLMに批評してもらうのが好きだな。その方が、学ぶのに良いと思うんだよね。外国語学習と一緒で、間違えて修正される方が、毎回正解を見るより身につくと思うし。それに、LLMがでたらめなことを言わないか心配する必要もないし。自分で調べるきっかけにもなるし。" userName="socksy" createdAt="2025-04-09T13:48:25" color="#38d3d3">}}

{{<matomeQuote body="知らない言語やライブラリを使うときは、ブラウザのタブをたくさん開いてるな。ドキュメントには注意点とかコツが書いてあることが多いけど、LLMには載ってないことが多いからね。それに、本を読むと基礎がしっかりするし。" userName="skydhash" createdAt="2025-04-10T12:52:00" color="#38d3d3">}}

{{<matomeQuote body="なるほどね。最近swiftを勉強し始めたんだけど、最初はLLMを頼ったよ。「JavaとPythonは知ってるんだけど、swiftの構文を教えて」みたいな感じで。それはすごく良かった。アーキテクチャについては、方向性だけ決めて、あとはGoogleで調べた（例えば、swiftData、coreData、sqliteのどれを使うべきかとか、会話スレッドで色々調べた）。" userName="ctxc" createdAt="2025-04-09T13:57:52" color="">}}

{{<matomeQuote body="新しいことを学ぶには、真ん中から始めるのがいいよね。概要を見て、他の人がどう考えているかを見て、それからマニュアルに飛び込む。" userName="mycall" createdAt="2025-04-09T17:15:52" color="">}}

{{<matomeQuote body="「推測するな」って言葉を、非現実的な意味で解釈する人が多いと思うんだよね。最高のプログラマーはそうじゃない。<br>ツールやライブラリがどんなモデルを提供しているか、ちゃんと把握しておくべきだよね。そして、そのモデルを使ってツールの挙動を「推測」するべき。推測が当たりやすいツールを選んで、特殊なケースが多くて推測しにくいライブラリは避けるべきだよね。<br>最高のプログラマーは、関数を呼び出すたびにドキュメントや実装を確認したりしない。一度にたくさんの仮定をチェックできるテストを書くのが得意だし、信頼できるツールを選ぶのが上手い。そして、間違った推測をさせるようなツールは避ける。<br>プログラミングのレバレッジは、理解しなくてもいいこと、読まなくてもいいコードから生まれるんだ。" userName="alphazard" createdAt="2025-04-09T19:39:00" color="#ff33a1">}}

{{<matomeQuote body="リファレンスに集中するのがマジで無理なんだよね。子供っぽいけど、どうしてもできない時がある。コードをいじくり回して今の自分があるんだよ。" userName="asdfman123" createdAt="2025-04-09T22:24:43" color="">}}

{{<matomeQuote body="正直言って、参照がマジで分かりにくい時あるよね。全部説明してる’つもり’でも、理解するための背景が足りてないんだよ。だから例が超大事。" userName="gwbas1c" createdAt="2025-04-10T02:43:11" color="">}}

{{<matomeQuote body="マジそれな。良いドキュメント書くのってマジ難しい。特に作者がデザイナーも兼ねてる時。コンテキストがありすぎて、当たり前だと思っちゃって省いちゃうんだよね。" userName="metalliqaz" createdAt="2025-04-09T12:42:46" color="#785bff">}}

{{<matomeQuote body="あなたのやり方は悪くないと思うし、少なくとも精神的には記事のアドバイスと矛盾してないと思うよ。テストされてない推測が製品に入ったり、根拠のないアドバイスを同僚にしたりする状況を言ってるんじゃないよね？仮説を立ててテストするのは価値があるけど、根拠のない前提に基づいて構築するのは全然違う。" userName="wging" createdAt="2025-04-09T20:16:57" color="#38d3d3">}}

{{<matomeQuote body="面白いね。俺も哲学勉強してた時に似たようなことしてたわ。読むより考える方が好きだから、まず哲学的な問題を自分で考えて、それから他の人の意見を読むんだ。そうすると理解が深まる気がしたんだよね。プログラミングでも同じことしてるかは分からん。" userName="Winsaucerer" createdAt="2025-04-09T15:35:55" color="">}}

{{<matomeQuote body="これ同意。新しいツール使う前に色々学ばないと、ドキュメントを効果的に使えないんだよね（Getting Started以上は）。すでに詳しい分野ならすぐ飛び込めることもあるけど、大抵は試行錯誤が大事。" userName="iamwpj" createdAt="2025-04-09T15:41:10" color="">}}

{{<matomeQuote body="実は、”まず自分でテストしてから学ぶ”アプローチは、研究によると、ただ学ぶよりも学習効果が高いらしいよ。" userName="d0mine" createdAt="2025-04-09T19:09:05" color="#ff33a1">}}


{{< /details >}}
{{< details summary="もっとコメントを表示（3）">}}
{{<matomeQuote body="＞“Stack Overflowに行くな、LLMに聞くな、推測するな、ソースに直接行け。意外とアクセスしやすくて、よく書かれてる。”<br>なんか数学の本みたい。工学部の時、形式的な数学を読むのがマジ嫌だった—いつも分かりやすいテキスト読んでた。修士でちょっとマシになって、要点を手短にまとめた章を読めるようになった。少なくとも今は、なんでみんな簡潔な参考文献を書くのか理解できる。rust cratesはいつもdocs.rsに行くし最高。Haskellのhoogleも好きだった。Cpp referenceも結構良い。<br>今日boto3 python libraryのドキュメント読んで、docs.rsが恋しくなったわ！" userName="dilawar" createdAt="2025-04-09T09:20:45" color="#ff33a1">}}

{{<matomeQuote body="＞“Stack Overflowに行くな、LLMに聞くな、推測するな、ソースに直接行け。意外とアクセスしやすくて、よく書かれてる。”<br>＞なんか数学の本みたい。工学部の時、形式的な数学を読むのがマジ嫌だった—いつも分かりやすいテキスト読んでた。修士でちょっとマシになって、要点を手短にまとめた章を読めるようになった。<br>それってアドバイスの意味と違うと思うな。体系的な知識と断片的な知識の話だと思う。LLMやStack Overflowで’学ぶ’人は、ツールの全体像を把握してないから、ステレオタイプな使い方しかできないし、無駄に難しいやり方でやる羽目になるんだよね。体系的な知識は分かりやすいテキストでも得られる。" userName="palmotea" createdAt="2025-04-09T12:40:53" color="#45d325">}}

{{<matomeQuote body="Haskellはもう何年も使ってないけど、何使っててもHoogleが恋しくなるんだよね。’X型の値が欲しいけど、どの関数がX型を返すんだ？’って検索できるのがマジ便利。Scalaも同じように型シグネチャで検索できるドキュメントがあった気がする。<br>最近Zig触ってるんだけど、ドキュメントシステムがマジ良い。見てるものの実装ソースが埋め込まれてて、使い方の例も載ってるのが良い。Hoogleみたいに型シグネチャで検索できたら最高。" userName="Zambyte" createdAt="2025-04-09T10:11:22" color="#785bff">}}

{{<matomeQuote body="これはワークフローを円滑にするツールを使うことにも繋がると思う。ライブラリコードの定義にジャンプできると、自分のコードから関数にすぐに移動できる。コードエディタのサポートがあれば、シームレスにできる。そうじゃないと、エディタから離れてGoogleで検索して、GitHubで探して、プロジェクト検索して、大量の結果から探さないといけない。<br>" userName="nickjj" createdAt="2025-04-09T10:17:54" color="#ff33a1">}}

{{<matomeQuote body="意外とアクセスしやすくて、読みやすいんだよね。この人が質の高いソフトウェアに関われてて良かったじゃん。俺はいつもラッキーとは限らなかったけどね。" userName="ClikeX" createdAt="2025-04-09T12:27:26" color="">}}

{{<matomeQuote body="リテラシープログラミングの強力な主張じゃん。http://literateprogramming.com/　俺が一緒に働いた最高のプログラマー2人は、クヌースのTAoCPを読み込んでたよ。" userName="WillAdams" createdAt="2025-04-09T11:00:42" color="#38d3d3">}}

{{<matomeQuote body="ほとんどのプロジェクトはdiataxisに従うべきだし、そうすれば苦労することも少なくなると思うぜ。" userName="jilles" createdAt="2025-04-09T22:39:22" color="">}}

{{<matomeQuote body="最高の開発者は、プリンシパルエンジニアともジュニア開発者とも話すんだよね。ヒエラルキーなんてないんだ。若い人も年配の人も、みんなから学ぼうとする。新参者はまだオフィス政治に染まってないから、新鮮な考えを持ってるんだよね。物事が難しい理由を知らないから、創造的な解決策を提案してくれる。過去の障害はもうないかもしれないし、彼らは素晴らしいインスピレーションの源になるんだ。<br>＞それが逸脱の正常化に対抗する方法だよ。新しい人が間違っていることを指摘しても、理由もなく無視しちゃダメ。そう、あなたはXをいつもと違う方法でやってきたし、何も問題は起こらなかった。でも、そうすべきでない理由があるかもしれないし、経験することによってそれを学び直すには多くのコストがかかるかもしれない。<br>誰にも存在理由がわからないけど、まだ守られている古いルールも同じこと。どんなルールにも存在理由の説明が必要だし、その関連性は定期的にチェックされるべき。" userName="arkh" createdAt="2025-04-09T07:51:56" color="#ff33a1">}}

{{<matomeQuote body="個人的には、新しい人の方が良い質問をすると思うな。経験豊富な人は、いつ慣習に従わないかを知ってる。<br>変化は本当に速いし、AIツールを使えばなおさらだ。だから、なぜ特定のやり方をするのかを問い続ける人がいることが重要なんだ。" userName="muzani" createdAt="2025-04-09T10:49:22" color="#38d3d3">}}

{{<matomeQuote body="この記事に欠点が見つからないな。ほとんど全部に同意できるけど、一点だけ例外がある。<br>＞「Stack Overflowに行くな、LLMに聞くな、推測するな、まっすぐソースに行け。多くの場合、それは驚くほどアクセスしやすく、よく書かれている。」<br>俺がプロとして積極的にコーディングするようになってから、もう15年以上になると思う。常に学んでるよ。キャリアを始めた頃は、Stack Overflowで質問するよりも、質問に答えることにかなりの時間を費やした。誰かの問題を解決するのは“Real-World challenge”みたいで、すごく役に立ったんだ。だから、Stack Overflowの使い方次第だと思うよ。<br>LLMについては、最近の若者がやってるような“vibe coding”には使わないな。これは間違った使い方だと思う。LLMは、リアルタイムイベントを分析して要約を作成したり、退屈なことを自動化したりするために、構築中のソフトウェアに統合するには最適だ。でも、プログラマーの代わりには絶対にならない。少なくとも今のところはね。LLMの使い方は、理解したい/探求したいトピックについて、鳥瞰図/10,000フィートの視点を提供するように依頼することだ。なぜかって？用語がわからないから、何がどう機能するのかわからないこともあるからね。そこでLLMが役立つんだ。用語がわかったら、LLMに頼るよりも、公式ドキュメント/論文を参照できる。これは過小評価されているLLMのスーパーパワーだと思うよ。" userName="kshri24" createdAt="2025-04-09T09:02:54" color="#ff5733">}}

{{<matomeQuote body="俺もほとんど同意できるけど、それ以外はね。このアドバイスは、人それぞれの学習方法から来てると思うんだ。もし作者とは違う学び方をするなら、このアドバイスは間違ってて、不快に感じるだろうな。<br>俺は読んで学ぶより、やって学ぶタイプ。何かを読んでも、実際に使わなかったら忘れちゃう。俺の脳はそれを“実用的じゃない、必要ない”と分類するみたい。でも、実際に使えばすぐに覚えるんだ。<br>だからドキュメントはひどいと思うし、何かがどう機能するかを読んでも役に立たない。例を見る必要があるんだ。何かが動作しているのを見れば、実際にそれを学ぶことができる。コピー/ペーストでも、コピーしたコードをいじったり、変数を変えたり、パラメーターをいじったり、コメントを追加/削除したりするから効果がある。コードは決してただコピーされるだけでなく、常に操作され、クリーンアップされ、不要なものが削除されるんだ。<br>例がないドキュメントや、使い方の関係のない貧弱な例がたくさんある。<br>APIに「意味」がないと、覚えにくいんだよね。たとえばSQL Serverの“OVER”句は、長年使ってきたけど、使うたびにまた覚え直さないといけない。そういうAPIは本当にイライラする。" userName="mattmanser" createdAt="2025-04-09T09:37:34" color="#45d325">}}

{{<matomeQuote body="人の学び方や創造の仕方はそれぞれ違うよね。他のクリエイティブな分野にもそういう二面性があるけど、俺たちは数学に近いから、常に物事の「正しいやり方」を見つけようとする。でも、俺たちの分野は実際には非常に柔軟で、多くの自己表現を許容しているんだ。" userName="asl2D" createdAt="2025-04-09T11:15:07" color="">}}

{{<matomeQuote body="マジでLLM最高だわ。200ページとか100ページ超えの13FのファイリングレポートをGeminiにぶち込んで10分後にはアノマリー見つけてくれるんだぜ。これマジありえないっしょ、今まで。だってこんなレポート、全然標準化されてないんだもん。" userName="ZeroTalent" createdAt="2025-04-09T09:17:04" color="#785bff">}}

{{<matomeQuote body="ログでも同じことやってる。ちゃんとfield by fieldでdiffとるのがめんどくさい時に。" userName="GardenLetter27" createdAt="2025-04-09T09:39:43" color="#ff5c5c">}}

{{<matomeQuote body="いや、全然一貫性ないドキュメントだよ。13Fファイリングの内容に関する要件はあるけど、フォーマットについてはあんまないんだよね。しかもPDFだから、従来のスクリプトで解析するのがマジ難しい。" userName="ZeroTalent" createdAt="2025-04-09T21:57:02" color="#38d3d3">}}

{{<matomeQuote body="めっちゃわかる。俺も同じような使い方してるわ。回りくどい言い方しかできなくて、言いたいことがうまく言えない時に検索で使う（昔読んだ本の超曖昧な記憶しかない時に、検索エンジンじゃ無理だったのに見つけられた）とか、”フレームワーク”に関する質問とか。例えば、これ何？とか、各要素の関係は？みたいな。ある意味これも検索問題だと思ってる。ゼロから始める検索みたいな。鵜呑みにはできないけど、情報の”ランドマーク”を把握して、そこから理解を深めていくには十分。" userName="lacn" createdAt="2025-04-09T09:14:08" color="#ff33a1">}}

{{<matomeQuote body="＞キャリア始めた頃は、質問するよりStack Overflowで質問に答えるのに時間を使ってたな。<br>今はSOの質問に趣味で答えるとか無理だと思う。昔は朝のコーヒー飲みながらやってたけど、いつの間にかプロの評判稼ぎみたいなのが湧いてきて、投稿される30秒前に全部答えちゃうんだもん。それに、やっと回答されてない質問見つけても、”魚の釣り方を教える”みたいな回答するとモデレーターに怒られるし。コピペできるコードじゃないとダメみたいな。" userName="nottorp" createdAt="2025-04-09T14:40:51" color="">}}

{{<matomeQuote body="まさに今のLLMの使い方それだわ。どんな分野でもキックスタートできるし、このレベルの使い方ならエラーもほとんどない気がする。" userName="onthewall" createdAt="2025-04-09T16:31:11" color="#ff5733">}}

{{<matomeQuote body="最近絵を描き始めたんだけど（ちょっとした中年クライシス）、全然わからなくて、何ができるのかすら理解できてない。ネットにはゴミみたいなチュートリアルばっかだし。LLMが俺の意図を解釈して、キーワードとか名前を教えてくれるのはマジ助かる。もちろん、詳しい人に聞くのが一番いいんだろうけど、いつも都合がいいわけじゃないし。LLMの一番いいところは、ソフトなインプットができるってこと。ソフトなアウトプットは問題ない。" userName="asl2D" createdAt="2025-04-09T11:11:26" color="#45d325">}}

{{<matomeQuote body="絵を描くなら、本とか講座を買うのが普通は良いと思うよ（New Masters Academyみたいな良いプラットフォームで）。あとは練習あるのみ。" userName="skydhash" createdAt="2025-04-10T13:04:25" color="">}}


{{< /details >}}


[記事一覧へ]({{% ref "/posts/" %}})
