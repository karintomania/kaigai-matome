+++
date = '2025-05-25T00:00:00'
months = '2025/05'
draft = false
title = 'あなたのコードを形作る見えない手！設計圧力'
tags = ["設計", "プログラミング", "ソフトウェアアーキテクチャ", "ドメイン駆動設計", "データモデリング"]
featureimage = 'thumbnails/purple5.jpg'
+++

> あなたのコードを形作る見えない手！設計圧力

引用元：[https://news.ycombinator.com/item?id=44087844](https://news.ycombinator.com/item?id=44087844)




{{<matomeQuote body="めっちゃいい講演だったね！共感できることマジでいっぱいあったよ。このトピックって、トレードオフが多いから難しいんだよね。今回触れられてなかった点として、時間軸があると思うんだ。最初はPostgresのデータの形そのまんまを型にしたような”データベース指向設計”（悪い意味でね）で始めるのが理にかなってること、結構あるじゃん？<br>でも時間が経ってドメインの理解が深まると、そのアプローチの限界に気づき始めるんだ。そしたら、別のドメインモデルを導入して、明示的なマッピングを使うのが多分正解。だけど、いつ切り替えるべきかっていうタイミングの見極めが超難しいんだよね。<br>最初からドメインモデルで始めるべき？多分ね、でもリスクもあるんだ。だって、SQLテーブルにあるやつより、ちゃんとドメインを表せてるとは言えないようなドメインオブジェクトになっちゃう可能性もあるじゃん。あと、少なくとも最初は、ドメインモデル、SQLのSELECT結果、JSONレスポンスの形がほとんど同じなのに、それらの間でいちいちマッピングするのって変な感じするし（チーム内で正当化するのも大変）。<br>だから、最初からドメインモデルにするより、ドメインがもっとわかってからリファクタリングで徐々に導入していくのが最良のアプローチかもしれないね。抽象化は少なめかゼロで始める方に倒しておきつつ、具体的なものだらけで辛くなってきたら躊躇なく抽象化を導入する。これもまた判断が必要だから、教えるのが難しいんだ（講演はそこを見事に指摘してたと思うけどね）。" userName="loevborg" createdAt="2025/05/25 17:31:03" color="#785bff">}}




{{<matomeQuote body="マジで素朴な疑問なんだけど、「ドメインモデル」って、こういったもっとプリミティブなデータ表現と何が違うの？よく聞く言葉だけど、みんなが具体的に何を意味してるのか、いまいち掴めないんだ。<br>ドメインモデルって、科学者が「理論」って呼ぶようなものなのかな？ドメインをいくつかの根本的な概念、それらの関係性、振る舞いなんかで記述したもの？仕様書みたいな？<br>それはもちろん、たくさんの具体的な実装（そしてデータを表現するたくさんの方法）がありうるよね。ここで俺が混乱するのは、データとドメインモデルの間でマッピングするってのが何を意味するのか分からないってことなんだ（ドメインモデルって実際のコードのエンティティなの？）。だから、多分俺、これについて考え方間違ってるんだろうな。" userName="bubblyworld" createdAt="2025/05/25 17:46:29" color="">}}




{{<matomeQuote body="ちょっと簡単な例だと、日付があるね。ISO 8601形式の文字列で保存できるし、システム間で共有される仕様だから、そうするのが理にかなってることも多い。でも、実際に表示する段階になると、ローカライゼーションやタイムゾーンみたいなたくさんの追加の考慮事項が出てくるんだ。そうなると、構成要素を分割したデータ構造が必要になるし、一部の構成要素は、最終的な表現を文字列として出力するロジックのキーやパラメータとして使われるかもしれない。<br>だから、ストレージ層もプレゼンテーション層も文字列だけど、それらは違うものなんだ。この両方を調和させるには、中間層が必要になる。そこにはドメインモデルとなる構造体や、それを操作するロジックが含まれるんだ。ある層から別の層へジャンプするには、データをマッピングする。この例だと、文字列から構造体、そしてまた文字列へ。<br>MVCやCRUDアプリだと、層ごとにモデルが似てる（特に動的言語だと同じ）ことが多いから、マッピングなんて気にしないよね。でも、ユースケースが複雑になるにつれて、ドメイン層とそこにあるモデルが変わってくるんだ。そうすると、マッピングのコードを追加する必要が出てくる。ストレージ層にはたくさんのテーブルがあるかもしれないけど（SQLを使ってる場合）、ドメイン層ではそれが単一の構造体になったり、その後、プレゼンテーション層で重複した情報を含むたくさんのモデルになったりするんだ。<br>NOTE<br>だから、多くの人がほとんどのORMライブラリが好きじゃないんだ。モデルが似てるときは素晴らしいんだけど、モデルが乖離し始めると、結局生のSQLクエリに頼る必要が出てきて、そうなるとリファクタリングが面倒になる。良いORMライブラリはメタプログラミングに依存してるけど、結局それはただの奇妙なSQLでしかない。" userName="skydhash" createdAt="2025/05/25 18:32:07" color="#ff5c5c">}}




{{<matomeQuote body="ORMライブラリには、そんな簡単な例のためのValue conversion機能があるよ。" userName="groone" createdAt="2025/05/25 20:16:24" color="">}}




{{<matomeQuote body="いや、そうじゃないんだよね。結局は書かなきゃいけないコードの話なんだ。ORMから取得するデータ構造をいじる代わりに、ドメインロジックをよりクリーンで明確にする何かを持つのさ。データをマッピングするためのコードはシンプルだから、保守可能なユースケースロジックを持つことと引き換えに、書くための時間という対価を支払うだけなんだ。" userName="skydhash" createdAt="2025/05/26 01:27:02" color="">}}




{{<matomeQuote body="一般的に、ある問題にとって理想的な形式は、別の問題にとってのそれとは同じじゃないんだよね。例えば、RDBMSにグラフを保存する場合、理想的な形式は多分隣接リストで、それを再帰クエリで辿るのがいいだろう。でも、アプリのコードでは、お互いを指し示すオブジェクトグラフとして持ってるのが多分一番楽だ。そして、フロントエンドのコンテキストでは、グラフなんて話したくもない。ユーザーは一つのノードの親子関係についてしか実際話せないからね。<br>あらゆるシナリオに理想的なデータモデルなんて一つもないんだ――だったら、シナリオごとに違うモデルを持てばいいじゃないか？そうすれば、あるモデルから次のモデルへ変換する方法だけを考えればいいし、その理想化されたデータモデルに依存するどんなロジックも、かなりシンプルに実装できるようになる（だって、それが良いデータモデルの本質だからね - それ以外のロジックはたいてい自然と決まってくる）。<br>だから、君が使っているデータモデルは、対象となるドメイン／主題に局所化されてるんだ。必要なときにデータをモデル間で移行させてるだけ。ドメインってのはただの任意のコンテキストさ――永続化層とか、UIロジックとか、あるいはもっと具体的で、会計士向けのUIページでデータがどう整理されるかを反映するように会計士向けのモデルを持ちたい、みたいな。だって、彼らが俺に頼んでることの30％しか理解してないから、”彼らの用語”で進めた方が、何も考えずに実装するのがずっと楽になるんだ。あるいは、この特定の関数の主な目的はレポート用の様々な集計だから、最初にデータセットを集計グループとほぼ一致する階層に整理する。適切に揃ったら、集計ロジック自体は完全に自明になるんだ。<br>単一テーブルの`select *`を超えるクエリをデータベースに投げるたびに、新しいドメイン固有のデータモデルを作ってるんだ、とさえ言えるかもしれないね。元のテーブル表現から新しいものへ変換してるだけなんだ。<br>すべてのドメインモデリングは、これから書くロジックに最も合う表現を具体的に選択すること、そして、持っているモデルを欲しいモデルに変える方法を見つけ出すことなんだ。それ以外の主題については、ただの実装の詳細でしかないよ。" userName="setr" createdAt="2025/05/26 06:21:16" color="#38d3d3">}}




{{<matomeQuote body="＞ 例えば、RDBMSにグラフを保存する場合、理想的な形式は多分隣接リストで、それを再帰クエリで辿るのがいいだろう<br>これは些細な点だって分かってるけど、全体のトピックに関連してると思うから、ちょっと突っ込んでみるね。<br>隣接リストは、RDBMSでグラフ／ツリーを保存する方法としては、多分最悪だよ。理解するのは一番簡単かもしれないけど、特にRDBMSにRecursive CTEがない場合、パフォーマンス特性が最悪クラスなんだ。これは、君が思うよりもはるかに低いスケールで問題になり始めるよ。数百万行あれば、速度低下が見え始めるのに十分だ。<br>この本[0]（Joe Celkoの『Trees and Hierarchies in SQL For Smarties』）には他の多くのオプションが載ってるけど、俺が好きなClosure tableアプローチ[1]は載ってないね。<br>そしてここで、DBとアプリケーションの間の長年の摩擦に話が戻ってくる。トリガーの話を始めると、開発者はひるむ。DBにロジックを入れたくないって言うんだ。俺が見てきたあらゆるケースで、彼らが考案する代替策は信じられないほど複雑でエラーを起こしやすいけど、まあ、DBにはないからね。トリガーを恐れる理由は全くない、ただし、コードと同じように扱うならばね（だってコードだから）：PRを介してのみ追加／修正／削除し、注意深いレビューとテストを行う。<br>[0]：<br>[1]：" userName="sgarland" createdAt="2025/05/26 12:41:04" color="#38d3d3">}}




{{<matomeQuote body="俺の理解では、データベースモデルっていうのは、完全に正規化されてるもの——つまり、冗長な情報や繰り返される情報がないようにテーブルを設計すること。リレーショナルDBを勉強するときに習うやつね。<br>そのモデルでは、参照を辿ることでどこからでもどこへでも移動できるんだ。<br>一方、少なくともDDDの観点からのドメインモデルは、少なくともいくつかの点で異なるよ。ドメインクラスはビジネスの振る舞いを公開するし、特定のエンティティを隠すこともできるんだ。<br>例えば、注文を表す必要があるeコマースアプリケーションを想像してみて。<br>DBモデルでは、`order`テーブルと`order_line`テーブルがあって、後者の各行が前者の行を参照する形になるだろう。でも、ドメインモデルでは、代わりに単一のOrderクラスを持っていて、注文明細はメソッド経由でのみアクセス可能で、文字列とかタプルとか、何らかの形式で持つことになるかもしれない——エンティティとしては持たない。Orderクラスは`order_line`テーブルの存在を隠蔽するんだ。<br>さらに、Orderクラスには`markAsPaid()`のようなメソッドがあるだろうし、これはこのタイプの情報をどう永続化するか——enum？boolean？`order`の行を参照する別のテーブル？——といった実装の詳細も隠蔽する。呼び出し側にとっては関係ないことなんだ。" userName="nazgul17" createdAt="2025/05/25 23:57:21" color="#ff5c5c">}}




{{<matomeQuote body="俺にとってドメインモデルとは、自分がモデリングしているドメインに関する情報を、使用する型やデータ構造の中にできるだけ多く取り込むことなんだ。大抵の場合、それは不正な状態を表現できないようにUnion型を使うことを意味するんだ。例えば、データベースネイティブな方法でUnion型を保存する方法を俺は見たことがないんだ。その場合、別のドメイン層を使うことが必須になるんだ。<br>参考までに：" userName="metayrnc" createdAt="2025/05/25 18:25:28" color="#ff5c5c">}}




{{<matomeQuote body="俺にとってドメインモデルは、システム内のデータとやり取りできるオブジェクト指向APIのことだね。もう一つのやり取りの方法はもちろん生のSQL呼び出しだけど、それだとユーザーはデータベーススキーマでデータがどう表現されているかを知る必要がある。一方、OOP APIを使うと、APIメソッドはいくつかの複数のモデルクラスのインスタンスを返すんだ。<br>異なるクラスがメソッド呼び出しによって互いに関連付けられている様子は、俺たちのシステムの「理論」のようなものを明確にするんだ。システム内にどんなオブジェクトがあって、それらがどんな操作を行って、結果として他のどんな種類のオブジェクトを返すか、などなど。だから、生態学的な生物学における「理論」にすごく似ているように見えるよ。複数の種が互いに相互作用しているようなね。" userName="galaxyLogic" createdAt="2025/05/25 21:04:46" color="#ff5733">}}




{{<matomeQuote body="この”理論”はDB自体の中でモデル化できるよ。" userName="Arch-TK" createdAt="2025/05/25 23:42:32" color="">}}




{{<matomeQuote body="ドメインモデルから始めるべきか？リスクあるけど絶対そうすべき。ショートカットはいいけどコード全体でpostgres-types使うのは後々大変だからダメだよ。<br>SQLとかJSONとかドメインモデルが同じならマッピング不要って？いやいや、普通は違うし、ちゃんとした型やID使うでしょ。単純なケースでもマッピングは必要だよ。" userName="valenterry" createdAt="2025/05/26 09:04:24" color="#38d3d3">}}




{{<matomeQuote body="長年の経験から、最近のWeb開発はコードをDBエンジンに入れるのを避けてるだけだと思うんだ。ORMとかはデータを”外部”扱いしてるせいだよ。<br>怖い話だけど、いつかWeb機能付きのJavaScript DBが出てきて、伝統的なDBは終わるかも。パフォーマンスは悪くてもシンプルで生産的だから、きっと流行るよ。" userName="jiggawatts" createdAt="2025/05/26 10:52:08" color="#ff5733">}}




{{<matomeQuote body="それは一つの見方だね。完全に間違いじゃないのが辛いところ。<br>でも100％正しいとも思わないな。今のDBだと難しいこともあるし。そういう機能をDBに詰め込んでも、問題のほとんどは残って”DBレイヤー”の中にあるだけになると思うよ。" userName="NilMostChill" createdAt="2025/05/26 11:01:39" color="#ff5c5c">}}




{{<matomeQuote body="俺が考えてるのは”今ある”DBじゃなくて、エンドツーエンドのJavaScript（かWASM）の全く新しいスタックだよ。AkkaとかOrleansをReactと組み合わせた感じ。<br>”データ”はActorが永続化して、Actorはサーバーでもブラウザでも全く同じコードで動かせる。ActorのアドレスはHTTP URIになるから呼び出し規約が統一されるんだ。" userName="jiggawatts" createdAt="2025/05/26 22:55:45" color="#ff5c5c">}}




{{<matomeQuote body="面白そうだね。でも、結局問題の場所を移してるだけだよ。<br>モデルをストレージ層に近づけるのはいいけど、他のストレージ問題はなくならないし、Actor層でトランザクションとか扱うのは注意が必要だね。<br>JavaScriptは嫌いだけど、WASMベースなら興味あるかも。動くモデルを見てみたいね。" userName="NilMostChill" createdAt="2025/05/27 05:40:59" color="#785bff">}}




{{<matomeQuote body="そうだね、デバッグも最適化もできないDBの中だね。" userName="corey_moncure" createdAt="2025/05/26 13:51:19" color="">}}




{{<matomeQuote body="DBエンジンに高度な機能を入れるなら、たぶんそこそこまともなデバッグサポートも入れるだろうね（そう願いたいけど）。<br>でもやっぱり、問題を解決してるんじゃなくて、場所を移してるだけだよ。" userName="NilMostChill" createdAt="2025/05/26 14:15:39" color="">}}




{{<matomeQuote body="君の言う通り100％その通りだよ。でも俺が何か見落としてなければ、これって（ありがたいことにJavaScriptじゃないけど）PostgREST [0]で既にやられてるんじゃない？<br>[0]: https://docs.postgrest.org/en/v13/" userName="sgarland" createdAt="2025/05/26 12:44:48" color="#38d3d3">}}




{{<matomeQuote body="Convexを紹介するね。<br>https://www.convex.dev/<br>免責事項：僕は精神的に似てるSpacetimeDBの開発者だよ。クライアントサイドでも動かすつもりで、クライアントサイド予測に必要だからね。いつかWebレンダリングもやると思うよ。" userName="cloutiertyler" createdAt="2025/05/28 21:21:28" color="#38d3d3">}}




{{<matomeQuote body="俺は筆者の意見に反対だな．データストアはpostgres，Kafka，RabbitMQ，redis，memcache，elasticsearchとか色々あるし，HTTP APIも普通ある．全部postgresって訳にもいかない時が多いし，「コードがDBに属する」って言っても結局APIが必要．問題を後回しにしてるだけに見える．JavaScript製のDBが従来のDBを終わらせるって話は，SpacetimeDBやSparkもあるし，万能解はないから起きないと思うな．全部トレードオフだ．" userName="valenterry" createdAt="2025/05/26 14:03:19" color="#ff5733">}}




{{<matomeQuote body="KafkaとRabbitMQは別物で，混同は誤用の証拠だよ．キューならKafkaじゃないし逆も然り．<br>redisやmemcacheは，ちゃんとしたRDBMS（Postgres，MySQL，SQLiteとか）のチューニングで不要なことが多い．RDBMSの高性能にはみんな驚くはずだけど，大規模運用が難しいからキャッシュを前に置くのが楽なんだね．<br>elasticsearchも，RDBMSのFTSで十分な場合が多い．ESは管理複雑だし．" userName="sgarland" createdAt="2025/05/26 14:35:15" color="#785bff">}}




{{<matomeQuote body="こういうプレゼンが記事形式になってたら良いのになーって時は確かにあるね．YouTubeの文字起こしを抜き出してみたけど，脇道に逸れた話とかジョークとか”えー”とかが混ざっててすごく読みにくかった．聴衆の前で話すときの自然なものだけど，長い文章になるとノイズでしかないんだよね．" userName="HappMacDonald" createdAt="2025/05/25 22:32:55" color="">}}




{{<matomeQuote body="AIなら文字起こし綺麗にできそうだよね？ LLMにうってつけっぽい．<br>―――<br>ちなみに俺が講演者なんだけど，正直最近は全然書く気起きないんだ．<br>前はブログ書いてCfPに出してたけど，最近のTwitterやGoogleの変更で，HN frontageに当たるくらいしか多くの人に読まれるチャンスが無い宝くじ状態になっちゃった．だからYouTubeにも手を出した．<br>考えまとめて話すのは大変だけど，講演だとIRLの交流があるのが重要なんだ（内向的な俺には）．<br>公共のウェブを殺して種を食い潰してるってことをもっと言いたいね．" userName="hynek" createdAt="2025/05/25 22:47:13" color="">}}




{{<matomeQuote body="これ，Gemini 2.5 Proで綺麗にしてみたやつだよ：https://rentry.org/nyznvoy5<br>YouTubeのリンクをAI Studioに貼り付けて，再現したいならこのプロンプトをあげたんだ：<br>このトークを記事形式に再フォーマットして．えー／あーは削除して，ただし要約はしないで，内容は実質的に同じになるように．可能ならスライドの内容も含めて．" userName="moozilla" createdAt="2025/05/26 02:08:32" color="#ff5c5c">}}




{{<matomeQuote body="なかなか良いね．ただBismarckじゃなくてFontaneだよ． 😉 あと，俺は転記されてるやつじゃなくてCGP Greyと比較してるんだ． 😄" userName="hynek" createdAt="2025/05/26 06:25:36" color="">}}




{{<matomeQuote body="トークの一部，https://www.amundsens-maxim.com/ を思い出したよ．" userName="vinipolicena" createdAt="2025/05/25 17:58:40" color="">}}




{{<matomeQuote body="あのトークを作業してる時にこれ見たかったな！リソースに追加しとくわ！" userName="hynek" createdAt="2025/05/25 23:01:23" color="">}}




{{<matomeQuote body="1ヶ月前に逆の問題あったんだよね。既存データもドメインモデルもAPIもないGreenfieldプロジェクトで。APIとか永続化レイヤーをドメインモデルと違うようにモデリングする理由なかったから、同じクラスを3回実装して、その上にマッピングを2つ乗っけたんだ。何のために？<br>まあ、いつかAPIコンシューマーとか既存データができて、その時のシステムを変えなきゃいけなくなるからさ。" userName="knallfrosch" createdAt="2025/05/25 18:21:33" color="#ff5c5c">}}




{{<matomeQuote body="面白いね。たぶん、モダンな便利さが結合を促してるのかも。だからシングルモニターとかLSP使わない達人がたくさんいるのも納得だよ。" userName="leecommamichael" createdAt="2025/05/25 18:51:25" color="">}}




{{< details summary="もっとコメントを表示（1）">}}

{{<matomeQuote body="筆者の言う設計圧力を、コードの形を作る一番の要因としてキャリアで捉えてきた。これが成功アーキテクチャで一番大事で、直感ベースだから銀の弾丸はない。感覚がないとベストプラクティスも台無し。これは味覚みたいに育てて言葉にできない。将来の失敗を予測できるのが目標だ。<br>元同僚と連絡取って進化を学んでる。この感覚を持つアーキテクトとは楽しいが、ベストプラクティス一辺倒な人は無理。" userName="g958198" createdAt="2025/05/25 15:29:39" color="#ff5733">}}




{{<matomeQuote body="Zen and Art of Motorcyle maintenanceは良い参考文献だね。あと、どんなゲームが実際プレイされてるか思い出すのも大事。「”ベストプラクティス”」を誰かが広める時、なんで？って。多くの場合、Uncle Bobみたいなのは自己宣伝のため。ほとんどのベストプラクティスは擁護できなくて、支持者はヤバくなるとad-hominem攻撃するんだ。" userName="osigurdson" createdAt="2025/05/25 16:23:38" color="#ff5c5c">}}




{{<matomeQuote body="コードは機械で動かす必要あるけど、主に人間とコミュニケーションするためのもの。パターンや原則、ベストプラクティスは、将来の自分も含め、他の人が理解しやすく、推論しやすくするためだよ。柔軟性は大事だけど、共通パターンとかメタファーはマジすごい。" userName="skydhash" createdAt="2025/05/25 15:57:38" color="#ff33a1">}}




{{<matomeQuote body="それ、ひどく近視眼的だよ。すごいクリアなアーキテクチャとコードでも、必要なユースケースをほぼゼロからやり直さないとサポートできないことだってあるんだから。" userName="rowanG077" createdAt="2025/05/25 17:14:17" color="#45d325">}}




{{<matomeQuote body="これまで設計された中で一番柔軟なシステムを持ってるとしても、チームの他のメンバーがそれを理解してなかったら、必要なユースケースを実装するのに苦労するだろうね。" userName="semicolon_storm" createdAt="2025/05/25 18:10:43" color="#785bff">}}




{{<matomeQuote body="両極端がダメなのは当然。それは言ってない。システムが使えないなら、設計が明確でも意味ないってこと。前の人が「コードは機械で実行される必要があるけど、主に人間とコミュニケーションするためのもの」って言ってたけど、それならこんな変な言語使わないよ。コードの目的は動いて機能を提供すること。でも人間が読めるのはいいね。" userName="rowanG077" createdAt="2025/05/25 20:38:43" color="">}}




{{<matomeQuote body="その言葉は全然違う。コードは機械とのコミュニケーションが一番の目的。人間となら人間の言葉を使う。コードが人間にわかる必要はあるけど、それが主な目的じゃないんだよ。" userName="immibis" createdAt="2025/05/25 18:29:56" color="#38d3d3">}}




{{<matomeQuote body="なんでJVM向けにJava, Kotlin, Scala, Groovy, Clojureとか色々あるの？ 機械はオペコードとビットだけだけど、人間には無理だからアセンブリとかにする。それより上の抽象化は、ほとんどコードを考えたり他の人と共有するためだよ。手続きとかOOPとか、問題をモデル化するのに役立つ良い抽象化を見つけて言語に入れる。VMごと作る価値があるほど良いのもある（Lispのホモイコニシティ、Smalltalkとかね）。" userName="skydhash" createdAt="2025/05/25 18:53:45" color="#ff5c5c">}}




{{<matomeQuote body="読みやすく拡張できるコードで、現実の問題を解決するためだよ。コードを書く目的は問題解決。読むためって言うのはおかしい。脚本を書くのは読むためじゃなく上演するため、音楽は見るためじゃなく聞くためだろ。コードを書くのも実行するためだよ。問題をモデル化した後？ 解決するんだ！ 実行するんだ！ 全部そのためさ。" userName="kaashif" createdAt="2025/05/25 23:26:42" color="#785bff">}}




{{<matomeQuote body="＞ 誰も一人でやるわけじゃない。共通の記法があるのは、みんなでちゃんと解決策を共有するためだよ。数学とか音楽とか、記法があるのは作ったものを他の人に共有したいから。そうじゃないなら、完成品だけ渡せばいい。だから音楽を書くのは聞いて楽しむためじゃない。自分で演奏すればいい。でも他の人にやってもらうなら、楽譜みたいな共通の記法が必要なんだよ。" userName="skydhash" createdAt="2025/05/26 01:12:32" color="#38d3d3">}}




{{<matomeQuote body="＞ 誰も一人でやるわけじゃない。いや、やるよ。一人で開発してる人も、一人で音楽作って演奏してる人もいっぱいいるじゃん。" userName="kaashif" createdAt="2025/05/26 08:50:46" color="">}}




{{<matomeQuote body="コードの二番目の目的は人間とのコミュニケーションだからだよ。だから読みやすさはすごく大事。ただ、一番の目的ほどじゃないってことね。" userName="rowanG077" createdAt="2025/05/25 20:41:29" color="">}}




{{<matomeQuote body="コード自体が機械だと思うな。高レベル言語でもね。コードマシンは言葉みたいに見えるから、それで考えられるって勘違いする。それは無理。コードは機械を作るためのもので、どう動くかは普通の技術文書を読んで理解すべき（でも普通の説明に決まりはないけどね）。" userName="Mikhail_Edoshin" createdAt="2025/05/25 19:51:14" color="">}}




{{<matomeQuote body="もしそうなら、俺たちは記号なしのバイナリでアセンブリだけ書いてるはずだろ。" userName="mejutoco" createdAt="2025/05/26 14:30:20" color="">}}




{{<matomeQuote body="これって機械とコミュニケーションする許容できるやり方だと思う？" userName="immibis" createdAt="2025/05/27 08:52:17" color="">}}




{{<matomeQuote body="メインの目的じゃないってのは当然その通りなんだけどさ，ここでは議論が，単にコードを動かすことじゃなくて，長期的なメンテナンス性を考慮した設計についてみたいだね．" userName="necovek" createdAt="2025/05/25 19:56:48" color="">}}




{{<matomeQuote body="彼が返信した人は，コードは主に他の人とコミュニケーションするためのものだって言ってたんだ．文字通り書かれてる通りに解釈する以外，どう解釈すればいいのかわかんないな．" userName="rowanG077" createdAt="2025/05/25 20:40:31" color="">}}




{{<matomeQuote body="人間の言語は不完全だよ．彼らは”他の”人たちとは言ってなくて，ただ”人間”って言ってただけだよ（自分自身も含まれるよね）．だからもう文字通りに解釈してないじゃん．みんなバイアスはあるさ（それに，機械語だってコードだけど，それを誤解した人は誰もいないよね）．俺は，その引用を，人間がコードについて推論できるように，特に変更が必要なときに更新できるように，きれいなコードを書くために余計な手間をかけてる，ってことだと捉えたんだ．それこそが，直接機械語じゃなくてプログラミング言語を発明した主な理由だと思うな．" userName="necovek" createdAt="2025/05/26 14:38:34" color="#38d3d3">}}




{{<matomeQuote body="あんた，”主に”って言葉を”主に”って意味じゃないって捉えてるじゃん．まあ，そうすることもできるけど，あんまり説得力ないと思うな．もしかしたら彼らは言い間違い（書き間違い）したのかもしれないけど，それは彼らの発言に反応した人のせいじゃないだろ．" userName="rowanG077" createdAt="2025/05/26 16:28:42" color="">}}




{{<matomeQuote body="いや，”主に”って意味で捉えてるよ，でもその話題の別の側面を指してるんだ．" userName="necovek" createdAt="2025/05/26 18:01:21" color="">}}




{{<matomeQuote body="新しい社員については，まさにこの価値観を持って生きてる人を探すんだ．そして，いい人間であることは必須．それ以外のことは学べるから．" userName="SeriousM" createdAt="2025/05/26 16:42:07" color="#ff33a1">}}




{{<matomeQuote body="これ，デザインパターンの”forces”（力）っていう概念に似てるね．パターンを選ぶときは，特定の文脈での力を評価・比較検討する必要があるんだ．デザインをある方向に引っ張るからそう呼ばれるんだよ．”pressure”（圧力）とは違う物理学のアナロジーだね．［0］ https://www.cs.unc.edu/~stotts/COMP723-s13/patterns/forces.h...［1］ https://www.pmi.org/disciplined-agile/structure-of-pattern-p...［2］ Chapter 19 in “Pattern languages of program design 2”， ISBN 0201895277" userName="layer8" createdAt="2025/05/25 15:46:32" color="#ff33a1">}}




{{<matomeQuote body="ここにSQLModelへの暗黙的な批判だって言うコメントがあったんだけど，返信しようと思って戻ってきたら消えてたよ．変なの．暗黙的だったからスライドには見つけられなかったけどね．" userName="Noumenon72" createdAt="2025/05/25 17:32:53" color="">}}




{{<matomeQuote body="あのコメント，俺が書いてすぐに消したんだ．オープンソースプロジェクトについて公に否定的なこと言うのは絶対したくないんだよね．みんな信じられないくらい一生懸命作ってメンテしてるプロジェクトだからさ．あのコメントは一線を超えたって感じたんだ．<br>とにかく，あのトークにはPydanticとSQL Alchemyのロゴ両方があるスライドがあったじゃん．俺が知る限り，この2つを繋いでる（そこそこ人気のある）ライブラリは一つだけだよ．スピーカーは，データとかドメインとかAPIとか，他のモデルは関連してるけど別々であるべきだっていう説得力のある主張をしてると思うんだ．" userName="davepeck" createdAt="2025/05/26 01:09:48" color="#38d3d3">}}




{{<matomeQuote body="attr.ibとattr.sが良いアイデアだと思ったやつから設計アドバイスを受けようとは思えないな。一方で、彼がDDDは空虚なカルトだと言ってるのは本当だけどね。" userName="da39a3ee" createdAt="2025/05/25 15:27:58" color="">}}




{{<matomeQuote body="DDDを批判する前に、patternitisとかover-OOPificationをもっと問題視すべきだね。確かに後者もやりすぎることはあるけど、最初の二つの方がずっと頻繁に濫用されてる。幸い、pattern crazynessはかなり落ち着いてきたけどね。" userName="switchbak" createdAt="2025/05/25 19:32:03" color="">}}




{{<matomeQuote body="あれは俺のattrsライブラリのことだよ。dataclassesの元。＠attr.sみたいなAPIは賛否両論あったけど、type hints前で”syntax noise”少なくクラス宣言できて効果的だったんだ。APIの一部にインポート名使うから読みやすかった。詳細はここ： https：//www.attrs.org/en/stable/names.html<br>後悔はしてない！" userName="hynek" createdAt="2025/05/25 20:33:25" color="#ff5733">}}




{{<matomeQuote body="参考までに言うと、俺は”loved it”派だったよ（俺、dataclassesの作者で、Hynekには計り知れない恩があるんだ）．" userName="ericvsmith" createdAt="2025/05/25 23:31:14" color="#ff5c5c">}}




{{<matomeQuote body="DDDは特に最初のフェーズでは良いね．コンセプトは全部、昔の原則を焼き直したものだよ．全く新しいものはないね．" userName="skydhash" createdAt="2025/05/25 15:59:59" color="">}}

{{</details>}}



[記事一覧へ]({{% ref "/posts/" %}})
