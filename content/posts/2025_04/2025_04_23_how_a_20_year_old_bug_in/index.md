+++
date = '2025-04-23T00:00:00'
months = '2025/04'
draft = false
title = '「マジかよ」GTAサンアンドレアスの20年前のバグがWindows 11最新版で発覚した件'
tags = ["GTA", "Windows 11", "バグ", "ソフトウェア", "レガシーコード"]
featureimage = 'thumbnails/blue2.jpg'
+++

> 「マジかよ」GTAサンアンドレアスの20年前のバグがWindows 11最新版で発覚した件

引用元：[https://news.ycombinator.com/item?id=43772311](https://news.ycombinator.com/item?id=43772311)

{{<matomeQuote body="これぞRaymond Chenって感じのことだよねー。マジで最高の褒め言葉！なんでそうなったのか、さらに深く追求して解明してくれたのが嬉しいな。" userName="bombcar" createdAt="2025-04-23T14:59:06" color="#ff5733">}}

{{<matomeQuote body="randomasciiもそうかもね。マジでレジェンドだよ（でも最近、辛いことが続いてるみたい…。良い方向に向かうといいな）。" userName="aneutron" createdAt="2025-04-23T21:09:23" color="#ff33a1">}}

{{<matomeQuote body="＞https:／／randomascii．wordpress．com／2024／10／01／life－death－and－…<br>＞https:／／randomascii．wordpress．com／2016／10／17／vestibular－dysf…" userName="wiseowise" createdAt="2025-04-24T00:09:55" color="">}}

{{<matomeQuote body="これ読むたびにミニ中年クライシスになってたの思い出すわー。<br>今回はちゃんと記録したんだよねー…はぁ…<br>＞https:／／github．com／MatthewJohn／terrareg／commit／2231ba733a7f5…" userName="mrmattyboy" createdAt="2025-04-24T08:11:21" color="">}}

{{<matomeQuote body="数年付き合ってる相手と先週末に一緒に住み始めたんだけど、彼の奥さんが9週間で亡くなったっていうブログ記事を読んで、マジでゾッとした…抱きしめてほしい。" userName="4ggr0" createdAt="2025-04-24T12:09:20" color="#45d325">}}

{{<matomeQuote body="マジか…。読むのが辛かった。彼は才能があって尊敬できる人だよね。これから良い方向に進むことを願ってる。" userName="dataflow" createdAt="2025-04-24T04:28:20" color="#ff33a1">}}

{{<matomeQuote body="Raymondはマジで魔法使いだよ。彼のブログを長年読んでるけど、彼のスタイルと知識が大好き。" userName="martinsnow" createdAt="2025-04-23T16:00:49" color="#785bff">}}

{{<matomeQuote body="彼はマジでレジェンドなのに、Dave’s GarageのYouTubeチャンネルのインタビューで言ってたけど、Bill Gatesに一度も会ったことがないらしい。会社で長年活躍してる人なら、彼が出席する会社のディナーに招待されてもおかしくないのにね。" userName="Discordian93" createdAt="2025-04-23T18:34:16" color="#ff5c5c">}}

{{<matomeQuote body="Microsoftってでかい会社だし、billgは2000年に一線を退いたんだよね。Raymondはまだ働いてるから、思ってるほど重なってないんじゃない？" userName="bombcar" createdAt="2025-04-23T19:34:25" color="">}}

{{<matomeQuote body="彼のブログにはWindows 2の話も載ってるみたいだから、まだ比較的小さかった頃には重なりがあったんだよね。だから、彼らが一度も話したり会ったりしたことがないっていうのは、ちょっと不思議な気がするな。" userName="iforgotpassword" createdAt="2025-04-24T14:06:25" color="">}}

{{<matomeQuote body="細かいことだけど、スクリーンショットじゃなくて、実際にコードを書いて例を示してくれるのがすごくいいよね。例えば、https://devblogs.microsoft.com/oldnewthing/20250414-00/?p=11...　もっといい例もたくさんあるけど、これは最近見たやつ。" userName="MattSayar" createdAt="2025-04-23T20:40:19" color="#38d3d3">}}

{{<matomeQuote body="Raymondは何でも知ってるんだね。Alpha AXPのマイクロコードのバグから、テンプレートメタプログラミング、UIまで。" userName="RcouF1uZ4gsC" createdAt="2025-04-23T16:05:20" color="#785bff">}}

{{<matomeQuote body="Deloitte、PwC、KPMG、Bain、EY、McKinsey、BCGのコンサルタントが、彼をTop Xのリストに入れたりして、何度か無邪気に彼を『影響を受けた人』の候補に挙げようとしたんだろうね。Yでソートされたスプレッドシートの上位にいたからって。" userName="transcriptase" createdAt="2025-04-23T20:00:39" color="">}}

{{<matomeQuote body="＞こいつの仕事はブログを書くことみたいだな。<br>＞AIで代用して、新しいVisual Enshitify 2.0の製品発表を定期的に宣伝させればいいじゃん。Win win win!ってか？" userName="billforsternz" createdAt="2025-04-23T22:12:06" color="">}}

{{<matomeQuote body="思うんだけど、契約の一部じゃないものはランダム化されるべきだよね。例えば、マップの反復順序が言語で保証されてないなら、言語はわざとそれをランダム化するべき。そうしないと、脆いコードになっちゃう。動かなくなるまで動くコードね。" userName="amenghra" createdAt="2025-04-23T18:08:08" color="#ff33a1">}}

{{<matomeQuote body="未初期化変数を特定の値（またはランダムな値）で初期化するためのコンパイラオプション（-ftrivial-auto-var-initなど）はいろいろあるけど、関数呼び出しごとにスタックの内容全体をランダム化（またはゼロ化）すると、パフォーマンスが著しく低下するから、そんなことはしないんだ。" userName="bri3d" createdAt="2025-04-23T18:29:49" color="#45d325">}}

{{<matomeQuote body="高速な命令（REP STOSx、AVX zero stores、dc zvaなど）やトリック（MTE、zero pages）はあるけど、関数呼び出し時にスタックを透過的かつ効率的にランダム化またはゼロ化する魔法のようなCPU命令は存在しないんだよね。そういうのがあってもいいと思うし、一部の特殊な高セキュリティシステムにはあると思うけど、どこで見つけられるかわからないな。Telecomには絶対ない。" userName="neuroelectron" createdAt="2025-04-24T01:39:20" color="">}}

{{<matomeQuote body="そういうふうに動作するCPUアーキテクチャも提案されてるよ。例えば、Mill <https://millcomputing.com/>。ほとんどのCPUが複数の呼び出し規約をサポートしているのに対して、Millはハードウェアで単一の呼び出し規約を強制してるんだ。ハードウェアには`call`命令があって、すべての作業を直接行うし、関数呼び出しから戻るための`ret`命令もある。TLB相当のものを使って、各関数が引数を含むスタックの部分からのみ読み取る許可を与えられてることを保証してる。その領域外を読み取ろうとすると、NaR（Not a Result、浮動小数点NaNに似てる）を返すアクセス許可エラーが発生する。<br>さらに、新しいスタックフレームは作成時に暗黙的にゼロ化される。これは、呼び出された関数の実行を続行する前に、それらのアドレスに対してCPUキャッシュをゼロで埋めることによって行われると思う。実際のゼロがメインメモリに書き込まれるのを待つ必要はないんだ。<br>https://millcomputing.com/wiki/Protection#Protecting_Stacks" userName="db48x" createdAt="2025-04-24T04:33:04" color="#785bff">}}

{{<matomeQuote body="これマジで興味深いんだけどー。この設計だとスタック参照ってどういう仕組みになってんの？" userName="smj-edison" createdAt="2025-04-24T14:45:25" color="">}}

{{<matomeQuote body="厳密に言うとスタック全体を読めると思うよ。制限されてるのはスタックの端っこの読み取りだけじゃね？ ただ、今のスタックの始まりが本当のスタックの始まりとは限らないから注意して。例えば`read`みたいなシステムコールの場合。<br>ユーザー空間にいて、普通にスタックフレームがあるじゃん。スタックにバッファを確保して(CPU命令がある)、そこに読み込みたいデータを置く。んで、`read`を`call`命令で呼ぶ。引数にはバッファのアドレスとかサイズとか渡す。<br>`read`はカーネルの一部だから、違う保護ドメインにいるんだよね。CPUが事前に設定されたメタデータを使って、これを”ポータルコール”に変える。ポータルコールの後、スレッドには別の保護ドメインが与えられる。`read`から見ると、スタックは始まったばかりで、前のフレームはない。実際には、このスタックフレームは呼び出し元のスタックの一部だけど、アクセスできる範囲が変わってる。前のスタックフレームは存在するけど、読めない。バッファも読めない。カーネルのアクセス範囲にないアドレスにあるから。<br>だから、アクセス範囲を変更するための命令が必要になる。`pass`命令を使うと、呼び出す関数に一時的にバッファへの読み書き権限を渡せる。コールバック後は自動的に権限が取り消される。(毎回手動でやる必要はない。libcにある非ポータルの`read`関数を呼ぶ。この関数がポータルコールを担当してて、`pass`命令も入れる。) ¹ turfは、ある保護ドメインで実行されているスレッドが読み書きできるアドレスの集合。" userName="db48x" createdAt="2025-04-25T03:05:21" color="#38d3d3">}}

{{< details summary="もっとコメントを表示（1）">}}
{{<matomeQuote body="ランダムにはできないけど、メモリ、キャッシュ、書き込み行の使用にパフォーマンスの低下があることを前提にすると、プログラム、ライブラリなどのためにスタックアドレスを分離できるかも。ただ、コストがかかる。コンテキストスイッチごとに独自のスタックが必要になり、もう1つレジスタをプッシュ/復元する必要がある。プログラムがそのように動作せず、適切に初期化された(後で上書きされない)メモリ外の値に依存しないことになっているのには、ちゃんとした理由がある。" userName="mjevans" createdAt="2025-04-24T02:22:53" color="">}}

{{<matomeQuote body="効率的であるべきだけどね。それがポイント。専用のハードウェアまたは命令を使用すると、スタックを1サイクルでゼロにできるはず。そうじゃなくて、今はもっとコストがかかる。ただ、これだと何かを隠すのに使えちゃう可能性もあるから、未知のエクスプロイトをリバースエンジニアリングできなくなるかも。" userName="neuroelectron" createdAt="2025-04-24T06:47:43" color="">}}

{{<matomeQuote body="なんで専用の命令が必要なの？ スタックは他のものと同じようにメモリに保存されてるじゃん。<br>コストがかかるのは、CPUの速度に比べて、値をメモリに書き出すのがめちゃくちゃ遅いから。それと、その書き込みを他のキャッシュと同期させるオーバーヘッドもある。<br>もしかして、仮想メモリから物理メモリへのルックアップテーブルにある「すべてゼロ」の特別なページのこと考えてる？ それも結局は、使われるなら実際に書き込む必要がある。" userName="mjevans" createdAt="2025-04-24T14:28:40" color="">}}

{{<matomeQuote body="CPUはすでに`xor reg,reg`をレジスタをゼロにする特殊なケースとして扱って、データ依存性を解消してる。スタックのビットをゼロにすることが一般的になれば、CPUが効率的に処理できるようになると思う(すでにスタックを特別扱いしてるし、push/popとか)" userName="dwattttt" createdAt="2025-04-24T06:44:46" color="">}}

{{<matomeQuote body="ちょっと疎遠になっちゃってるんだけど、C++26には`-ftrivial-auto-var-init`みたいなのがデフォルトで有効になるみたい。[1]の”safe by default”のセクションを見てみて。<br>ちなみに、C++26に採用された実際の提案は[2]。パフォーマンスについては一般的にしか議論されてなくて、[3]で詳しく分析されてる。このリファレンスには、時間とコードサイズで約0.5%の低下って書いてある。初期のプロトタイプではもっと大きな低下(最悪の場合”horrendous”)が示唆されてたけど、コンパイラの最適化に力を入れたことで、かなり改善されたみたい。<br>もちろん、環境によって結果は違うと思うし、0.5%の低下を受け入れられない人もいるかも。でも、C++委員会は、頻繁に発生する未定義の動作を削除するために、許容できるトレードオフだと考えたみたい。" userName="smarks" createdAt="2025-04-24T05:16:15" color="#785bff">}}

{{<matomeQuote body="MicrosoftのVisual C++コンパイラには、`/Ge`コンパイラオプションがある(https://learn.microsoft.com/en-us/cpp/build/reference/ge-ena... を見て)。VC2005から非推奨。<br>このコンパイラオプションを使うと、コンパイラはスタックプローブ関数を呼び出して、十分なスタック領域があることを確認する。<br>スタックページごとに1回プローブする代わりに、スタックフレームを特定の値(0xBAADF00Dみたいな)で*埋める*関数を代用できる。値を実行時に好きなように設定できる。<br>これはgcc/clangの`-ftrivial-auto-var-init`と似たような動作になる。<br>Windowsは、Windowsカーネルや他のいくつかの領域で、ほとんどのスタック変数を自動的に初期化し始めた。<br>自動的に初期化される型:<br>　　スカラー(配列、ポインタ、float)<br>　　ポインタの配列<br>　　構造体(POD構造体)<br>自動的に初期化されないもの:<br>　　Volatile変数<br>　　ポインタ以外の配列(intの配列、構造体の配列など)<br>　　PODじゃないクラス<br>最初のテストで、スタック上のすべての型のデータを強制的に初期化したら、いくつかの主要なシナリオで10%以上のパフォーマンス低下が見られた。<br>POD構造体だけだと、パフォーマンスはもっとマシになった。コンパイラの最適化によって、基本的なブロック内とブロック間の両方で冗長なストアが排除され、POD構造体によるパフォーマンスの低下はほとんどのテストでノイズレベルまで低下した。<br>すべての型(特にオプティマイザーが強力になった)をゼロ初期化することを計画してるけど、まだ手が回ってない。<br>https://web.archive.org/web/20200518153645/https://msrc-blog... を見て" userName="canucker2016" createdAt="2025-04-24T11:17:16" color="#45d325">}}

{{<matomeQuote body="このレベルでのランダム化はコストが高すぎる。デバッグ目的でこれを行うツールはあるけど、そのモードだと処理がめっちゃ遅くなる。" userName="frollogaston" createdAt="2025-04-23T20:27:54" color="">}}

{{<matomeQuote body="Perlについて読んだ記事を見つけるためにググった。これはdictのイテレーション順序に影響すると思う。<br>＞2012年11月22日 — Perl 5.18では、プロセスごとのハッシュランダム化が導入され、ほぼ確実に新しいハッシュ関数が採用されます。" userName="throwaway2037" createdAt="2025-04-24T02:55:20" color="">}}

{{<matomeQuote body="それってリリース版に入れるべきじゃないよね、マジで。誰かの”セット”が実はシーケンス（重複あり）で、デバッグビルドでアサートが発生したら、日の目を見ずに終わるバグって結構あるんじゃないかな。" userName="foxhill" createdAt="2025-04-23T21:02:49" color="">}}

{{<matomeQuote body="デバッグビルドって問題を見つけるのに役立たないよね。誰が実際に使うのさ？開発者がバグを再現しようとするときに、作業中の個々のバイナリのデバッグビルドを使うくらいじゃない？Windowsチーム含め、どの会社でもデバッグビルドを普段使いする人なんて見たことないよ。" userName="Arainach" createdAt="2025-04-24T00:36:32" color="">}}

{{<matomeQuote body="特にゲームだと、最適化されたリリースビルドじゃないとまともに動かないのが普通だよね。" userName="dontlaugh" createdAt="2025-04-24T02:03:02" color="#ff33a1">}}

{{<matomeQuote body="だよねー、統合テストですらoptモードで実行されそう。" userName="frollogaston" createdAt="2025-04-24T16:37:01" color="">}}

{{<matomeQuote body="契約についてだけど、ここから学べる教訓があるよ。引用すると”内部実装のスタックレイアウトの変更でさえ、アプリケーションにバグがあって、意図せず特定の挙動に依存している場合、互換性に影響を与える可能性がある”<br>Linuxカーネルのメンテナがユーザースペースを壊さないように主張する理由もそこにあるんだろうね。" userName="abnercoimbre" createdAt="2025-04-23T18:45:06" color="#785bff">}}

{{<matomeQuote body="でも、ここでのLinuxで言うならカーネルじゃなくてglibcじゃない？" userName="cylemons" createdAt="2025-04-24T09:15:13" color="">}}

{{<matomeQuote body="違うよ。hyrumslaw.comを思い出して。<br>APIの利用者が十分に多い場合、契約で何を約束しようと関係ないんだ。システムで見られるすべての挙動は、誰かに依存されることになる。<br>ランダム化を約束したら、誰かがそれに依存するんだよ！そして、もう削除できなくなる！" userName="tantalor" createdAt="2025-04-23T21:03:19" color="#ff5733">}}

{{<matomeQuote body="ちょっと似てる話。GoogleのSite Reliability Engineeringの本に載ってたんだけど、あるシステムのパフォーマンスがSLOを超えてたせいで、みんなが100%の稼働率を期待するようになっちゃったんだって。それで、SLAに近づけるためにエラーを発生させて、下流のエンジニアにサービスが理由もなく失敗することがあるってことを受け入れさせたんだとか。どこでもできるわけじゃないけど、面白いと思った。" userName="scott_w" createdAt="2025-04-24T09:03:19" color="#45d325">}}

{{<matomeQuote body="＞If you promise randomization<br>そんなこと約束しないよ。順序は未定義だって言うだけ。" userName="timewizard" createdAt="2025-04-24T00:43:53" color="">}}

{{<matomeQuote body="そこがポイントじゃないんだ。実際、ランダム性を提供したら、誰かに依存されるってこと。" userName="__float" createdAt="2025-04-24T03:07:29" color="">}}

{{<matomeQuote body="それってなんで？単にコーディングの悪い癖が原因？" userName="psnehanshu" createdAt="2025-04-24T03:27:40" color="">}}

{{<matomeQuote body="全部コーディングの悪い癖だよ。だからこうなってるんだって。" userName="simonask" createdAt="2025-04-24T06:37:00" color="">}}


{{< /details >}}
{{< details summary="もっとコメントを表示（2）">}}
{{<matomeQuote body="ランダム化しないようにランダムにできるってこと？" userName="dwattttt" createdAt="2025-04-24T03:00:00" color="">}}

{{<matomeQuote body="Cみたいな言語の利点の一つは、使う機能にだけコストを払えばよくて、未使用変数の初期化みたいな不要なオーバーヘッドがないこと、って意見もあるかもね。" userName="ormax3" createdAt="2025-04-23T19:24:02" color="#38d3d3">}}

{{<matomeQuote body="デバッグモードとかカオスモンキーモードならそういう機能にお金を払ってもいいんじゃない？リリースモードでは払わなくていいし。Rustも同じで、整数のオーバーフローはデバッグモードでは完全にチェックされるけど、リリースモードでは黙ってラップアラウンドするよ。" userName="nayuki" createdAt="2025-04-23T19:40:34" color="#38d3d3">}}

{{<matomeQuote body="Adaだと、整数のオーバーフローチェック(実行時)にお金を払うこともできるよ。Ada SPARKを使えば、コードに整数のオーバーフローがないことを証明できるから、実行時チェックは不要になる。" userName="irundebian" createdAt="2025-04-23T20:16:27" color="#ff5c5c">}}

{{<matomeQuote body="Adaの場合はフラグでチェックを無効にできるし、SPARKなら実行時には何も起こらないよ。<br>＞Check the table at<br>＞https://docs.adacore.com/spark2014-docs/html/ug/en/usage_sce...<br>＞, look for “SPARK builds on the strengths of Ada to provide even more guarantees statically rather than dynamically.”. <br>＞More reading:<br>＞https://docs.adacore.com/spark2014-docs/html/ug/en/tutorial....<br>＞https://learn.adacore.com<br>＞(many books for learning Ada and SPARK) available in PDF, EPUB, and HTML format。<br>" userName="johnisgood" createdAt="2025-04-23T21:29:46" color="#ff33a1">}}

{{<matomeQuote body="それだと、リストのランダム化に実行時のクロックサイクルを無駄にしてるってことだよ。" userName="willcipriano" createdAt="2025-04-23T18:59:12" color="">}}

{{<matomeQuote body="まともな言語ならリストのイテレータはリストの順序に従うように設計するでしょ。問題は順序のないハッシュベースのセットやマップ/辞書をイテレートする場合だよ。多くの言語はイテレーションの順序を未定義にしてる。Pythonは途中までそうだったけど、その後辞書(セットは違う)はキーが追加された順にイテレートするように定義したんだ。あと、意図的にプログラムの実行ごとに順序をランダム化して、ユーザーがハッシュテーブルに衝突するキーを詰め込むのを防ぐ言語もある。" userName="nayuki" createdAt="2025-04-23T19:42:07" color="#45d325">}}

{{<matomeQuote body="最高の変更だよね。セットも順序付けされてたらもっと良かったのに。" userName="mabster" createdAt="2025-04-23T22:21:25" color="#785bff">}}

{{<matomeQuote body="C/C++の精神とはちょっと違うかもね。でも、このバグはデバッグビルドで簡単に見つかるはずだよ（20年前でも）。ただ、ゲームだとデバッグビルドは遅すぎて使えなかったのかも。俺のゲーム開発の経験ではそうだった。でも、20年も持つコードは十分すごいけどね！" userName="mras0" createdAt="2025-04-23T18:30:44" color="">}}

{{<matomeQuote body="それって別の契約を作るってことにならない？ユーザーがそれがランダムであることを前提にコードを書くかもしれないじゃん。" userName="plutaniano" createdAt="2025-04-23T20:01:40" color="">}}

{{<matomeQuote body="Perl 5.8の1mloc弱のコードをPerl 5.32(くらい)で動くようにアップデートしたことがあるんだけど、意外と問題は少なかったんだよね。その問題の一つがまさにこれで、ハッシュのイテレーション順序が定義されてないってこと。Perl 5.8では挿入順序が同じならイテレーション順序も同じだったけど、後のバージョンでは意図的にランダム化されたんだ。<br>予測可能なハッシュキーのイテレーション順序を前提にしてるところがいくつかあって、テストが50%の確率で失敗してた。エラーを見つけるのがどれだけ面倒かっていうのは、テストでエラーが出る頻度と反比例するってことだね。(Perl 5はコミュニティに見捨てられてて、CPANモジュールが消えたり、古すぎて他のモジュールと連携できなくなったりって問題もあったけど)" userName="codebje" createdAt="2025-04-24T02:01:07" color="#38d3d3">}}

{{<matomeQuote body="booking.comでの話？" userName="zerr" createdAt="2025-04-24T10:21:48" color="">}}

{{<matomeQuote body="確か、Goは意図的にmapの順序をランダムにしてるんだよね。まさに同じ理由で。" userName="roseway4" createdAt="2025-04-23T18:13:47" color="">}}

{{<matomeQuote body="そうそう。で、再現できないクラッシュレポートが上がってくるんだ。" userName="withinboredom" createdAt="2025-04-23T19:06:08" color="">}}

{{<matomeQuote body="＞コンパイルの警告を無視しないこと–このコードは、元のコードで警告を発していた可能性が高く、無視または無効にされていました！<br>どんなコンパイラエラーを期待する？scanfからの戻り値をチェックしてパラメータの数と一致することを確認しないとか？そうでなければ、これはコンパイラが手がかりを持たないデータファイルエラーのように思えます。" userName="jandrese" createdAt="2025-04-23T16:53:34" color="">}}

{{<matomeQuote body="g++ version 11.4で試したけど、sscanfの戻り値をチェックしなくてもデフォルトでは警告は出ないね。`g++ -Wall -Wextra -Wunused-result`でも小さい例では警告は出ない。" userName="kristianp" createdAt="2025-04-24T00:35:33" color="">}}

{{<matomeQuote body="初期化されていないメモリにアクセスするのは未定義動作だよね。サニタイザーならそれを検出できたはず。" userName="burch45" createdAt="2025-04-23T18:22:00" color="#785bff">}}

{{<matomeQuote body="コンパイラはメモリが未定義かどうかを知ることはできないよ。データファイルを検証できない限りね。せいぜい、scanfの戻り値をチェックしてないことを警告するくらいだろうけど、それも違うかも。ファイルの終端をチェックしてる可能性もあるし。一致したパラメータの数をチェックしてなかったんだよ。scanfのセマンティクスを考えると見逃しやすいエラーだよね。" userName="jandrese" createdAt="2025-04-23T18:31:15" color="#45d325">}}

{{<matomeQuote body="コンパイラがメモリ未定義だってわかるはずないって？そんなことないよ！`-fsanitize=address`ってオプションは色々やってくれるんだ。シャドウメモリってのを確保して、メインメモリの定義状態を記録して、読み書きするアドレスを全部チェックするんだって。コンパイル時と実行時のチェックの組み合わせなんだね。もちろん重いから、デバッグ用でリリースには使わない方がいいね。<br>＞https://clang.llvm.org/docs/AddressSanitizer.html”<br>＞https://learn.microsoft.com/en-us/cpp/sanitizers/asan?view=m…”" userName="nayuki" createdAt="2025-04-23T19:44:20" color="">}}

{{<matomeQuote body="clang ASANで試したけど何も起きなかったよ。このバグは検出できないみたい。ASANは間違った挙動は検出するけど、正しい挙動がないのは検出できないんだ。<br>use-after-freeとかuse-after-returnとかOOBアクセスとかじゃないしね。これは「確保されたスタック変数が実行時に初期化されずに読まれる」ってケースで、標準的なanalyzerじゃ無理だと思う。<br>一番いいのは、ローカル変数は全部初期化するってポリシーにするか(ゲームスタジオじゃ無理だろうけど)、`-ftrivial-auto-var-init=pattern`みたいなスタック初期化を有効にしてデバッグすることかな。QAですぐ見つかると思う。" userName="bri3d" createdAt="2025-04-23T21:43:57" color="#785bff">}}


{{< /details >}}
{{< details summary="もっとコメントを表示（3）">}}
{{<matomeQuote body="調査ありがとう。MSan(memory sanitizer)が未初期化リードを検出するのに適したツールみたいだね。<br>＞https://stackoverflow.com/questions/68576464/clang-sanitizer… “<br>自分はUBSanとASanしか使わないから、他の人のコードの監査は知識不足かも。CとC++より新しい言語は、こういう設計ミスを繰り返してないし、後から導入された変なsanitizerツールも必要ないんだよね。" userName="nayuki" createdAt="2025-04-23T21:54:25" color="#45d325">}}

{{<matomeQuote body="どっちも正しいかもね。ASANがscanfとかの標準ライブラリ関数をinstrumentしてないのかも。でも2015年からはやってるはず。<br>＞https://github.com/google/sanitizers/issues/108 “<br>「ローカル変数は宣言時に初期化されてないといけない」ってルールでも、当時のツールで検出できたと思う(ちょっと強引だけど)。" userName="hoten" createdAt="2025-04-23T20:49:22" color="">}}

{{<matomeQuote body="問題は、scanf()の後に定義される変数の数が可変だってこと。<br>例えば:<br>int x, y, z;<br>int n = scanf(”%d %d %d”, &x, &y, &z);<br>コンパイル時には、x, y, zのどれが定義されてるか推論できないんだ。nの値によるから。<br>解決策は色々あるけど、確実に代入するとか、複数の戻り値を許すとか(Pythonみたいに)かな。Javaみたいにスカラーしか返せないのはプログラマーにはつらいけどね。" userName="nayuki" createdAt="2025-04-23T21:30:49" color="">}}

{{<matomeQuote body="「ローカル変数は宣言時に初期化されてないといけない」ってことは、<br>int n = scanf(”%d %d %d”, &x, &y, &z);<br>って呼び出しが引っかかるってことだよね。許可するには、事前に変数を初期化する必要がある。" userName="twic" createdAt="2025-04-23T23:53:18" color="">}}

{{<matomeQuote body="初期化のコストが高いケースのために、unsafeなインスタンス化を許可するキーワードがあってもいいと思う。でも、基本的には安全な方がいいよね。" userName="da_chicken" createdAt="2025-04-24T10:07:05" color="">}}

{{<matomeQuote body="ASANがscanfを置き換えて、実行時に入力が指示する任意のメモリアドレスへの書き込み時に追加のブックキーピングをするってことじゃない？<br>リンクしたPRで解決された問題はそれだと思うけど、確認してないや。" userName="hoten" createdAt="2025-04-23T23:27:47" color="">}}

{{<matomeQuote body="初期化されてない変数って、マジでよくあるよねー。" userName="andrewmcwatters" createdAt="2025-04-23T18:32:36" color="">}}

{{<matomeQuote body="初期化されてない変数のポインタがscanfに渡されて、エラーがなければそこに値が書き込まれるってわけか。コンパイラはscanfの宣言だけじゃ、この挙動を理解できないんだね。" userName="gmueckl" createdAt="2025-04-23T20:34:54" color="#ff33a1">}}

{{<matomeQuote body="デバッグはすごいけど、原因は意外と軽微なんだな。" userName="andrewmcwatters" createdAt="2025-04-23T18:31:52" color="">}}

{{<matomeQuote body="なるほどねー。読んでるときは、初期化されてないメモリの使用に対する警告が拾うと思ってたわ。<br>でも、一行全体がsscanfで解析されるから、コンパイラの静的解析は初期化されたと仮定せざるを得ないんだ。これ catching できるような一般的な静的解析のアプローチってなさそうだね。<br>scanf専用の警告を作って、初期化済みの値を渡すか、戻り値を確認するように強制するとか？" userName="phire" createdAt="2025-04-23T22:49:43" color="#45d325">}}

{{<matomeQuote body="こういう技術的な記事読むの、マジで好き。AI時代になったら、もっと減っちゃうのかなー。" userName="maz1b" createdAt="2025-04-23T14:57:46" color="">}}

{{<matomeQuote body="そんなに減るとは思わないなー。常にトップレベルのエンジニアはディープダイブするでしょ。そう願いたいわ。<br>AIも過去50年以上のソフトウェア開発のイノベーションも、彼らをreplace しないと思う。スタックとヒープの違いを知らない開発者なんていっぱいいるし、気にしてない人もいるし。" userName="Cthulhu_" createdAt="2025-04-23T19:58:59" color="#ff5c5c">}}

{{<matomeQuote body="もしキャリア全体がスタックにほとんどデータを保存しない高水準言語を使うことばかりなら、プログラマが気にする必要ある？ツールの抽象化が進むのは普通のことじゃん。C/C++をたくさん書いたけど、アセンブリ言語なんて一度も必要なかったし。" userName="throwaway2037" createdAt="2025-04-24T03:29:31" color="">}}

{{<matomeQuote body="一般的なソフトウェアエンジニアは職人からtrademensに変わると思うけど、この記事みたいなのは職人芸の極みだよね。" userName="senda" createdAt="2025-04-23T15:12:47" color="">}}

{{<matomeQuote body="3ヶ月のブートキャンプ卒業の”ソフトウェアエンジニア”をよく見かけるようになったよね。CRUDアプリ作って50万ドル稼ぐのはもう無理かもね。" userName="eduardofcgo" createdAt="2025-04-23T15:56:58" color="">}}

{{<matomeQuote body="それって良いことじゃん" userName="sitzkrieg" createdAt="2025-04-23T20:22:52" color="">}}

{{<matomeQuote body="マジかよ。3ヶ月のブートキャンプ卒業生がCRUDアプリ書いて50万ドルも稼げるわけないだろ。ありえねー" userName="throwaway2037" createdAt="2025-04-24T03:32:28" color="">}}

{{<matomeQuote body="JS/CSS/HTMLしか知らなくても、フロントエンドの開発者だってすごい奴いるじゃん。クロスブラウザとかプラットフォームの問題とか、パフォーマンスの調整とかで職人技を発揮できるし。" userName="throwaway2037" createdAt="2025-04-24T03:31:20" color="#ff5733">}}

{{<matomeQuote body="今のPythonのデベロッパーと60年代のFortranのデベロッパーを比べてみろよ。それくらいの距離感だろ。もっとかもな。でも、この流れは今に始まったことじゃない。" userName="nonethewiser" createdAt="2025-04-24T02:09:13" color="">}}

{{<matomeQuote body="Windowsのこのバージョンで、クリティカルセクションのロック/アンロックの実装がどう変わったのか、そっちの方が気になるわ！" userName="adzm" createdAt="2025-04-23T15:02:59" color="#ff5733">}}


{{< /details >}}


[記事一覧へ]({{% ref "/posts/" %}})
