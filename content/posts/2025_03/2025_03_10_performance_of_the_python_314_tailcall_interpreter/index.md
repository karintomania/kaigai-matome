+++
date = '2025-03-10T00:00:00'
months = '2025/03'
draft = false
title = 'Python 3.14のテールコールインタープリターのパフォーマンスは本当によかったのか？'
tags = ["パフォーマンス", "Python", "テールコール", "プログラミング", "ベンチマーク"]
featureimage = 'thumbnails/cyan3.jpg'
+++

> Python 3.14のテールコールインタープリターのパフォーマンスは本当によかったのか？

引用元：[https://news.ycombinator.com/item?id=43317592](https://news.ycombinator.com/item?id=43317592)

{{<matomeQuote body="こんにちは！私はCPythonにおけるテールコールインタープリタのPRの作者です。まず最初に、これを解決するために約1ヶ月をかけたNelsonに感謝したいです。それから、私が大きな見落としをしてしまったことに対して、非常に恥ずかしく思っており謝りたいです。私もCPythonチームも、ベースラインで使っていたコンパイラがそのバグを持っているとは予想していませんでした。謝罪のブログを投稿しました。" userName="kenjin4096" createdAt="2025-03-10T11:42:19" color="#45d325">}}

{{<matomeQuote body="あなたがそんなエラーバグを見落としたことに恥じ入っていると聞いて、CPythonのパフォーマンスを悪化させたのかと想像していました。ですが、全然違いましたね。10～15％のパフォーマンス向上を発表しましたが、それは実際にはバグのないコンパイラでの1～5％の向上に過ぎなかった。あなたは勉強して改善し、PRも他の人にレビューされているのに、その数値が誤解を招くようなものだったのは不運です。誰もが合理的に犯す可能性のある間違いのように思えます。" userName="jraph" createdAt="2025-03-10T12:40:31" color="#38d3d3">}}

{{<matomeQuote body="そのバグを間接的に修正することで、間違ったコンパイラを使っていた全員に約10％のパフォーマンス向上をもたらしました！それは多くの人が知らないようなオプションフラグよりも素晴らしいことです。" userName="ehsankia" createdAt="2025-03-10T16:54:00" color="#ff5c5c">}}

{{<matomeQuote body="そのパフォーマンスの退化は、同じ計算済みのgotosを持つ非常に多くのパスを使用しているコードにのみ影響しました。それは比較的複雑なインタープリタだけが影響を受ける可能性が高いです。ですから、広範囲にわたるパフォーマンスの向上というわけではありません。しかし、コンパイラの新しいヒューリスティックが失敗した例を持つのは興味深いです。" userName="chowells" createdAt="2025-03-10T18:50:41" color="">}}

{{<matomeQuote body="今、確かにその影響を受けているのは、そのコンパイラでビルドされたPythonを使っている全員を含んでいます。" userName="ncruces" createdAt="2025-03-10T20:35:30" color="">}}

{{<matomeQuote body="あなたは宿題をやったと思う。改善を行い、10～15％のパフォーマンスの向上を測定し、PRは他の人にもレビューされている。しかし、その10～15％の数値が誤解を招くのは、あなたが使ったclangのバージョンに問題があったからです。間違いがあったとしても、不幸な間違いのようです。" userName="rtollert" createdAt="2025-03-10T22:19:34" color="#38d3d3">}}

{{<matomeQuote body="確かにそうかもしれません！面白いですね、Gettier問題を知らなかったので教えてくれてありがとう。そのページをHNの投稿として提出してみてはどうですか？" userName="jraph" createdAt="2025-03-11T05:51:01" color="#785bff">}}

{{<matomeQuote body="ちなみに、あなたがそのブログを投稿した後、修正はマージされましたよ。加えて、古いPythonインタープリタにとって3～5％の向上は大きなことです。非常に誇らしく思いますよ。30年も経つと、性能改善に懐疑的になることを学びました。明らかに得られることもあるけど、そう頻繁ではありません。" userName="DannyBee" createdAt="2025-03-10T12:50:48" color="#ff5733">}}

{{<matomeQuote body="30年も経てば、長い間パフォーマンスが重視されるシステムにおける重要なパフォーマンス向上には懐疑的になる。" userName="theLiminator" createdAt="2025-03-10T16:29:06" color="">}}

{{<matomeQuote body="もちろん、私も長い間パフォーマンスが重要だったシステムへの大きな改善には懐疑的です。" userName="DannyBee" createdAt="2025-03-10T16:55:15" color="">}}

{{<matomeQuote body="0.5％の改善なら信じるし、10000％の改善も信じるけど、10％は怪しいな。" userName="colechristensen" createdAt="2025-03-10T17:09:16" color="">}}

{{<matomeQuote body="テイルコールインタープリタのデザインの主な目的は、オプティマイザの影響を受けにくくするためだよ。具体的には、オプティマイザが重要な変数をレジスタに保持させないとか、同じコードパスを合併させちゃって最悪の性能になることがあるんだ。それに比べてテイルコールインタープリタは、欲しい機械コードのパターンをインタープリタ内で表現できるから、オプティマイザに頼る必要が減るんだ。だから、パフォーマンスの改善は3-5％以上にもなると思う。" userName="haberman" createdAt="2025-03-10T16:51:22" color="#785bff">}}

{{<matomeQuote body="これは良いポイントだね。LTOとPGOを使ったビルドでこれを観察したよ。最近のコンパイラだと各LTO+PGOビルドが1-2％もパフォーマンスに変動があるんだ。テイルコールインタープリタがあればこの影響を受けないかもしれないね。" userName="kenjin4096" createdAt="2025-03-11T03:04:15" color="#785bff">}}

{{<matomeQuote body="その通りだと思う。さまざまなコンパイラ構成に対してパフォーマンスが安定しているというのは大きな価値があるよ。" userName="sunshowers" createdAt="2025-03-10T17:58:47" color="#785bff">}}

{{<matomeQuote body="自分のミスを素直に謝れるのは素晴らしいと思う。今の世の中、そういうことが難しいからね。" userName="jxjnskkzxxhx" createdAt="2025-03-10T11:50:00" color="">}}

{{<matomeQuote body="フラストレーションは理解するけど、そういう言い方は必要なかった気がする。ニュースが世の中の人々の見方に影響を与えないようにしたいよね。" userName="kzrdude" createdAt="2025-03-10T12:12:02" color="">}}

{{<matomeQuote body="分断と征服が進んでる。私たちはお互いを憎んで、国家やエリート、技術を信じることが予定されてるんだ。真の犯罪者はその計画の設計者たちだよ。" userName="codr7" createdAt="2025-03-10T19:22:12" color="">}}

{{<matomeQuote body="このベースラインパフォーマンスの劣化が、速いCPythonのベンチマークページに出なかったのはどうしてだろう？同じような問題を今後防ぐためにベンチマークを改善できるかも。" userName="ptx" createdAt="2025-03-10T11:57:10" color="">}}

{{<matomeQuote body="普通よりは良いベンチマークページだね。ただ、IntelとARMのCPUだけでテストしたのが気になる。もっと多様なCPUが必要だと思う。" userName="cb321" createdAt="2025-03-10T12:23:47" color="">}}

{{<matomeQuote body="最近のコンパイラを使ったベンチマークは過去のデータと比べられなくなるから通常はやらないんだよね。Clang 19は昨年リリースされたけど、ベンチマークは数ヶ月前にやったもので、macOSでの明らかな遅延を確認したよ。でもこれはXcode Clangに対するもので、違うコンパイラだから深く調べなかった。今思えば後悔してるけど。結局Clang 19と18の比較ベンチマークはしてなくて、他のコンパイラとの比較のみだったから、コンパイラの違いだと考えていたよ。" userName="kenjin4096" createdAt="2025-03-10T12:09:34" color="">}}

{{< details summary="もっとコメントを表示（1）">}}
{{<matomeQuote body="それは良い質問だね。ブログの記事によると1～5％のパフォーマンス改善があるみたいで、CPythonには大きいと思う。ソースも複雑にはならないし、自動生成されたコードなので、メンテナンスのためには今後もこの改善を維持すべきだと思う。バイトコードが小さい関数であれば、デバッグも楽だし。パフォーマンスと生産性の面で価値があると思うよ。" userName="kenjin4096" createdAt="2025-03-10T12:12:45" color="#ff5c5c">}}

{{<matomeQuote body="壊れやすいコンパイラの最適化に対して強固になるのも重要な利点だよ。インタープリタのループは特殊なコードで、コンパイラのヒューリスティックに任せるには気を付けるべきだと思う。望ましい呼び出し構造がポータブルに達成できるなら、それは勝利だね。" userName="ot" createdAt="2025-03-10T15:41:59" color="#ff33a1">}}

{{<matomeQuote body="2022年に全体で5倍のスピードアップを目指す計画があったんだ。その後GuidoとチームがCPythonを大幅に速くする発表をしたんだけど、実際に2倍のスピードアップは見られたのか？それともせいぜい0.2倍とか？インタープリタの変更を否定するつもりはないけど、そのスピードアップの計画が実現可能だったのか、1/5も達成できるのか知りたい。" userName="coldtea" createdAt="2025-03-10T13:19:30" color="">}}

{{<matomeQuote body="Faster CPythonプロジェクトは3.10を基準にして5倍を目指してるんだ。CPython 3.13は3.10よりも1.6倍速くなって、JITを有効にするとさらに若干速くなる。3.14の変更で1.8倍のスピードアップになるのが予想されてる。進展はあると思うけど、JITの最適化が進むことでまだもっと速くなる余地があると思うよ。" userName="chippiewill" createdAt="2025-03-10T15:11:23" color="">}}

{{<matomeQuote body="そのプロジェクトから多くのスピードアップが実現されてきたよ。一度にすべてが行われるわけじゃなく、過去のリリースに分散しているから、個々のスピードアップは地味に見えるかもしれないけど、累積しているのを忘れないで。" userName="Twirrim" createdAt="2025-03-10T14:15:04" color="">}}

{{<matomeQuote body="ここでの詳細はここにある：<https://github.com/markshannon/faster-cpython/blob/master/pl...>著者について：<https://us.pycon.org/2023/speaker/profile/81/index.html>　＞彼の学術的および商業的な仕事は、Pythonのためのコンパイラ、仮想マシン、静的解析に焦点を当てている。彼の博士号は動的言語のための仮想マシンの構築に関するものだよ。わけて言うと、彼は神レベルだね。冗談半分だけど、MSFTもGoogle V8のLars Bakをスカウトできるかも。" userName="throwaway2037" createdAt="2025-03-11T05:11:11" color="">}}

{{<matomeQuote body="Pythonの発展を推し進めるために素晴らしい仕事をしてるよ。みんなの努力に感謝してる！" userName="robertlagrant" createdAt="2025-03-10T13:25:30" color="#ff5c5c">}}

{{<matomeQuote body="この問題の対処が非常に良い形で行われたね！間違いを修正するためにここまで気を使ってくれて感謝してる。Pythonの開発者たち全員に感謝し、尊敬しているよ！" userName="pseufaux" createdAt="2025-03-10T11:57:35" color="#45d325">}}

{{<matomeQuote body="Pythonを改善するための努力に感謝。特に、明確で目立つ形で記録を正す手伝いをしてくれてありがとう。一部のコメントは「謝る必要はない」と言ってるけど、これは「高い基準を求めなくていい」って読み取れる。つまり、僕は反対だ。責任感や知的誠実さが軽視されている現在、結果を報告する前にもっと調査すべきだったと言えることは、高い基準を持つということだと思う。もう一つの見方は「気にする必要はない」というもので、これは賛成。多くの場合、自分の仕事を十分に挑戦できていないことがある。これは誰にでもあることだよね。" userName="nickm12" createdAt="2025-03-11T03:09:34" color="#ff5c5c">}}

{{<matomeQuote body="＞「責任感や知的誠実さが軽視されている」<br>HNでのこのようなネガティブな発言に疲れた。僕の人生では、常に人々が「責任感や知的誠実さが軽視されている」と文句を言っている。地方ニュースのインタビューと同じレベルだ。「最近の交通はどう？」。「悪化している」。いつの時代に責任感や知的誠実さが「正しく」評価されていたんだい？" userName="throwaway2037" createdAt="2025-03-11T04:58:26" color="">}}

{{<matomeQuote body="うん、あまり気にしないで。君の失敗が公開されただけで運が悪かっただけだよ。皆、プライベートで同じような失敗やってるし。Pythonの最適化について知ってる人なら、数パーセントのスピード改善でも驚くよ。それは多くのGWhの電力を節約することにもつながるし、数パーセントでもすごいことだよ！君は新しいアカウントで、ブログもまだ一つの記事だけみたいだから新しい開発者かな？でも、すごくいい仕事してるから頑張って！" userName="ok_dad" createdAt="2025-03-10T22:54:50" color="#45d325">}}

{{<matomeQuote body="Pythonをより良くするための仕事をしてくれてありがとう。" userName="rbetts" createdAt="2025-03-10T13:13:48" color="">}}

{{<matomeQuote body="5％の変更があったとしても、すごく素晴らしい仕事として見られると思うよ。誠実な間違いに対処する姿勢には感謝してるし、Pythonコミュニティへの努力も敬意を表するよ。" userName="acdha" createdAt="2025-03-10T12:43:27" color="">}}

{{<matomeQuote body="恥じたり謝ったりする必要はないよ。パフォーマンスが向上したんだから。短期的には知らなかったバグを回避したし、長期的にはバグが修正されても向上はある。ソフトウェア開発は抽象に依存するしかないし、すべてを正確に知るのは難しい。スマートな人々は何かを作り、他のスマートな人々は問題を見つける。何も壊れてないよ。" userName="SmellTheGlove" createdAt="2025-03-10T17:24:53" color="#ff33a1">}}

{{<matomeQuote body="謝る必要なんてないよ。どんな結果でも君は素晴らしい仕事をしたんだから。" userName="sundbry" createdAt="2025-03-10T16:52:18" color="">}}

{{<matomeQuote body="依然としてパフォーマンス改善があったし、Pythonの規模で考えると全球的な電力節約につながると思うよ！" userName="tiagod" createdAt="2025-03-10T13:26:35" color="#ff5c5c">}}

{{<matomeQuote body="長い心からの謝罪は不要だ。一言「くそっ」が十分だ。間違いはない、ただ運が悪かっただけだ。もっと慎重になることで運を改善できるけど、過度に気を使うことで試すこともできなくなるから、君のスタイルを続けてほしいな。" userName="immibis" createdAt="2025-03-10T17:05:25" color="">}}

{{<matomeQuote body="この見落としを気にする人はいない。もっと重要なのは、君が僕たちのために開発に時間を使ってくれることだ。ありがとう。" userName="Vaslo" createdAt="2025-03-11T14:39:03" color="">}}

{{<matomeQuote body="ベンチマークってホントやるの難しいよね。多くの要因が誤解を生むことがあるし。最近、アルゴリズムを１５％速くする方法を見つけたんだけど、実行してない方が速くなるってどういうこと！？要するに、コードやメモリ配置の問題で、CPUキャッシュとの相性が良くなったかな。スピードアップが本当にコードの改善によるのか、いい偶然だったのか分からないし。Casey Muratoriのシリーズがこの辺りをよく説明してるよ。" userName="MattPalmer1086" createdAt="2025-03-10T08:28:38" color="#45d325">}}

{{<matomeQuote body="そのリンカーの運が１５％も改善したのは驚きだね。どういうケースでそんな大きな改善が出るんだろ？それが珍しいのか、どうやって気づいたのか教えて。" userName="porridgeraisin" createdAt="2025-03-10T09:44:52" color="">}}


{{< /details >}}
{{< details summary="もっとコメントを表示（2）">}}
{{<matomeQuote body="いろんな研究が、この手の誤差が１５％以上になることを示してるよ。そんなに珍しくないし、結構遭遇する。コンパイラーやリンカーは頑張ってるけど、現代のCPU自体がすごく複雑だからね。Casey MuratoriのシリーズがCPUレベルでのことを分かりやすく解説してくれている。" userName="MattPalmer1086" createdAt="2025-03-10T09:56:51" color="#ff5c5c">}}

{{<matomeQuote body="追加の背景だけど、特定の探索アルゴリズムのためにベンチマークツールを書いてたんだ。ノイズを減らすためにかなり手間かけたし、CPUピンニングや何度もテストして、同じデータで一番良いスコアを取るようにした。でも、ツール自体は再現性があったんだけど、どのアルゴリズムが良いかの正確さは信頼できなかったから、結局そのプロジェクトはあきらめたよ。" userName="MattPalmer1086" createdAt="2025-03-10T12:38:51" color="">}}

{{<matomeQuote body="コンパイラーの決定を意図的にランダム化して、コードの本当のパフォーマンスを安定させるためのベンチマークプロジェクトのことをぼんやり覚えてる。" userName="eru" createdAt="2025-03-10T08:45:33" color="">}}

{{<matomeQuote body="それはEmery Bergerの「Performance Matters」っていうStrange Loopsのトークのことだと思うよ。https://youtube.com/watch?v=r-TLSBdHe1A" userName="Mond_" createdAt="2025-03-10T08:52:56" color="">}}

{{<matomeQuote body="類似のことをしてたStabilizerってのがあったけど、今はメンテされてなくて、最新のLLVMには対応してない。もっと新しいやつが出てるはずだけど、名前は忘れた。" userName="MattPalmer1086" createdAt="2025-03-10T08:55:20" color="">}}

{{<matomeQuote body="Emery BergerのCozプロファイラーについても。これなら、どの関数を変えれば望むレイテンシーやスループットが得られるか、良い推定ができる。" userName="FridgeSeal" createdAt="2025-03-10T09:59:04" color="#38d3d3">}}

{{<matomeQuote body="LLDにはこれを目的とした新しいオプション「--randomize-section-padding」があるよ。https://github.com/llvm/llvm-project/pull/117653" userName="McP" createdAt="2025-03-10T16:15:00" color="">}}

{{<matomeQuote body="面白いね、ありがとう！" userName="MattPalmer1086" createdAt="2025-03-10T16:33:17" color="">}}

{{<matomeQuote body="なんか明らかにおかしいことしてないのに、間違ったデータが出てきた！" userName="igouy" createdAt="2025-03-10T17:23:28" color="">}}

{{<matomeQuote body="なんか明らかにおかしいことしてないのに、間違ったデータが出てきた！" userName="igouy" createdAt="2025-03-10T20:14:12" color="">}}

{{<matomeQuote body="これは多分Emery Bergerのプロジェクトで、プログラムの異なる部分を意図的に遅くして、どの部分がパフォーマンスに影響が大きいかを探ってるんだろうね。" userName="alpaca128" createdAt="2025-03-10T09:42:10" color="#45d325">}}

{{<matomeQuote body="Aleksey Shipilёvっていう長年のJavaのパフォーマンスエンジニアがベンチマークの大変さについてたくさん書いてるから、ブログやトークをぜひ見てみて！" userName="throwaway2037" createdAt="2025-03-11T05:15:33" color="">}}

{{<matomeQuote body="著者にはほんとに感謝！今回の話はPython 3.14のテールコールインタプリタの改善についての貴重な教訓を示してくれたね。パフォーマンスの主張を全て再考させるきっかけになったし、他にも検証も必要だな。" userName="jeeybee" createdAt="2025-03-10T07:31:31" color="#38d3d3">}}

{{<matomeQuote body="10％のパフォーマンス低下がどうして見つからなかったのか大きな疑問だな。コンパイラ自体のベンチマークはやってないの？" userName="ehsankia" createdAt="2025-03-10T16:58:22" color="#38d3d3">}}

{{<matomeQuote body="LLVMがCPythonで大きなパフォーマンスの低下を引き起こして、なんで誰も気づかなかったのかが驚きだね。" userName="twoodfin" createdAt="2025-03-11T00:03:02" color="#ff33a1">}}

{{<matomeQuote body="公式のCPythonバイナリはGCCで作ってるから、Clang 18や19でビルドしないとスピードの違いに気づかないかも。だから誰も気付かなかったのかも。" userName="ltfish" createdAt="2025-03-11T04:57:50" color="">}}

{{<matomeQuote body="Cが機械に近いとかポータブルアセンブリじゃないってすごくわかる例だね。意図した最適化とは逆の結果が出ることがあるんだよね。" userName="kryptiskt" createdAt="2025-03-10T08:23:55" color="">}}

{{<matomeQuote body="”Cはポータブルアセンブリ”というのは、基本的に他のシステムプログラミング言語から見るとそうなんだよ。Cの表現である’a += 1’は数値を正しくインクリメントするけど、C++だとメモリを割り当てたりスタックが巻き戻ったりするかもしれない。”Cはポータブルアセンブリ”って言葉は、各文が必ずしも同じ機械コードに変換されるという意味ではないよ。" userName="jmillikin" createdAt="2025-03-10T08:41:49" color="#ff5733">}}

{{<matomeQuote body="コードがclangやgccのIRに来ると、その時点で’a’は存在しないんだよ。SSA形式は変化しないから、新しい変数に割り当てられるんだ。1のインクリメントがあるかどうかもわからないし、加算がまとめられてしまうかもしれないし、場合によっては16のチャンクで処理されて、最後のチャンクで調整が必要ってこともあるんだ。" userName="kryptiskt" createdAt="2025-03-10T09:32:02" color="">}}

{{<matomeQuote body="高レベルの学術的な見解では、コンパイラは合法的な変換を行うことができるんだけど、実際のCコンパイラは出力する内容について結構保守的なんだ。-march=なしでコンパイルした場合ね。中程度に複雑なオープンソースのCライブラリを見つけて、それをコンパイルしてHexraysやGhidraやradare2でその結果を見れば、元のソースと比較してあんまりマジックはないってわかると思うよ。" userName="jmillikin" createdAt="2025-03-10T10:04:22" color="">}}


{{< /details >}}
{{< details summary="もっとコメントを表示（3）">}}
{{<matomeQuote body="-O3はオートベクタライゼーションを行うんだ。ループをSIMD命令に変換したりして、時にはパフォーマンスプロファイルが大きく変わったりもするんだよ。オートベクタライゼーションが”あんまりマジックじゃない”なら、他に何がマジックなんだろうね。" userName="hun3" createdAt="2025-03-10T10:27:52" color="">}}

{{<matomeQuote body="”Cはポータブルアセンブリ”って言葉は、各文が必ずしも同じ機械コードに変換されるという意味ではないんだよ。ウィーゼルワードってやつだね。自動運転車の話をしてるみたいで、運転手が常に注意を払ってなきゃいけないみたいなものさ。Cを勧める人は、特定の機械的な結果を達成できると思っている様子があるけど、そんな時もあればそうでない時もある。" userName="pjc50" createdAt="2025-03-10T10:13:41" color="#ff33a1">}}

{{<matomeQuote body="一般的に、技術的な議論をしているときに、すべての参加者が特定の表現を使っていて、あなたが理解できない時は、少し確認するべきだよ。例えば、Cが”ポータブルアセンブリ”かどうかの話の中で、アセンブリプログラミング時代を思い出してしまうかもしれない。Cはマクロや制限された環境で書くことができるけど、実はそこ、本当に話題になっていることではないんだよ。" userName="jmillikin" createdAt="2025-03-10T11:20:18" color="">}}

{{<matomeQuote body="”Cの’a += 1’は数値を確実にインクリメントする”って言ってるけど、未定義の動作を知らないの？" userName="eru" createdAt="2025-03-10T08:46:34" color="">}}

{{<matomeQuote body="もしこのコードを誤ってコンパイルするCコンパイラがいるなら、僕のポイントを認めるよ：uint32_t add_1(uint32_t a) { a += 1; return a; }。" userName="jmillikin" createdAt="2025-03-10T08:56:33" color="">}}

{{<matomeQuote body="Cは他のシステム言語から見ると低レベルだけど、現代の宇宙船に対してApollo 11がシンプルとは言えないようなものだよ。Cのコードは実行されるものとはあんまり近くない。例えば、たいていのコンパイラは以下のコードの’a’をインクリメントしない可能性が高いんだ。uint32_t add_and_subtract_1(uint32_t a) { a += 1; a -= 1; return a; }。" userName="WJW" createdAt="2025-03-10T09:46:17" color="">}}

{{<matomeQuote body="もしコンパイラに自分のコードをリテラルなポータブルアセンブリとして扱わせたければ、最適化をオフにすることだよ。" userName="mkoubaa" createdAt="2025-03-10T12:07:00" color="">}}

{{<matomeQuote body="なんで同じ変数から１を減らしたら、１を増やすの？無駄なサイクルじゃない？って思うよ。良いコンパイラならこれを最適化できると思うし、何か誤解があるかな？" userName="johnisgood" createdAt="2025-03-10T12:00:35" color="">}}

{{<matomeQuote body="たぶんあれはCがアセンブリに近いってコメに対する直接の返信だと思う。便利かどうかは関係ないけど、動作が正確じゃないってことだね。" userName="vikramkr" createdAt="2025-03-10T12:57:03" color="">}}

{{<matomeQuote body="Cが「ポータブルアセンブリ」って言われるのは、単に個々のソース式から決定論的なマシンコードが生成されるわけじゃないってことを強調したいんだ。他の言語の例もあるし、コンパイラの出力はもっと複雑なことがあるよ。" userName="jmillikin" createdAt="2025-03-10T13:25:24" color="">}}

{{<matomeQuote body="こちらは、全角リンクを貼っとくね：＜https://godbolt.org/z/r39jK1ddv＞。-O0だと、まずインクリメントしてからデクリメントするよ。だから特に問題はないと思うんだ。" userName="johnisgood" createdAt="2025-03-10T13:40:20" color="">}}

{{<matomeQuote body="C標準は変わらない動作を保証してるんだ。それが標準の目的だよ。ただし、特定のアセンブリ命令が使用されることを保証はしていないね。" userName="eru" createdAt="2025-03-12T12:59:06" color="">}}

{{<matomeQuote body="それはちょっと分かりにくい例だけど、重要なプログラムではその間にコードがあったり間接的な参照があることが多いんだ。だからコンパイルされたコードを見ても、ソースコードと直接の対応があるとは限らない。コンパイラの仕組みを理解して、ハードウェアやアプリケーションの知識も必要なんだ。" userName="acdha" createdAt="2025-03-10T12:51:46" color="#38d3d3">}}

{{<matomeQuote body="コンパイラがインクリメントは当然やるだろうけど、デクリメントはしないし、古い値を使うのが普通だよね。" userName="remexre" createdAt="2025-03-11T04:18:24" color="">}}

{{<matomeQuote body="Cの例を一つ挙げただけじゃ全然弱いよ。もっと興味深い状況を提示しないと。C++でもこのテストは通る。" userName="tux3" createdAt="2025-03-10T09:24:49" color="">}}

{{<matomeQuote body="’a += 1’に未定義動作があると示したけど、CやC++に問題があるのは承知さ。で、インターネットにはたくさんの無名整数足し算の例があるよ。" userName="jmillikin" createdAt="2025-03-10T10:15:39" color="">}}

{{<matomeQuote body="’int a’で’a += 1’が驚く結果をもたらすことは分かってる。C++でも同じように信頼できそう。" userName="eru" createdAt="2025-03-10T09:14:27" color="">}}

{{<matomeQuote body="Cは演算子オーバーロードが無いから、`a += 1`ってのは数値を1増やすって理解しやすいんだ。C++だとそれが難しくなる。" userName="jmillikin" createdAt="2025-03-10T09:40:58" color="#ff33a1">}}

{{<matomeQuote body="CやC++の問題は山ほどあるけど、最適化がセキュリティチェックを省略しちゃうことには困るよね。" userName="MaulingMonkey" createdAt="2025-03-10T10:34:39" color="">}}

{{<matomeQuote body="だから『a += 1』が数値を1増やすと理解しやすいってのは間違いで、元のソースと機械語のマッピングが難しいってことだよ。別の例もあるから見てみて。" userName="gpderetta" createdAt="2025-03-10T12:39:30" color="">}}


{{< /details >}}


[記事一覧へ]({{% ref "/posts/" %}})
