+++
date = '2025-05-22T00:00:00'
months = '2025/05'
draft = false
title = 'Gemini Diffusion！'
tags = ["AI", "機械学習", "深層学習", "拡散モデル", "生成モデル"]
featureimage = 'thumbnails/orange2.jpg'
+++

> Gemini Diffusion！

引用元：[https://news.ycombinator.com/item?id=44057820](https://news.ycombinator.com/item?id=44057820)




{{<matomeQuote body="正直Googleの仕組みは全然わかんないけど、最近RWKVの人たちが似たこと（attentionをWKVっていう一方通行の線形attentionに置き換えて、ちょっと後から学習）やってたから、たぶんそれじゃないかな。そんなフランケンシュタインみたいなの、後から学習するだけでできちゃったんだって。これのすごいとこは、有用な知識のほとんどはFFNに入ってて、attention自体はそんなにユニークとか重要じゃないってことを示唆してるっぽいこと。<br>詳しいのはここ見て→ https://substack.recursal.ai/p/qwerky-72b-and-32b-training-l...<br>そうそう、すでに学習済みのattentionを使って、gpt2の高速学習でFFNだけ学習させたらどんくらいかかるか試すのも面白いかもね（ルール違反だけど、個人的にはめっちゃ興味ある論文を読みたいとこ）。<br>https://github.com/KellerJordan/modded-nanogpt<br>あと、昨日読んだけど、モデル間のembeddingsってかなり似てて、簡単な変換器を訓練できるらしい。もしこの両方が本当なら、固定のembeddingsとattentionsを共有するだけで、全部もっと速く訓練できるかもね。" userName="cztomsik" createdAt="2025/05/22 07:44:20" color="#ff5733">}}




{{<matomeQuote body="attentionってさぁ（元の研究者には最大限の敬意を払いつつ言うけど）、「ただ」ネットワークの過去全部を逆版MoEみたいなニューラルネットにぶち込んでるだけって、気づいてた？（つまり、専門家がネットワークの一部を実行するんじゃなくて、入力の一部を選んでるってことね）<br>ある意味、これがうまくいくってのはみんな知ってたんだよね。誰もやらなかったのは、RとかPython使う人でも「ありえないくらい遅い」とか「納得いくレベルまで訓練できるほど実行できない」と思ってたから、効率悪すぎるからなんだ。" userName="spwa4" createdAt="2025/05/22 09:35:24" color="">}}




{{<matomeQuote body="attentionなんて、ネットワークを並列化して学習できるようにする、ただの完全に勝手なやり方だよ。<br>俺的に成功に貢献したのは、「shortcut connections」で層を飛び越えるやつだと思うね。あれのおかげで、学習中により早い層に影響を与えられるようになったんだ。" userName="scotty79" createdAt="2025/05/22 12:20:59" color="">}}




{{<matomeQuote body="＞俺的に成功に貢献したのは、「shortcut connections」で層を飛び越えるやつだと思うね。<br>知らない人のために言うと、これはResNet（He et al., Deep Residual Learning for Image Recognition, https://arxiv.org/abs/1512.03385）のアイデアね。ResNetは深層学習史上、最も影響力のある論文の一つだね。<br>Residual connectionsのおかげで、どれだけ深いネットワークでも訓練できるようになったんだ。ResNetが出る前は、深すぎると勾配消失とか勾配爆発で訓練できなかったからね。" userName="grumbelbart2" createdAt="2025/05/22 12:55:23" color="#38d3d3">}}




{{<matomeQuote body="＞あと昨日読んだけど、モデル間のembeddingsってかなり似てて、簡単な変換器を訓練できるらしい<br>これはここからだよ。<br>https://news.ycombinator.com/item?id=44054425" userName="cubefox" createdAt="2025/05/22 12:50:21" color="">}}




{{<matomeQuote body="現代のtransformerで使われてるSDPA attentionがそんなに重要じゃないってのは既知だよ → https://arxiv.org/abs/2111.11418<br>FFN、normalization、and residual connectionsはマジで替えがきかないけど、attentionは他の層（poolingとかconvolution、random mixingとか）でtokens間で情報共有できれば、ほぼ何でも置き換えられるんだ。" userName="slickytail" createdAt="2025/05/22 09:16:33" color="#785bff">}}




{{<matomeQuote body="深いネットワークで勾配消失を防ぐんだよ。<br>あと、residualがあるblocksはほとんどが初期化のときにidentity functionに近くなるから、うまく振る舞う傾向があるんだ。" userName="simsla" createdAt="2025/05/23 00:17:17" color="">}}




{{<matomeQuote body="マジか…めちゃ速いじゃん。でもさ、結局LLMって新しいコードとかプロトタイプ向きだと思うんだよね。何度も手直しされた既存のデカいコードを改善するのは微妙じゃない？ コードベースに無い「負の空間」の情報って大事で、LLMはそれ持ってないし。いくら賢くなっても、その知識不足がハンデになると思うんだ。想像してみてよ、めっちゃ優秀な開発者にデカいコード渡して、ちょっと読んだだけで質問も無しに一発で直せって言うようなもん。大抵は、腕は普通でもコードに詳しい人の方が価値出せるよ。" userName="airstrike" createdAt="2025/05/22 01:30:29" color="#785bff">}}




{{<matomeQuote body="いや、俺の経験だと違うんだよな。LLMsは既存の良い感じのコードを真似るのは得意だけど、言わなきゃ新しいアイデアは出してこない。コード全体を飲み込めてないから、たまに他のファイル見せてコピペさせることもあるし。とはいえ、Stable Diffusionみたいなネガティブプロンプトはコードでも面白そうだな。" userName="8n4vidtmkvmk" createdAt="2025/05/22 04:25:06" color="">}}




{{<matomeQuote body="俺も「既存コードはダメ」派だな。1000行くらいのファイルとか、別のライブラリとか設計パターン使うように直させようとすると、マジでゴミしか出てこないんだよ。UIにDBの処理入れたり、関係ないapi呼び出したり、出力が完全に壊れたりさ。きっと正しい使い方があるんだろうけど、なんか「持ち方間違えてる」って感じだわ。" userName="Incipient" createdAt="2025/05/22 05:59:42" color="">}}




{{<matomeQuote body="「…コードベースに無いもの、そしてその負の空間に意味ある信号がある。」ってさ。何十年もカネ稼ぐためにソフト書いてるけど、このマジな真実に気づいたことなかったわ。少なくとも意識してハッキリとはね。だから、サンキューな！" userName="ManuelKiessling" createdAt="2025/05/22 06:42:34" color="">}}




{{<matomeQuote body="あれは一般的なコメントだったんだ。最先端モデルでそんなに差があるなんて意外だよ。vscode使って、pythonフレームワーク（dash, fastapi, pandasとか）で、関係するファイル4〜5個をコンテキストに入れてる感じ。dockerで開発してるから、エージェント系はちょっと使いにくいんだよね。" userName="Incipient" createdAt="2025/05/22 08:03:32" color="">}}




{{<matomeQuote body="Clineみたいなエージェントシステム使うのはどう？ LLMが自分でコードベースをウロウロして調べて「メンタルモデル」作って、実装計画を立てられるんだ。それに沿って試行錯誤して、最後に実装させるとか。このやり方の方が今言ってるより断然うまくいくよ。" userName="danielbln" createdAt="2025/05/22 08:10:18" color="#ff33a1">}}




{{<matomeQuote body="LLMが自分でコードベースを調べてメンタルモデル作るとか…コンテキストの長さ制限があるから、それは無理でしょ。" userName="otabdeveloper4" createdAt="2025/05/22 10:03:13" color="">}}




{{<matomeQuote body="アートの負の空間はわかるんだけど、それがソフトウェア書くのにどう関係するのか説明してくれる？" userName="stef25" createdAt="2025/05/22 10:59:16" color="">}}




{{<matomeQuote body="コツはLLMと会話して情報共有すること。大きな作業では、o3に同僚のように話しかけ、関連ファイルをコピペしてコンテキストにする。理解できたと感じるまで高レベルで議論。o3にコード全体の実装計画を立ててもらい、Codexに実行させる。PRができる。手直しも必要だが、完璧な時も。豊富なコンテキストは必要だが、これは上手い使い方のコツ。慣れれば強力で楽しいよ。" userName="westoncb" createdAt="2025/05/22 08:52:39" color="#45d325">}}




{{<matomeQuote body="たとえば簡単な2Dゲームの話ね。エンジン使わずグラフィックライブラリだけでアニメーション作るとして、数値ベタ書きじゃなくてベクトルモジュールとか抽象化するでしょ？ 経験上そうなるはず。ナイーブなコードは機能するけど、すごく冗長でメンテ大変なんだよ。<br>だから絵を描くみたいにプログラム全体をホリスティックに考える必要がある。コードは抽象化を支えるもの。それが何を書くべきか、書かないべきかを決める。ソフトウェアでパターンが重要視されるのはそのため。コードよりパターン、構造が大事なんだよね。" userName="skydhash" createdAt="2025/05/22 12:14:14" color="#785bff">}}




{{<matomeQuote body="2Dゲーム作ったことあるけど、たぶんこの比喩はピンとこないか、ここで役に立つとは思わないな。アートのネガティブスペースはある効果を生む。リンクされてるコメントみたいに、空きスペースは彫刻の一部ってわけ。だから空きスペースには目的と意味がある。<br>でも特定のライブラリを選ばなかった場所、その空きスペースは何の機能も果たさない。コードを変えて開発を楽にしたり難しくしたりはするけど、結果そのものに意味はない。" userName="lukan" createdAt="2025/05/22 15:02:26" color="">}}




{{<matomeQuote body="コードベース全体じゃなくて、呼び出しマップとか関数シグネチャとかだけでいいんだよ。呼び出し全部含める必要はないけど、全部にアクセスできれば関連するものを選べるはず。" userName="exe34" createdAt="2025/05/22 11:25:29" color="">}}




{{<matomeQuote body="gitの全履歴とか、Issue trackerの全チケットをコンテキストに含めることだってできるし、ミーティングの記録までいけるかもね。でも、そんな巨大なコンテキストが使える結果を出すかはまだ分からないけど。" userName="manmal" createdAt="2025/05/22 04:56:19" color="">}}




{{<matomeQuote body="ナイーブなコードを書くより、コードを設計することについて話してるんだ。ライブラリについても同じことが言えるけど、そっちはもっと主観的。<br>ソフトウェアを書くナイーブなアプローチの多くはアセンブリみたいに見える。オペコードじゃなくてライブラリ関数だけどね。でもアセンブリやアセンブリみたいなプログラミングから離れたのは、基本的に一発ものだから。プログラムの変更が難しくて面倒なんだ。だからその一つの命令の塊じゃなくて、柔軟性を持たせるために隙間を作るんだ。関数、オブジェクト、モジュールとか…でもそれらの実際のつながりはまだ整形する必要がある。<br>ライブラリはある程度形に影響を与えるけど、手段より解決策を優先するならそれはマイナーなものだよ。でも時にはその形の隙間を埋めるのにすごく熱心になる人がいて、そういう時に KISSとかYAGNIって叫びたくなる。形を変えたい時には SOLIDとか他の原則を持ち出すんだ…" userName="skydhash" createdAt="2025/05/22 16:18:01" color="#ff5733">}}




{{<matomeQuote body="1k LOCなら全然問題ないよ。Claudeで多くの（全部じゃないけど）1k LOCくらいのプロジェクトでは問題経験しなかったな。" userName="johnisgood" createdAt="2025/05/22 11:47:06" color="">}}




{{<matomeQuote body="これには同意できないな。問題を解決する代替手段があったのに採用されなかったなら、それはコメントに文書化すべき。自分や同僚にいつも言い聞かせようとしてるマントラは、頭の中にしか情報がないなら”どこかに”書き出せ、ってこと。<br>もし一つのライブラリに落ち着く前に5つの異なるライブラリを試したなら、どのライブラリを試したけどダメだったか、そしてその理由をコメントに書くんだ。特定のツールを使って競合状態をデバッグしたなら、それの使い方に関するWikiページへのリンクをコメントに置く。特定の分野で専門家の同僚がいるなら、その人の名前をコメントに書く。基本的に、将来の開発者の時間を節約することになるものは何でも書き出すべきなんだ。" userName="spuz" createdAt="2025/05/22 08:18:08" color="#ff5c5c">}}




{{<matomeQuote body="それ以下は「プロジェクト」じゃなくて「ファイル」だよ。" userName="otabdeveloper4" createdAt="2025/05/23 16:08:33" color="">}}




{{<matomeQuote body="モデルが十分速くなればさ、専門家を即戦力として迎え入れて、特にRAGを使えば、自分で解決策を見つけさせられるようになるよ。そのうち、モデルはゼロから始めるんじゃなくて、もっとメモリや組織の知識を取り込むようになると思うな。" userName="ec109685" createdAt="2025/05/22 02:23:58" color="">}}




{{<matomeQuote body="”コードをただ書くんじゃなくて、設計の話だね”って？大学でデザインパターンを学んだけど、実務でオーバーエンジニアリングになっちゃった経験があるんだ。だから今は、すごくシンプルで分かりやすい設計が好き。回りくどいことや隠されたレイヤーはなし。君の言いたいことは分かるけど、僕には clever すぎる複雑な設計を良しとしてた昔の自分を思い出させる雰囲気なんだよ。" userName="lukan" createdAt="2025/05/22 17:51:03" color="#ff5c5c">}}




{{<matomeQuote body="面白いやり方だね。”〜な実装計画を生成して…”って言い方、パクるよ。僕もCursorで似たことやっててね。まずspecファイルにやりたいこと書いて、AIチャットで質問させて、それに答える。ファイルも添付してね。それからAIに実行計画を作らせるんだ。これで仕様が固まる。複雑な機能向けだけど、簡単なのはチャットでプロンプト編集してやってるよ。" userName="dimitri-vs" createdAt="2025/05/22 12:23:58" color="#38d3d3">}}




{{<matomeQuote body="コメント書きながらそれも考えたんだけど、それを一貫して、速く、スケーラブルに実現するためのインフラや連携部分は、まだ数年先だと思うな。" userName="airstrike" createdAt="2025/05/22 02:40:26" color="">}}




{{<matomeQuote body="その通り、本物のScotsmanなんていないんだよ！" userName="exe34" createdAt="2025/05/23 17:39:25" color="">}}




{{<matomeQuote body="うん、シンプルさは大事だけど、簡単さとは違うんだよね。シンプル⇔複雑の軸と、簡単⇔難しいの軸は別。何も考えずにパターン使って複雑にするのも簡単だし、単純なコードで後で扱いにくくなるのも簡単。良いプログラマーはこれらをバランスさせて、扱いやすいコードにすること。スケッチみたいに、段階ごとにフィードバック得て次の方向を決める感じ。アーティストが判断力のために練習するようにね。" userName="skydhash" createdAt="2025/05/22 18:16:00" color="#785bff">}}




{{< details summary="もっとコメントを表示（1）">}}

{{<matomeQuote body="LLMの助けが欲しいような実際のプロジェクトって、数千行じゃなくて数百万行のコードから始まるんだよ。1k行くらいのコードなら、LLMなんていらないし、インターン1人の頭の中に全部収まっちゃうじゃん。" userName="otabdeveloper4" createdAt="2025/05/23 10:15:44" color="#ff33a1">}}




{{<matomeQuote body="今どきの会議って、ほとんどがノイズだと思うんだよね。「これが結果だ！」っていう明確な”シグナル”がない。これこそAIがフィルターできるべきことだと思うな。もちろん、みんながもっと明確に、簡潔に話せたら一番良いんだけどね。" userName="Cthulhu_" createdAt="2025/05/22 07:46:28" color="">}}




{{<matomeQuote body="”各段階で、次のイテレーションの正しい方向性を判断するための十分なフィードバックを得る”って、プロジェクトによると思うな。急な変更にはシンプルな解決策の方がうまく妥協できる。シンプルが簡単なんて絶対言わないよ。むしろ逆で、複雑にするのは簡単。デザインパターンもKISSも知ってたけど、賢さばかり重視してたんだ。結論は：シンプルで直接的な解決策を優先すべき。clever にやろうとするのは clever じゃない。初めて読む人が理解できないコード一行より、3行の方がいいし、設計でも同じだよ。" userName="lukan" createdAt="2025/05/22 19:00:36" color="#ff5c5c">}}




{{<matomeQuote body="それは誤った例えで釣ろうとしてるだけだね。もし君のリポジトリマップが1000トークンに収まるなら、それは十分小さいリポジトリだから、ファイルを全部連結してLLMにプロンプトとして一気に食わせられるよ。いや、現在のLLM技術は実際の（つまり大きな）リポジトリを処理することはできないんだ。" userName="otabdeveloper4" createdAt="2025/05/25 20:29:12" color="#38d3d3">}}




{{<matomeQuote body="ちょっとやってみるね。ソフトウェアにおけるネガティブスペースの比喩は、抽象化の形であり、適切なものを簡単に、かつレールに乗せるようにしつつ、過剰な設計にならないスイートスポットを見つけることだと思うんだ。<br>視覚芸術では、ネガティブスペースはレイアウトの一部で、視覚的な流れを作る。それは物事そのものと同じくらい、物事間の関係性を定義するのを助けるし、適切に使えば、優雅さと雑然さの違いになるんだ。<br>「ライブラリを選ばない」っていうのは重要な情報だけど、ネガティブスペースと同じものじゃなくて、むしろ制限とかフレーミングに近いかな。見せないもので多くのことができるけど、この分野では良いアートと良いソフトウェアは目標が違うと思うんだ。僕にとって良いアートは考えさせたり、感じさせたり、推測させたりするけど、良いソフトウェアはそれ以外のことをできるだけ少なくして理解させてくれる。<br>例外としては、非常に良いけど明らかじゃない理由で物を選ばない場合かな。これは大声で文書化すべきだね。ライセンスとか他の外部要因とか、特定のハードウェア要件とかかな。例えば、以前、それが役立つ可能性があった製品でGraphQL APIの作成を禁止したことがあるんだ。なぜなら、既存のAPIをサードパーティのために永遠にサポートする必要があったから、APIを置き換える提案は、実は密かに2つのAPIを同期させて維持するという提案だったんだよ。" userName="collingreen" createdAt="2025/05/22 16:10:02" color="#45d325">}}




{{<matomeQuote body="これにめちゃくちゃ驚いてる人いる？ IOで一番大きな発表だと思うんだけど、Veo 3とかに影が薄くなっちゃってるよね。<br>コード生成のためのDiffusionモデルはすごい大事だよ。もしTransformerを使ってるなら、これはおそらくDiTの仲間に入るだろうね。数年前にU-Net diffusionを活用したユースケースに取り組んだことがあって、ハイブリッドモデルにはかなりの関心があったんだ。近い将来、Diffusion分野でさらなる飛躍があると期待してるよ。" userName="shreezus" createdAt="2025/05/22 04:45:08" color="">}}




{{<matomeQuote body="ここでの直感を誰か手伝ってくれない？ 画像Transformerからの僕の理解では、ノイズから始めて、一連の階層モデルを使ってノイズを目標に反復的に洗練していくんだよね。各層はより高い解像度で画像を生成するように訓練されていて、それらを重ねることで「ノイズ」から「顔っぽく見えるノイズ」になるまでの始めの疎な勾配の問題をスキップする。<br>これがコーディングでどう機能するの？ 生成される成果物を階層的に構造化できる必要があるってことだよね。多分これもうまくいくかもね。「この問題にはDjangoを使う」みたいな粒度の低いコンセプトから始めて、次に「これらのエンドポイントが必要だ」そして「コードを出力する」。でもAIUI Diffusionにはバックトラッキングの仕組みがないから、低レベルの問題に対応してデザインの側面を変更する必要が出たときに、詳細レイヤーからの信号を上位抽象化レイヤーにフィードバックできないんだ。<br>一方、Transformerは各トークンに対してモデル全体を通過するから、必要なら問題の各ステップで全てのスマートさやロジックを展開できるし、重要なデザイン決定のバックトラッキングも含まれる。<br>僕のメンタルモデルには大きなギャップがあるはずだ、何かインサイトがあれば嬉しいな。" userName="theptip" createdAt="2025/05/22 05:51:40" color="">}}




{{<matomeQuote body="名前とは裏腹に、Diffusion LMは画像のDiffusionとはほとんど関係なくて、BERTや古き良きマスクされた言語モデリングにはるかに近いんだよ。BERTがどう訓練されるか思い出してみて。<br>1. 文全体を取る（”the cat sat on the mat”）<br>2. 15%のトークンを[MASK]トークンに置き換える（”the cat [MASK] on [MASK] mat”）<br>3. Transformerにマスクされた位置のトークンを予測させる。これは単一の推論ステップで並行して行う。<br>さて、Diffusion LMはこのアイデアをさらに進める。BERTは15%のマスクされたトークン（”ノイズ”）を回復できるけど、ここで止まる必要はない。30%、50%、90%、100%のマスクされたトークンを持つテキストを回復するようにモデルを訓練しよう。<br>それが訓練できたら、ゼロから何かを生成するために、全ての[MASK]をモデルに入力することから始める。それはほとんど意味不明なものを生成するけど、ランダムな位置からいくつかのトークン（例えば10%）を取って、これらのトークンが生成された（”確定した”）と仮定することができる。次に、別の推論イテレーションを実行する。今度は入力が90%のマスクと10%の”確定した”トークンを持つ。再び、新しいトークンの10%を確定済みとしてマークする。これを続けると、10ステップでシーケンス全体を生成できる。これがDiffusion言語モデルの核となるアイデアだよ。<br>もちろん、現実世界にはいくつかの最適化がある。本当に長いテキスト（200トークン以上）を生成する必要があるなら、それをチャンクに分割して、最初のチャンクを並行して完全に生成してから次のチャンクに進む方が良い。この半自己回帰生成がBlock Diffusionが行うことだよ。<br>生成されたと見なすトークンをどのように正確に選び、何パーセントを正確に選ぶかについてスマートになれる。初期段階では、ほとんどがノイズの時、もっと多く取れるし、最終段階ではもっと多くのイテレーションを行い、より少ないトークンを取ることができる。<br>結局のところ、Diffusion LMは依然として反復的だけど、ステップ数は自己回帰モデルよりもはるかに少ない。良い点は、どれだけのステップを行うかを選択できることで、品質と速度をトレードオフできることだね。<br>極端な場合、Diffusion LMで一番左のマスクされたトークンだけを生成することさえ可能で、事実上、それを従来の因果言語モデルに変えることができるんだ。" userName="nvtop" createdAt="2025/05/22 07:38:32" color="#ff5c5c">}}




{{<matomeQuote body="素晴らしい説明だね。テキストDiffusionモデルが推論中に「編集」できるって見たことがあると思うんだ。言い換えれば、「確定」したトークンが必ずしも「確定」じゃなくて、変更される可能性があるけど、後のイテレーションでモデルが本当に確定だと判断するってこと？ それはどうやって機能するの？" userName="yahoozoo" createdAt="2025/05/22 10:36:27" color="">}}




{{<matomeQuote body="僕も君と全く同じ疑問を持ってるよ。画像のDiffusionでさえ理解するのがやっとで、テキストみたいな連続データでは意味がわからないんだ。" userName="pertymcpert" createdAt="2025/05/22 06:06:12" color="">}}




{{<matomeQuote body="その通り、Diffusion LMは中間予測を編集できるから「確定」トークンは必ずしも確定じゃないんだ。これってすごく面白い特性で、GPTみたいなモデルにはできない、生成されたエラーを修正できるってことなんだよ。<br>この編集は、Transformerのエンコーダーの特性に基づいているんだ。それはシーケンス内の__全ての__トークン、マスクされたトークンだけでなく、それ以外のトークンも含めて、確率を予測するんだ。だから例えば、”[MASK] cat barks”っていう3つのトークンの文を入力すると、Transformerは3つのトークンそれぞれに対して、語彙全体にわたる確率分布を無料で生成してくれる。<br>さて、トークンを編集したいか、そのままにしたいかをどう決めるかについては、色々な方法を考えられるよ。最も単純なケースでは、新しいトークンの確率が元のトークンよりもある程度高ければ、新しいトークンを採用する。僕たちの例で言うと、モデルが2番目の位置のトークン”cat”の確率をp_2(“cat”) = 0.3、一方p_2(“dog”) = 0.6と返したとする。僕たちは”cat”を”dog”に置き換えて、それを以降のイテレーションで使いたいと思うかもしれない。<br>実際のヒューリスティクスはもう少し複雑だけど、基本的な考え方はこれだよ。<br>追記：LMに、入力のマスクされていないトークンをただコピーするだけでなく、より良い代替を見つけようと試みるように教えるためには、訓練目的に入力トークンの一部を他のランダムなトークンで置き換えることを含めるべきだね。これで入力の一部がマスクされ、入力の一部が破損しているので、モデルは全ての入力トークンがそのまま存在すると盲目的に仮定することはできないんだ。" userName="nvtop" createdAt="2025/05/22 11:36:27" color="#38d3d3">}}




{{<matomeQuote body="語彙に1万個のトークンがあると仮定しようか。<br>そうするとテキストは、高さ1万ピクセル、幅Nピクセル（テキストの長さ）の画像になるね。<br>各列では、ちょうど1つのピクセルが白（そこにある単語に対応）で、残りは黒だよ。<br>そしたらDiffusionプロセスは同じさ。繰り返しノイズ除去するだけ。" userName="janalsncm" createdAt="2025/05/22 07:18:12" color="">}}




{{<matomeQuote body="いや、その直感は正しくないよ。<br>ノイズ除去モデルは、多くの領域が滑らかになるから機能するんだ。そういうことは「離散的なやり方」ではできないんだよ、わかるかな。" userName="moralestapia" createdAt="2025/05/22 09:42:35" color="">}}




{{<matomeQuote body="でも、プログラム内のシンボル間の依存関係はどうなるの？ それらのシンボルはプログラム設計という高い制約に囲まれているからね。<br>これは画像のDiffusionでも問題になるんだ。ポートレートを頼んで、詳細が間違っている時とかさ。それは顔には制約があるからだよ（アーティストが学ぶこと）。パターンと確率だけでは助けにならないんだ。" userName="skydhash" createdAt="2025/05/22 12:28:35" color="">}}




{{<matomeQuote body="コード生成にDiffusion modelsはマジで重要だよ＞俺もそう思うんだよね。こういうモデルはコーディングの簡単なタスクにいっぱい使えるからさ：<br>－関数定義と出力で制約して間のトークンを”生成”するワークフローとかできるはず。両方向のトークンを見れるからね。<br>－あとは、高レベルなレイアウトから始めてリンターとかコンパイルとかAST情報使いながら実装を進める2段階ワークフローも。マジで色々試す価値ありだね。" userName="NitpickLawyer" createdAt="2025/05/22 05:38:55" color="#45d325">}}




{{<matomeQuote body="ノイズ付きコードをきれいにする小さなステップでは独立性を仮定できると思ってるんでしょ？たくさんのステップをつなげると、全ての相互依存性をモデル化できる柔軟な分布ができるんだ。統計の人がもっと詳しいだろうけど、Diffusionはautoregressionを一般化するって見方もあるらしいよ。依存関係のグラフを因数分解するのに順序がいらないからね。" userName="angusturner" createdAt="2025/05/22 14:01:38" color="#ff5733">}}




{{<matomeQuote body="autoregressionとdiffusion、両方できるハイブリッドモデルって可能なのかな？根本的にできないことはなさそうだよね。思考（thought generation）をDiffusion CoTでサクッと作って、答えはautoregressionで出すとか、色々考えられそうだよ。" userName="Workaccount2" createdAt="2025/05/22 15:15:39" color="">}}




{{<matomeQuote body="画像をダウンスケールするみたいに、ピクセル値じゃなくてトークン埋め込みを平均化すればテキストもダウンスケールできるんだ。でも、そうする必要はないよ。AFAIKだけど、vision transformersは疎な勾配で困らないから、ダウンスケールはただのパフォーマンス最適化なんだ。フル解像度で画像を処理するのは大変だからね。" userName="yorwba" createdAt="2025/05/22 06:29:12" color="">}}




{{<matomeQuote body="この技術でどうやってスピード出してるのか気になるな。普通、”masked language model”って全単語の候補を毎回転計算するから、もっと遅いと思ってたんだよね。てっきり、最終的には連続空間でdiffusionして、離散トークンにデコードする感じになるのかと。あと、これもGemini Diffusionのやり方の”推測”ってことで合ってる？" userName="shawntan" createdAt="2025/05/22 17:08:06" color="#45d325">}}




{{<matomeQuote body="面白いね、解説もすごく分かりやすい。でも、挿入とか削除の操作はどうなの？ ”最終”トークンの間に、コードをちゃんと完成させるのにトークンが少なすぎるリスクってないのかな？" userName="oliwary" createdAt="2025/05/22 12:34:53" color="">}}




{{<matomeQuote body="embedding空間なら滑らかなのかもね。" userName="lostmsu" createdAt="2025/05/22 16:40:42" color="">}}




{{<matomeQuote body="＞でも Veo 3とかに霞んじゃってるね。Veo 3のパワーとか能力の違いは簡単に理解できるから。テキスト補完の重要な進歩を理解するには、今あるものの価値とか将来的な影響を知る必要があるんだ。まだ多くの人が、そもそもLLMがコーディングに役立つって信じてないみたいだしね。" userName="bredren" createdAt="2025/05/22 06:13:16" color="">}}




{{<matomeQuote body="ソフトウェアの保証にformal verificationがある理由、各コンポーネントの意味論を知る必要性、トークン一つで意味が変わること、プログラミングは指示に意味論を押し付けること、アルゴリズムは意味論的な制約だって話。LLMとかdiffusionはせいぜい高度な検索だって見れるけど、本当に重要なのは意味論なんだ。紙でも設計できるのはそのため。コードエディタ使うのはフィードバックが良いから。コードを読むのが一番確実だってね。" userName="skydhash" createdAt="2025/05/22 16:46:05" color="#45d325">}}




{{<matomeQuote body="でも、それって結構難しくない？Aの次にはBしか来ちゃダメ、みたいなルールがあって、5番目のトークンがAに変わっちゃったら、守らなきゃいけない制約がドミノ倒しみたいになるじゃん。" userName="janalsncm" createdAt="2025/05/22 07:20:10" color="">}}




{{<matomeQuote body="コード版のインペインティングみたいな？" userName="bn-l" createdAt="2025/05/22 07:39:31" color="">}}




{{<matomeQuote body="どうだろうね。原則、左右の情報使えるのは有利だと思うけど、LLaDAはサイズに対してすごいけどperplexityでは遅れてるし、それは仕方ないと思うな。あと、早く固定されちゃうから、テキストを深く修正できるっていう期待はそこまで信じてないんだ（もちろん、単語1つ2つ間違いとかはある程度直せるだろうけど）。間違った単語は同時にマスクする必要があると思ってるからね。それでも、実験で見た結果には満足してるよ。" userName="impossiblefork" createdAt="2025/05/22 08:22:34" color="#45d325">}}




{{<matomeQuote body="＞例えばモデルがトークン「cat」の確率0.3、「dog」の確率0.6を返すとするじゃん？<br>「cat」を「dog」に置き換えて次で使いたいかも．<br>スピードと品質のトレードオフとして、logitで分岐させてより良い結果を探す「ツリー探索」って手もある？<br>diffusion modelがARよりずっと速いなら、探索やバックトラックしても気にならないかも．" userName="paulsmith" createdAt="2025/05/22 15:34:11" color="#785bff">}}




{{<matomeQuote body="俺っち思うんだけど、一番大事なこと見落とされてない？<br>これってめっちゃすごくて速いInstructGPTだよ．<br>間違いなくスペルチェック、codemods、コードエディタで使われる．<br>インスタント編集は余計な機能なしにサッとテキスト編集．<br>shadertoysのコードで変数名変更頼んだら、ちゃんと動く結果くれた．マジ感動！" userName="heliophobicdude" createdAt="2025/05/22 01:31:26" color="#785bff">}}




{{<matomeQuote body="いや、そうじゃないよ．単語のスペルは合ってるけど、文法的に正しくても間違った単語を使っちゃう場合とか、スペルチェックは頻繁に間違いを見逃すんだ．" userName="efitz" createdAt="2025/05/22 06:00:14" color="">}}




{{<matomeQuote body="何か例を出してくれる？スペルチェックって単語が辞書にあるかだけチェックするんだろ．文法や文脈はチェックしないじゃん．" userName="wenc" createdAt="2025/05/22 06:23:18" color="">}}

{{</details>}}




{{< details summary="もっとコメントを表示（2）">}}

{{<matomeQuote body="「Bob went to Venice to pick up the doge．」<br>ここでdogeは称号（dukeみたいな）の名前だけど、「dog」ってスペルミスしてるんだ．「Venice」を使ってることから、doge（ヴェネツィア総督）のことを言ってる可能性が高まって、賢いスペルチェックならdogeのままにしてdogに直さないかも．もっと広い文脈を見れば、Bobが子犬の話をしてるって分かるかもね．<br>もっと簡単な例だと「spell cheque」とか．" userName="thinkingemote" createdAt="2025/05/22 07:51:46" color="">}}




{{<matomeQuote body="一つの辞書の定義によると、スペルミスってのは「単語の、慣習的に受け入れられた綴り方における誤り」だから、一つの単語を別の単語と間違えるのはこの定義には入らないんだよ．<br>確かに今はスペルチェッカーに文法チェックも期待されてるけど、純粋なスペルチェッカーなら英語の単語リストに頼るだけで大丈夫なんだ（これは形態がもっと発達してたり複合語が多い言語では通用しないけどね）．" userName="macleginn" createdAt="2025/05/22 10:19:32" color="">}}




{{<matomeQuote body="うん、まあそれは技術的な細かさだね．スペルチェッカーはゆっくり文法チェッカーに進化したし、みんなが本当に欲しいのはエラー修正なんだよ．<br>それがスペルチェッカーと呼ばれるかどうかなんて、小さな言語の問題で（人間がしょっちゅうやることだよ）．<br>辞書のために教える時は、「俺が難癖つけなかったら、彼らが何を言いたいか明らか？」って聞いてみて．" userName="kmacdough" createdAt="2025/05/22 10:46:17" color="">}}




{{<matomeQuote body="でも、この二つのケースでは違う出力が必要だよね．間違った単語選びは、たぶん別の単語の意図があったんじゃない？っていうヒントが普通ついてくるけど、間違ったスペルは明確に間違いってマークできるんだ．<br>この二つの動作は別々にオンオフできるし、違う二つのラベルが必要なんだよ．" userName="macleginn" createdAt="2025/05/22 12:30:44" color="">}}




{{<matomeQuote body="オッケー。”Dessert”と”desert”の間違いは、文法ミスっていうよりスペルミスだよね。どっちも名詞だけど意味全然違うし、ただスペル間違えてるだけじゃん。" userName="ealexhudson" createdAt="2025/05/22 11:11:18" color="#ff33a1">}}




{{<matomeQuote body="うん、同意。でもさ、「complementary／complimentary」とか「discrete／discreet」みたいに、普通のスペルチェックじゃ引っかからないタイプのスペルミスだよね。" userName="macleginn" createdAt="2025/05/22 12:34:56" color="#785bff">}}




{{<matomeQuote body="あんたの定義の解釈には同意できないな。「pale」を「pal」って書くのは、「pal」って単語があっても「pale」としては間違いだよ。「His mouth dropped and he turned pal。」って文を人間が見たら、間違いだって指摘するはず。スペルチェックができないのは難しいからで、コンピュータの限界だろ。スペルチェックの定義の問題じゃないよ。" userName="tacitusarc" createdAt="2025/05/24 15:18:47" color="#ff5c5c">}}




{{<matomeQuote body="Finnishが何か言いたげだよ。「kauppa」（”shop”）みたいな名詞一つに、少なくとも6000以上の形があるって（https://flammie.github.io/omorfi/genkau3.html）。これ複合語とか含まないんだよ。借用語とかスラング、他の品詞への派生もあって、これを全部網羅した単語リストなんて作るの絶対無理。同じUralic languagesの仲間も極端に活用するけど、言語モデルの学習や単語リスト集めに使えるオンラインリソースがほぼないんだ。" userName="internet_points" createdAt="2025/05/22 08:26:01" color="#38d3d3">}}




{{<matomeQuote body="Finnishは他のほとんどの言語とは全然違うし、訓練データが少ないのは事実だけど、あのウェブページはおかしいし、実際の言葉を反映してないよ。あんな形、Finnishの歴史上で誰も喋ったことないから。文法ってのは言葉を「記述」するもの、「定義」するもんじゃないんだ！" userName="yencabulator" createdAt="2025/05/22 15:57:01" color="#ff33a1">}}




{{<matomeQuote body="”would like a word”ね。なるほど、君がそこで何やったか分かったよ…ってね。" userName="rcarmo" createdAt="2025/05/22 12:59:11" color="">}}




{{<matomeQuote body="まさに彼らが言ってることだよ。「the work required deep incite」なんて書いたら、普通のスペルチェックじゃ間違い見つけられないけど、みんなそれはスペルミスだって思ってるもんね。" userName="Timwi" createdAt="2025/05/22 08:32:46" color="#785bff">}}




{{<matomeQuote body="「cue」を「queue」と間違える人たちの登場だね。" userName="SSLy" createdAt="2025/05/22 07:53:03" color="">}}




{{<matomeQuote body="でもさ、スペルチェックがこのコメント直してくれたら良かったと思わない？" userName="matsemann" createdAt="2025/05/22 08:02:51" color="#45d325">}}




{{<matomeQuote body="ハハ！ Appleは”of”だけ拾って”consider have instead”って言ったけど、他はそのままだったよ。スペルチェックの限界を示す最高のqedだね。でもね、Chatgptは完璧に直したよ：”But wouldn’t you like it if a spell check could have fixed these commands？”ってね。" userName="NitpickLawyer" createdAt="2025/05/22 09:40:18" color="#38d3d3">}}

{{</details>}}



[記事一覧へ]({{% ref "/posts/" %}})
