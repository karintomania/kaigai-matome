+++
date = '2025-05-13T00:00:00'
months = '2025/05'
draft = false
title = 'Branch Privilege Injection：分岐予測器の競合状態を悪用！'
tags = ["セキュリティ", "CPU", "脆弱性", "投機的実行", "サイドチャネル攻撃"]
featureimage = 'thumbnails/orange1.jpg'
+++

> Branch Privilege Injection：分岐予測器の競合状態を悪用！

引用元：[https://news.ycombinator.com/item?id=43974891](https://news.ycombinator.com/item?id=43974891)




{{<matomeQuote body="研究者のブログ記事と論文へのリンクだね。<br>ブログ： https://comsec.ethz.ch/research/microarch/branch-privilege-i...<br>論文： https://comsec.ethz.ch/wp-content/files/bprc_sec25.pdf" userName="progval" createdAt="2025/05/13 16:50:29" color="">}}




{{<matomeQuote body="影響の説明だよ。<br>研究者のRüeggeさんが言うには”時間かければメモリ全部の内容を読み出せる”<br>”繰り返しエラー起こして毎秒5000バイト以上読み出せる”<br>だから攻撃されたらCPUメモリの情報全部が悪いやつの手に落ちるのは時間の問題だ、ってさ。怖いね。" userName="ncr100" createdAt="2025/05/13 17:10:38" color="#ff5733">}}




{{<matomeQuote body="もし大した性能向上じゃないなら、なんでこんなひどいバグを導入したんだ？" userName="cenamus" createdAt="2025/05/13 17:14:58" color="">}}




{{<matomeQuote body="いや、大したことないってわけじゃないよ。投機的実行は普通、分岐の多さによるけど、コードを10～50パーセントも速くするんだ。" userName="bloppe" createdAt="2025/05/13 17:27:22" color="#ff5c5c">}}




{{<matomeQuote body="ありがとう！記事のタイトルについてるURLをブログ記事に変えてくれると嬉しいな。今のプレスリリースは役に立たなさすぎ。" userName="trebligdivad" createdAt="2025/05/13 17:47:56" color="">}}




{{<matomeQuote body="これにはソフトウェアとハードウェアが協力する必要があるね。特に、セキュリティコンテキストが違うスレッドは同じコアに割り当てちゃダメ。これを保証できれば、fenceとかflushとかの状態クリアはカーネル呼び出しとかプロセスの一生が終わるときだけに限定できる。そうすれば、キャッシュとか投機的実行のメリットは、実際に重い処理をやってるものにはそのまま残せて、サイドチャネルリークの心配もなくなるよ。" userName="tsukikage" createdAt="2025/05/13 23:27:36" color="#ff5733">}}




{{<matomeQuote body="オッケー、上の https://ethz.ch/en/news-and-events/eth-news/news/2025/05/eth... からブログ記事の方に変えたよ。" userName="dang" createdAt="2025/05/13 17:58:31" color="">}}




{{<matomeQuote body="最近のプロセッサのパイプラインは何十サイクルも深いんだ。<br>分岐予測がないと、次に実行する命令を常に知ってる必要がある。<br>だから、今の命令をデコードして、それが分岐やジャンプじゃないってわかるまで何もフェッチできない。<br>もっと深刻なのは、もし分岐だったら、命令の実行が終わって、分岐するかわかるまで何十～何百サイクルも止める必要がある。<br>毎回の分岐でそんなに止まってたら、今の性能は絶対出ないよ。<br>そんなプロセッサが欲しいなら、マイクロコントローラー買えば？" userName="umanwizard" createdAt="2025/05/13 21:49:15" color="#ff33a1">}}




{{<matomeQuote body="それでもまだかなり控えめな見積もりだよ。全ての分岐の前に lfence を入れたら、たぶん10倍くらい遅くなる。" userName="titzer" createdAt="2025/05/13 20:52:09" color="#ff33a1">}}




{{<matomeQuote body="みんな、どう思う？うん、ダイレクトリンクはクリックを減らせるけど、元のタイトルの方が一般読者には分かりやすかったと思うんだ。私はプロのカルマ稼ぎじゃないし、dangさんの立場なら同じように調整しただろうけど、変更後にアップボート率が75%も下がったのを見ると、ちょっとキツイとは言わざるを得ないね。" userName="alberto-m" createdAt="2025/05/14 09:08:53" color="">}}




{{<matomeQuote body="気持ちはわかるよ。でも開発者たちは、あふれる3rd partyのnpmモジュールの魔女の呪文をnginxで提供するのに苦労してるんだ。security labelled cgroupベースのマイクロ（ナノ？）コンピューティングサービスを安全に設計・開発して、様々なセキュリティレベルのテキストを推論できるようにするなんて、95%のコーダーには無理ゲーだし、1%のトップ開発者でも超大変だろうね。いっそプロセッサを直す方が良くない？" userName="tankenmate" createdAt="2025/05/14 06:51:17" color="">}}




{{<matomeQuote body="そうだね…これが簡単に避けられることだと思ってる人は、ブランチ予測がない使いたいプロセッサを探し回ってみるといいよ。明るい面としては、90年代に行くことになるから、ずっと良い音楽シーンを楽しめるだろうね。" userName="bee_rider" createdAt="2025/05/13 17:40:23" color="#ff5c5c">}}




{{<matomeQuote body="修正がパフォーマンスを著しく低下させるなら、「ただ」ではない、トレードオフだよ。プロセッサ単体では緩和が必要かどうか判断する仕組みがないから、どこでもすべてに影響を与えざるを得ないんだ。今は2025年で、セキュリティは私たちの世界の一部なんだから、後からボルトオンしようとするんじゃなくて、プロセッサとソフトウェアの相互作用について考える方法に最初から焼き付ける必要があるね。私たちはその教訓をインターネット向けのソフトウェアで何十年も前に学んだ。ここでも学ぶべき時が来たんだ。" userName="tsukikage" createdAt="2025/05/14 09:28:12" color="#ff33a1">}}




{{<matomeQuote body="もちろん、ここにはちょっとしたチキンと卵の関係があるよね：もし（動的な）ブランチ予測がなかったら、私たち（コンパイラとか）は予測しないCPUにとって速いコードを出すだろうね（そして多分、予測するCPUにとっては遅くなる）。それが10倍の差を少し緩和するんじゃないかな。" userName="grumbelbart2" createdAt="2025/05/14 07:56:35" color="">}}




{{<matomeQuote body="でも、ブランチ予測は必ずしも複雑なロジックを必要としないんだよ。もしちゃんと覚えてるなら（20年前に論文を読んだきりだけど）、単純なヒューリスティック、「後方への相対分岐はすべて実行、でも前方と絶対分岐は実行しない」っていうのでも、当時の最先端実装の70～80%のパフォーマンスを達成できたらしいよ。" userName="tremon" createdAt="2025/05/14 14:20:41" color="#ff5733">}}




{{<matomeQuote body="これでJavaScriptが私のパスワードマネージャーのデータベースを漏洩させるのをどうやって防げるの？" userName="immibis" createdAt="2025/05/14 08:04:30" color="">}}




{{<matomeQuote body="もちろんそれは知ってるよ。でも、このバグの修正（Intel CPUにセキュリティホールいくつあった？）で性能ロスが数%しか出ないなら、どうやってそれを正当化できるの？そこに根本的な問題があるんじゃないの？" userName="cenamus" createdAt="2025/05/14 17:20:25" color="">}}




{{<matomeQuote body="ソフトウェア書くのがそんなに怠惰じゃなかったら、どれだけ改善されるんだろうね。ハードウェアが「十分良い」って期待するんじゃなくて、マシンから最大限のパフォーマンスを引き出して、無駄な肥大化を避けるためにちゃんとコードを書けばさ。" userName="autoexec" createdAt="2025/05/13 23:08:26" color="">}}




{{<matomeQuote body="問題は間接分岐にあるんだよ。ほとんどの分岐は直接分岐だからね。" userName="thesz" createdAt="2025/05/14 16:29:24" color="#ff5733">}}




{{<matomeQuote body="まあね。CPUがやってることをコンパイラに任せるのはうまくいかないって、何度も証明されてきたと思うよ、最近だとItaniumとかね。" userName="anyfoo" createdAt="2025/05/14 22:12:50" color="#785bff">}}




{{<matomeQuote body="全体的にってこと？ それとも分岐予測に限定して？ もしそれが全部本当なら、20〜30%のパフォーマンス低下って話になるの？" userName="anyfoo" createdAt="2025/05/14 22:14:32" color="">}}




{{<matomeQuote body="”こういう風に動くプロセッサが欲しいなら、マイクロコントローラーを買え”<br>ARM Cortex-R5FとかCortex-M7とか、いくつか名前を挙げると、これらにも分岐予測器ついてるんだけどね ;）" userName="superblas" createdAt="2025/05/14 00:07:01" color="#38d3d3">}}




{{<matomeQuote body="静的な分岐予測器を持つことはまだできるよ。それは驚くほど良いカバー率なんだ。これが素晴らしいアイデアだって言ってるわけじゃなくて、ただ指摘してるだけだけどね。" userName="jeffbee" createdAt="2025/05/14 01:51:17" color="#45d325">}}




{{<matomeQuote body="IBM Stretchには分岐予測があったよ。90年代初頭のPentiumにもあった。パイプライン処理においてはどんな場合でも大きな利点なんだ。" userName="wbl" createdAt="2025/05/14 02:59:26" color="#ff5c5c">}}




{{<matomeQuote body="”Branch Privilege Injectionは非Intel CPUに影響しますか？”<br>いいえ。私たちの分析では、評価したAMDとARMシステムでは問題は見つかりませんでした。" userName="yencabulator" createdAt="2025/05/14 14:29:10" color="#38d3d3">}}




{{<matomeQuote body="それに見合うだけの価値はあるの？全てがOrange Book（DoD 5200.28-STD）のClass B1システムみたいになる必要はないでしょ。" userName="tankenmate" createdAt="2025/05/14 11:30:05" color="">}}




{{<matomeQuote body="めっちゃ良い記事だった！要点まとめね．予測更新が分岐完了後に遅れること，ディスパッチや特権レベル変更命令が予測器の更新を待たないこと，これらは理にかなってる．でも，特権レベル変更の件は，予測時とコミット時のレベル一致保証がないと，異なる特権レベル間で予測状態が混ざる可能性があるのが気になる．パイプライン中の”現在の特権レベル”って曖昧だから難しそう？" userName="eigenform" createdAt="2025/05/13 21:07:51" color="#45d325">}}




{{<matomeQuote body="Kaveh Razavi の名前を見れて嬉しいな！彼，僕が Vrije Universiteit にいたときアムステルダムで教えてたんだよ Hardware Security って授業，マジでやばいくらい面白くて，この記事みたいな内容を深く掘り下げてたんだ．" userName="mettamage" createdAt="2025/05/13 16:58:30" color="">}}




{{<matomeQuote body="このコース（あと Vrije のマルウェアのやつ）を数年前にチェックしたことあるんだけど，その頃はコースに関する公開情報がほとんどなかったんだよね．公式な録画とかノートってオンラインにあるか知ってる？事前にサンクス．" userName="markus_zhang" createdAt="2025/05/13 17:38:38" color="">}}




{{<matomeQuote body="僕が知る限り，コース資料は公開されてないんだ． VUSEC グループのコースでは実習課題がすごく重要で，残念ながらコースのインフラがないとリモートでやるのは難しいんだよね． 君が言ってた Binary and Malware Analysis のコースは， Dennis Andriesse の本 ”Practical Binary Analysis” をベースにしてるから，興味あるならその本を手に入れるといいかも．" userName="thijsr" createdAt="2025/05/13 20:30:17" color="#45d325">}}




{{< details summary="もっとコメントを表示（1）">}}

{{<matomeQuote body="あーそうだ，彼がボットネットをどうハッキングしたかっていうゲスト講義もしてたな！詳しくはここ見てみて： https：／／krebsonsecurity．com／2014／06／operation−tovar−targets−．．．もうずいぶん前の話だけどね" userName="mettamage" createdAt="2025/05/13 20:47:39" color="">}}




{{<matomeQuote body="委託学生って手があるよ．料金は状況次第． Vrije のコース内容を大まかに教えるね： Hardware Security では Flush／Reload， Spectre， Rowhammer とか研究論文の実装・読解． Binary ＆ Malware Analysis は IDA Pro， Taint analysis， Intel PIN， Triton を使った解析・クラッキング． Computer ＆ Network Security は Web／App／Network Security（パケットスニファ作成， Kevin Mitnick 攻撃），Cの脆弱性探し（stack／heap overflows， format strings bugs）．実践的で超濃い内容だった． Binary／Network security は hackthebox．eu おすすめだけど， Hardware security の代替は知らないな．" userName="mettamage" createdAt="2025/05/13 20:45:16" color="#785bff">}}




{{<matomeQuote body="うわー，詳しい回答マジサンクス．委託学生として登録できるか見てみるよ，でも多分リモートは受け付けてないだろうな．そういや，当時めっちゃモチベーション高かったんだね．かなり大変だったろうけど，乗り越えたんだね．おめでとう！" userName="markus_zhang" createdAt="2025/05/14 00:25:12" color="">}}




{{<matomeQuote body="どっちもSpectre V2は悪用してるけど、やり方が違うんだよ。俺の考えだとね：<br>Training Solo：<br>- Kernelに入って（権限レベルを変えて）、disclosure gadgetへブランチを誤予測させるように”自己学習”させてメモリを漏洩させる。<br>Branch predictor race conditions：<br>- trained branch predictorの更新がまだ処理中のうちにKernelに入って、その更新が間違った権限レベルに関連付けられるようにする。これでまたKernel内のブランチをdisclosure gadgetにリダイレクトして、メモリを漏洩させるんだ。" userName="hashstring" createdAt="2025/05/14 07:44:16" color="#785bff">}}




{{<matomeQuote body="もしCPUのbranch predictorが、バッファ境界とかコードの権限レベルをチェックできる情報をすぐ持てたら、こういうのはもっと簡単に防げたはずなのにね。でも、それはC言語プログラマーの手からvoid*を無理やり剥ぎ取って、ポインタに大事な情報を持たせるようにならないと実現しないみたいだ。" userName="rini17" createdAt="2025/05/13 17:26:19" color="">}}




{{<matomeQuote body="あるいは、みんなが問題の範囲をもっとよく理解して、脆弱性があるからって直接攻撃につながるわけじゃないって気付くべきだよ。投機的実行のExploitは、低レベルコードを実行できるコンピューターに直接アクセスできる場合だけ現実的で、JSコードでブラウザから任意の秘密を漏洩できるわけじゃない。Exploitする価値があるシステムは、許可されていない任意のコードが実行されないシステムであるべきだ。個人的には、パフォーマンス向上が体感できるから、全ての緩和策を無効にしてる。" userName="ActorNightly" createdAt="2025/05/13 19:29:26" color="">}}




{{<matomeQuote body="＞ JSコードを書いてブラウザで動かして、任意の秘密を漏洩させられるわけじゃない<br>SpectreやMeltdownってまさにそれだったじゃん。この攻撃が現代のブラウザでも動くかは不明だけど、SharedArrayBufferは再び有効になったし、既存のSpectre/Meltdown対策でこの攻撃が防げるかも不明だよ。<br>＞個人的には、パフォーマンス向上が体感できるから、全ての緩和策を無効にしてる<br>おめでとう、あなたのマシンではJSコードが暗号キーを読み取れる可能性が高いね。" userName="vlovich123" createdAt="2025/05/13 20:01:22" color="#38d3d3">}}




{{<matomeQuote body="インターネットからの任意コードを実行しない内部システムなら、一部の緩和策を無効にするのは理にかなってるね。ビルドサーバーとか、ロードバランサーとか、ステートレスなAPIサーバーとか、他のテナントと共有されてない物理マシンのVMじゃない限りは。" userName="nine_k" createdAt="2025/05/13 21:36:12" color="">}}




{{<matomeQuote body="JSを有効にしたウェブブラウザを使ってる時点で、”インターネットからの任意コード”を実行してることになるんだよ。" userName="anyfoo" createdAt="2025/05/13 22:09:34" color="#ff33a1">}}




{{<matomeQuote body="＞ みんなが問題の範囲をもっとよく理解するべき<br>あなたこそ理解してる？Dragnet攻撃で個人的に影響されないって知ってるの？<br>だって、あなたのこの主張：<br>＞ JSコードを書いてブラウザで動かして、任意の秘密を漏洩させられるわけじゃない。<br>Spectreにとっては真実じゃなかったんだから。オリジナルのSpectre論文はJSを攻撃ベクターとして有名に挙げてる。もし全ての緩和策を本当に無効にしてるなら、その穴をまた開けてるってことだよ。だから：<br>＞ これを使える唯一現実的な方法は、低レベルコードを実行できるコンピューターに直接アクセスできる場合だけだよ。<br>俺は低レベルのKernelエンジニアだけど、これが一般的なケースで真実だとは知らないね。JITも”低レベルコード”を生成してるんだよ。これが十分じゃないってどうしてわかるの？" userName="anyfoo" createdAt="2025/05/13 22:13:06" color="#38d3d3">}}




{{<matomeQuote body="＞ 問題の範囲を理解してる？Dragnet<br>問題はそれが俺に影響するかじゃなくて、リスクがどれくらいかだよ。リスクは非常に低いって断言できる、俺の方がこの分野をよく理解してるみたいだから。<br>＞ オリジナルのSpectre論文はJSを攻撃ベクターとして有名に挙げてる。<br>たとえるなら、攻撃ベクターは特定の種類の武器、Exploit実行は戦争。Log4Shellは携帯ショットガンみたいに簡単だけど、Spectre/Meltdownは環境に強く依存するブービートラップ。JSのキャッシュタイミングは難しい。もちろん絶対確実はないが、ブラウザコードは公開されてるからブラウザの脆弱性は低い。" userName="ActorNightly" createdAt="2025/05/14 21:04:29" color="">}}




{{<matomeQuote body="まさにこれが、ほとんどのインフラボックスではやらないことだよね？もしボックス上の全てのソフトウェアを合理的に信頼できるなら、アドバーサリーコードがマシン上で実行された影響から守る多くの緩和策は不要になる。<br>一方、アドバーサリーがボックス上で低権限RCEを取得した場合、SpectreやRowHammerのようなものを悪用すれば、権限レベルを昇格させるのに役立ち、他のインフラへの攻撃をより簡単に仕掛けることができる。" userName="nine_k" createdAt="2025/05/13 22:57:35" color="">}}




{{<matomeQuote body="それ、どうやって役に立つと思ってんの？ソフトウェアの話じゃなくてハードウェアの話だよ。ポインタ変えてもトランジスタは変わんないし。君が求めてるのは、ロード/ストアごとにバウンダリ情報を持つ”拡張アドレス”を通るみたいなハードウェア。つまり80286のセグメンテーションのこと。あれあったけど、君の求めることは無理だったじゃん。だってセグメントディスクリプタをロードするソフトがミスしないわけじゃないからね。”ただのポインタ”だから、同じ間違いをするんだよ。" userName="ajross" createdAt="2025/05/13 17:38:10" color="#38d3d3">}}




{{<matomeQuote body="『おめでとう、JSで暗号キー読まれるかもね。AIに仕事取られるの怖がってるわけだ（笑）』全然違うって。JS変数からキー取るには1. サイトにJSコードを注入する方法を見つける（今難しい）2. 特定のメモリアドレスを知る必要がある（変数名ランダムだし）3. キャッシュがエビクトされる必要（プロセッサ依存、Webアプリの状態も）JSだとメモリレイアウト推測して、分岐予測器訓練も必要で時間かかる。だから、キャッシュ攻撃より物理的に強盗に遭う方がよっぽど可能性高いって。Spectre/Meltdownみたいに、この手の攻撃は実世界であまり見ないよ。特定のプロセッサ狙って、任意のコード実行できないと、キャッシュタイミング攻撃を正しく動かすの超難しいから。" userName="ActorNightly" createdAt="2025/05/14 20:40:02" color="#45d325">}}




{{<matomeQuote body="えー、Same-Originとかインジェクション攻撃が前提ってのが分かんないな。どっかのリンク踏んで適当なサイト見るだけでいけないの？" userName="anyfoo" createdAt="2025/05/14 22:40:40" color="">}}




{{<matomeQuote body="君は、特定のサイトのデータに興味があって、同じサイトで攻撃する必要があるって考えてるみたいだけど、この脆弱性はシステム内のどこでもメモリ読めちゃうんだよ。PoC（https://www.youtube.com/watch?v=jrsOvaN7PaA）は/etc/shadowをメモリから探してダンプしてるのを見せてる。JSでできるかは分かんないけど、もしJSでできるなら、他のサイトにコード入れたり、アドレス知る必要なんてないんじゃないかな？（もしJSで無理なら、この話は無意味だけどね）" userName="anyfoo" createdAt="2025/05/15 00:24:58" color="#38d3d3">}}




{{<matomeQuote body="それは、他のサイトのデータが入ってるJS変数なんてないんだから、そのサイト自身が置いた秘密を盗むだけに制限されるでしょ。" userName="ActorNightly" createdAt="2025/05/15 03:22:12" color="">}}




{{<matomeQuote body="『システム内の任意のメモリを読み取れる』<br>PoCはコンパイルされたCコードだよね。システムで動くCコードと、ブラウザの中で動くJSコードが違うってこと、説明いる？" userName="ActorNightly" createdAt="2025/05/15 03:58:55" color="">}}




{{<matomeQuote body="そうだよ、この脆弱性は最悪、システム内のどこでもメモリ読めちゃうって話だろ？特定のサイトとかブラウザの中だけじゃなくて。" userName="anyfoo" createdAt="2025/05/15 03:56:14" color="">}}




{{<matomeQuote body="うん、前のコメントでも言ったけど、ちょっと君のコメント読み違えてたわ。インフラ系の箱で「マシンの全て持ってる」みたいなのは本当。でも、例えばDBサーバーの注意もね。信頼レベル違うアカウントが使う共有DBサーバーはヤバいかも、ストアドプロシージャとかある場合。結局、誰でもアクセスしていいわけじゃないデータが箱にあるなら、超注意しないとね。" userName="anyfoo" createdAt="2025/05/13 23:01:01" color="">}}




{{<matomeQuote body="それって使えるgadget次第じゃないの？CもJSもマシンコードになるんだし。個人的には、最悪の場合、カーネル近くまで行って（PoCがシステムコールでやるみたいに）、タイミングサイドチャネルでカーネルのメモリを誤予測させて漏洩させられない、なんて信じないね。最近のカーネルはほとんどの物理メモリをマップしてるし（64bitだと楽だしね）。詳しい理由はここに書いたよ: https://news.ycombinator.com/item?id=43991696" userName="anyfoo" createdAt="2025/05/15 04:23:43" color="#ff5c5c">}}




{{<matomeQuote body="自分の誤解を認めつつ、多くのPCは任意コード実行しないと思ってる人でも影響受けるよ。DBサーバーもstored procedures（PL/SQLみたいなやつ）とかで任意コード実行に注意しないとね。" userName="anyfoo" createdAt="2025/05/13 22:51:15" color="">}}




{{<matomeQuote body="ちょっと違うよ。この脆弱性は直接アドレスできるメモリを読むんだ。任意コード実行できるなら理論的には全メモリ空間だけど、ASLRとか仮想メモリで実際は難しい。JSはもっと制限多くて、任意のアドレスにポインタでアクセスできないんだ。" userName="ActorNightly" createdAt="2025/05/15 04:34:18" color="">}}




{{<matomeQuote body="JSにはシステム上の任意メモリにアクセスできる仕掛けはないよ。配列の境界外はできるけど、JSエンジンの翻訳層があるから生のメモリは直接扱えないんだ。web assemblyでもね。" userName="ActorNightly" createdAt="2025/05/15 04:44:41" color="">}}




{{<matomeQuote body="サプライチェーンリスクもそうだし、多層防御って考え方も大事だよね。物理的に分けるのが一番シンプルかな。この手の攻撃は、ひとつの仕事だけしてる専用マシンにはあんまり関係ないんだ。" userName="baobun" createdAt="2025/05/14 00:31:03" color="">}}




{{<matomeQuote body="JS無効にしたら？ HTMLだって表現力は低いけど「インターネットからの任意コード」みたいなもんだし。" userName="dwattttt" createdAt="2025/05/13 22:47:22" color="">}}




{{<matomeQuote body="JSコードが攻撃のために任意メモリを指す実際のポインタを作らないといけない理由がまだよくわかんないな。良性の適当な整数値をカーネルに渡して、それがポインタとして使われるコードに誤予測させるんじゃないの？ このリンクに詳しく書いてあるよ： https：//news.ycombinator.com/item？id=43991973" userName="anyfoo" createdAt="2025/05/15 04:58:15" color="#785bff">}}




{{<matomeQuote body="このスレッド読んでるとさ、“single-tenant”って言葉の意味を脆弱性との関連でかなり誤解してる人が多い気がするな。" userName="vlovich123" createdAt="2025/05/14 09:00:32" color="">}}




{{<matomeQuote body="ハードウェアウォレットいっぱいあるのに、今どき誰が自分のPCに暗号キー置いとくかな？" userName="gblargg" createdAt="2025/05/14 06:15:25" color="">}}




{{<matomeQuote body="Spectre素人だけど、有効なポインタは絶対必要？ 実際には動かないコードでも、それをポインタとして使うコードに誤予測させればいいだけじゃない？ 論文のC PoCはsystem callを仕掛けに使って、良性の値がチェック前に誤予測した情報漏洩コードでポインタとして使われる例を示してる。JSから直接system callは無理だけど、良性の値が間接的に渡されて、別のカーネルパスでポインタとして使われる誤予測が起きる可能性はないの？ 物理メモリのほとんどはカーネル空間だから、それができればほぼ任意メモリに影響できるはず。難しいのはわかるけど、不可能？ Spectreってヤバすぎるから、ハードウェアで直さないと、単に難しくなるだけで、十分難しいの？ ASLRは論文で破ってるよ。" userName="anyfoo" createdAt="2025/05/15 04:56:06" color="#ff33a1">}}

{{</details>}}




{{< details summary="もっとコメントを表示（2）">}}

{{<matomeQuote body="JSだと配列超えてどのくらい先が必要か分かんないし、最初の値のメモリ位置も不明。割り当てられた場所から後ろ向きに読めるけど、運良くキャッシュ追い出せて他のアプリをかわせたとしても、残るのはランダムな値で鍵は特定不能。Cコードならメモリを直接参照できるからなんとかなるんだけどね。" userName="ActorNightly" createdAt="2025/05/15 07:05:53" color="#ff33a1">}}




{{<matomeQuote body="Intelのセキュリティ勧告だよ：https://www.intel.com/content/www/us/en/security-center/advi..." userName="layer8" createdAt="2025/05/13 17:33:17" color="#ff5733">}}




{{<matomeQuote body="AMDのハードウェアにも似たような穴あるのかな？投機的実行って、共有プロセッサ空間じゃパッチ当てるのめっちゃ難しい脆弱性っぽいから、AMDはどうやって避けてるんだろうって気になる。" userName="rtkwe" createdAt="2025/05/13 17:00:37" color="">}}




{{<matomeQuote body="著者のブログ記事によるとね：<br>＞Branch Privilege Injectionは非Intel CPUに影響ある？<br>＞いいえ。評価したAMDとARMシステムでは問題は見つかってないよ。<br>情報源：https://comsec.ethz.ch/research/microarch/branch-privilege-i..." userName="tmoertel" createdAt="2025/05/13 17:03:50" color="#ff5c5c">}}




{{<matomeQuote body="簡単に言うと、AMDが（脆弱性を）避けてるわけじゃないよ。投機的実行のサイドチャネルって一つの脆弱性じゃなくファミリー全体なんだ。今回のはIntelだけみたいだけど、Meltdownと同じで。でもAMDもオリジナルのSpectreには脆弱性があったんだよ。" userName="pdpi" createdAt="2025/05/13 17:10:38" color="#ff33a1">}}




{{<matomeQuote body="厳密には投機的実行自体は脆弱性じゃなく、今の高性能CPUには必要な仕組みなんだ。でも複雑だからエンジン内のバグは多い。<br>AMDやARMにも似たバグあるはず。Intelで見つからなかった期間を考えてみてよ。唯一の解決策は、現代システムじゃコード隔離できないって認めること。これは一部企業のビジネスモデルに打撃だろうね。" userName="bee_rider" createdAt="2025/05/13 17:16:39" color="#38d3d3">}}




{{<matomeQuote body="＞現代システムじゃコード隔離できないって認めるのが唯一の解決策<br>VMをハードウェアコア（SMT含む）に固定するのは、今回のケースを直す？これで多くのサイドチャネル攻撃に対処できたと思ってた。<br>理想的じゃないけど、ハイエンドCPUのコア数が増えてる時代には悪くないよね。" userName="fc417fc802" createdAt="2025/05/13 23:28:27" color="">}}




{{<matomeQuote body="これカーネルメモリ読めるなら、VMはホストカーネルとか中のセキュリティキー読めちゃうんじゃない？<br>あと、コアピンニングで攻撃が同じコアの別CPUアクセスに限定されるってのも、サイドチャネル攻撃ではあんまり聞かない話だけど。" userName="vlovich123" createdAt="2025/05/14 09:05:07" color="#38d3d3">}}




{{<matomeQuote body="たぶん違うんじゃないかな。<br>このエクスプロイトは共有されてるメモリをウォークできるって感じみたいだけど？" userName="everfrustrated" createdAt="2025/05/14 07:25:06" color="">}}




{{<matomeQuote body="でも、自分が動いてるコアでアクセスされてないメモリを外に出せるの？<br>ブランチ予測器って物理コアごとに一つだと思ってたし、この手のサイドチャネル攻撃は同じコアで別権限ドメインでやってることから漏れるんだとばっかり。" userName="fc417fc802" createdAt="2025/05/14 21:59:44" color="#ff5733">}}




{{<matomeQuote body="僕が言いたかったのは、こういう脆弱性を作らずにパフォーマンス向上を実現するのが難しい機能だってことだよ。" userName="rtkwe" createdAt="2025/05/14 14:28:47" color="">}}




{{<matomeQuote body="この脆弱性の解決策は僕には直感的だよ。<br>ブランチ予測器の更新をキューに入れる時に現在の権限レベルをスナップショットして、それがプロセッサの内部バッファを流れる間ずっとそのスナップショットも一緒に持たせるんだ。<br>ソフトウェアでもありそうな問題だし、同じ解決策だよね？" userName="quotemstr" createdAt="2025/05/13 18:27:51" color="#38d3d3">}}




{{<matomeQuote body="それ、実はうまくいかないんだよね。<br>分岐条件の評価は権限更新の場所から遠い場合も。<br>更新する「現在の状態」はなく、後でどうだったか認識するだけ。<br>CPUでデータ持ち運びは高コスト。<br>命令ポインタも使えない原因。<br>リタイア時更新も考えられるけど、それも危うい。<br>リタイアキューでの追跡やレジスタ確認が必要で、可能だけど少し難しいんだ。" userName="wbl" createdAt="2025/05/13 21:12:02" color="#785bff">}}




{{<matomeQuote body="（引用：こういう隙間を埋めるにはプロセッサのマイクロコード特別なアップデートが必要で、BIOSかOSアップデートでWindowsの累積アップデートに含まれるはず）<br>なんでWindowsだけ？Linuxユーザーはどうなるの？" userName="smartmic" createdAt="2025/05/13 17:53:05" color="">}}




{{<matomeQuote body="IntelはLinux向けマイクロコード更新をここ<br>https://github.com/intel/Intel-Linux-Processor-Microcode-Dat...<br>で配布してるよ。<br>ディストリビューションはそこから自動で取ってきて配布する設定になってる。<br>ただ、これらの特定の緩和策がもう入ってるかは、専門家じゃないから分からないんだ。" userName="ajross" createdAt="2025/05/13 18:26:41" color="#ff33a1">}}




{{<matomeQuote body="研究者たちはこれが CVE-2024-45332 って言ってるよ。<br>INTEL-SA-01247 がその CVE をカバー。<br>Microcode release 20250512 でその INTEL-SA が緩和済みらしい。<br>詳細はこの辺見てみて。<br>https://github.com/intel/Intel-Linux-Processor-Microcode-Dat...<br>https://www.intel.com/content/www/us/en/security-center/advi..." userName="yencabulator" createdAt="2025/05/14 15:06:30" color="#38d3d3">}}




{{<matomeQuote body="Ubuntu 24.04.2 で確認するとこんな感じだよ。<br>`dpkg -l | grep microcode`<br> ii  amd64-microcode 3.20231019.1ubuntu2.1 amd64 Processor microcode firmware for AMD CPUs<br> ii  intel-microcode 3.20250211.0ubuntu0.24.04.1 amd64 Processor microcode firmware for Intel CPUs<br> ii  iucode-tool 2.3.1-3build1 amd64 Intel processor microcode tool" userName="brokenmachine" createdAt="2025/05/14 04:47:33" color="#785bff">}}

{{</details>}}



[記事一覧へ]({{% ref "/posts/" %}})
