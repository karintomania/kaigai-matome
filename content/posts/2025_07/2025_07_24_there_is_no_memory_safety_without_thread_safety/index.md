+++
date = '2025-07-24T00:00:00'
months = '2025/07'
draft = false
title = 'スレッド安全なきところにメモリ安全はない！'
tags = ["プログラミング言語", "メモリ安全", "並行処理", "Go", "ソフトウェアセキュリティ"]
featureimage = 'thumbnails/red1.jpg'
+++

> スレッド安全なきところにメモリ安全はない！

引用元：[https://news.ycombinator.com/item?id=44672003](https://news.ycombinator.com/item?id=44672003)




{{<matomeQuote body="この手の話が出るとDropboxでのチームを思い出すな。Goサーバーでデータ構造への書き込み同期を怠り、新人エンジニアがセグフォを起こすのが通過儀礼だったんだ。Swiftにも同じ問題があって、データ共有時のセグフォを実証するプログラムを書いたよ。GoはRustやJavaのような意味でのメモリ安全じゃないのに、そう呼ばれるのは変だね。" userName="chadaustin" createdAt="2025/07/24 17:30:42" color="#ff5733">}}




{{<matomeQuote body="そう、問題は”RustやJava的な意味”のメモリ安全が、実際の用語の意味と違うことなんだ。”メモリ安全”はPLTの公理じゃなくて、ソフトウェアセキュリティの専門用語だよ。これはただ、お互いすれ違って話してるだけだね。Goプログラマーがこの区別を知らないわけじゃない。それは言語の前提、「共有ではなく通信で」の基礎だからね。もちろん、うまくいかなくて今のGoは多くを共有し同期も必要だけど、みんな分かってるよ。" userName="tptacek" createdAt="2025/07/24 19:40:28" color="#785bff">}}




{{<matomeQuote body="21世紀のプログラミング言語としては、Goで本来あるべきだったのに実現しなかったものが多いのは、ちょっとおかしいよね。だけど、DockerとKubernetesがあるからね。" userName="pjmlp" createdAt="2025/07/24 17:57:22" color="">}}




{{<matomeQuote body="確かに、二つのグループがすれ違って話してるね。これを明確にするのは重要だよ。「”RustやJava的な意味”のメモリ安全が実際の用語の意味じゃない」って、じゃあ実際の意味は何？ただ「実際に悪用されたバグがない」ってこと？Wikipediaの「メモリ安全」定義（バッファオーバーフローやUAFなどからの保護）では、Goはメモリ安全じゃない。設計で許容されてるからね。Goの選択はいいけど、JavaやRustと同じメモリ安全と主張するのは納得できないな。" userName="moefh" createdAt="2025/07/25 01:28:28" color="#ff5733">}}




{{<matomeQuote body="逆に、何の意味があるの？すでに山ほど、何でもあるような言語は存在するじゃん。同じ道に進まなかったからこそ、Goは誰も使わないようなマイナー言語の山に埋もれずに済んだんだよ。" userName="9rx" createdAt="2025/07/24 18:01:00" color="">}}




{{<matomeQuote body="あれは不自然な型混同バグだよ。アドレスがハードコードされてるから42hを読み出すわけで、普通のコードではやらないことだ。GoやPythonなど共有メモリ並行性を持つ言語のセキュリティ評価で、この記事の例を見せて「このコードはメモリ安全じゃない」と言っても、真剣に受け止められないだろうね。Rustの正確性に関するPLTの議論は邪魔しないけど、この記事のセキュリティ主張は実際には間違ってるよ。" userName="tptacek" createdAt="2025/07/25 01:49:03" color="#ff5733">}}




{{<matomeQuote body="誰も使わないマイナー言語にならなかった唯一の理由はGoogle、そしてDockerやKubernetesがGo headsをチームに入れてPythonやJavaからGoに書き換えた幸運のおかげだよ。例えば、Goのデザインに影響を与えたLimboやOberon-2なんかは、誰も知らないでしょ。" userName="pjmlp" createdAt="2025/07/24 18:05:12" color="">}}




{{<matomeQuote body="「42hを読み出すのはアドレスがハードコードされてるから」って言うけど、この例は簡単に任意のint2ptrキャストに変えられるよ。「Rustの型システムがないGoやPython、Java」って言うけど、PythonやJava、JavaScriptなんかはメモリ安全だよ。データ競合と「言語自体が壊れる」のを混同してるんじゃない？僕は「メモリ安全」の歴史は詳しくないけど、「型安全」はPLTで何十年も使われてるから、”安全”用語が全部セキュリティ分野とは限らないでしょ？Goがメモリ安全であるっていうあなたの定義は何？Wikipediaの定義（バッファオーバーフローやダングリングポインタなどからの保護）では、Goはそうじゃないよ。Goのその選択は全然いいんだけど、JavaやRustと同じ意味でメモリ安全だと主張するのは我慢できないね。" userName="ralfj" createdAt="2025/07/25 12:10:59" color="#ff5c5c">}}




{{<matomeQuote body="問題は、もっと恐ろしい値をハードコードできないことじゃなくて、攻撃者が値とアドレスの両方を制御するような、現実的なコードでのもっともらしいシナリオを証明する必要があることだよ。Goがメモリ安全な言語だと僕が主張し続ける理由をあなたが疑問に思うなら、ISRG（Internet Security Research Group）にも聞いてみてよ。彼らも同じことを言ってるからね。（メモを確認）https://www.memorysafety.org/ でね。" userName="tptacek" createdAt="2025/07/25 12:12:40" color="#785bff">}}




{{<matomeQuote body="Goがメモリ安全な言語だって俺が言い続けるのは何でかっていうなら、ISRGに聞いてみろって言うけど、ISRGの定義とGoは食い違ってるって。Goは境界外アクセスを防げないし。メモリ安全性の定義に”もっともらしい”とか”現実的”って言葉は入るのか？って疑問だよ。定義をハッキリさせてほしいね。" userName="ralfj" createdAt="2025/07/25 12:19:57" color="#45d325">}}




{{<matomeQuote body="Goのマップみたいな基本的な構造はスレッドセーフじゃないってGoの仕様に明記されてるのに、Dropboxでは一体何が起きてたのか気になるね。" userName="potato-peeler" createdAt="2025/07/24 18:38:23" color="">}}




{{<matomeQuote body="「メモリ安全性」がPLTの公理じゃないって言うけど、PLTで20年以上も使われてるんだぜ？お前は20年遅れてるよ。ソフトウェアがメモリ安全なら、（a）割り当てられたアドレス空間外を、参照しない、（b）コンパイラとリンカが作成したコード領域外の命令を実行しない、ってことだ。詳細はhttps://llvm.org/pubs/2003-05-05-LCTES03-CodeSafety.pdfを見てみろよ。" userName="Ygg2" createdAt="2025/07/24 21:56:47" color="#ff33a1">}}




{{<matomeQuote body="「みんなが理解してる」なんてありえないよ。理解してたらこんなバグが本番コードにゼロのはずだろ。C++勢が自分たちの言語を救おうとしてる問題点だね。完璧なコードを書けって言うけど、C++もGoも現状はそれしかない。参照外しとか簡単にミスできるんだからさ。" userName="socalgal2" createdAt="2025/07/25 02:39:57" color="#ff5c5c">}}




{{<matomeQuote body="それは違うよ。技巧的なコードで境界外書き込みやクラッシュを誘発できたとしても、それが「メモリ安全性」という一般的な概念に反するわけじゃないんだ。" userName="tptacek" createdAt="2025/07/25 12:21:08" color="">}}




{{<matomeQuote body="その定義だと、関連するバグが一切なければCプログラムでもメモリ安全ってことになるのかな？まあ実際には、みんな自分のプログラムにどんなバグがあるか全部は把握してないけどさ。" userName="Wowfunhappy" createdAt="2025/07/25 01:09:17" color="">}}




{{<matomeQuote body="同期しない書き込みがSEGFAULTになるのは驚きだよね。Panicやエラーじゃなくてさ。JavaやC#だと例外を吐くか、変な値で続行するのに。SEGFAULTはネイティブコードや生メモリAPIを明示的に使ってるか、ランタイムのバグを見つけた時しか起こらないはずだろ。Goは同期なし並行書き込みがあると完全にはメモリ安全じゃないってことだよ。" userName="tsimionescu" createdAt="2025/07/25 05:24:02" color="#ff33a1">}}




{{<matomeQuote body="Goが人気なのはそれだけじゃないと思うよ。最大の理由はランタイムだね。今のところ唯一、GC、高速起動、静的型付け、高速実行、マルチスレッドを全部提供してる言語ランタイムなんだ。Kubernetesみたいな自動スケーリングするマイクロサービスには最強の組み合わせだよ。Javaは起動遅いしメモリ食うし、.NETも似たようなもんだ。Pythonは遅すぎ、TypeScriptはシングルスレッド。RustやC++は手動メモリ管理だし。だからGoがKubernetes本体にも使われたし、みんなGoを選んでるんだ。言語設計自体は古臭いけど、ランタイムは他に類を見ないレベルなんだよ。" userName="tsimionescu" createdAt="2025/07/25 05:39:36" color="#ff33a1">}}




{{<matomeQuote body="Googleの強力な支援があったからこそ、Goは誰も使わないような忘れ去られた言語にならなかったんだよ。" userName="stouset" createdAt="2025/07/24 18:35:09" color="">}}




{{<matomeQuote body="でも、お前はDropboxのエンジニアがそういうバグを”通過儀礼”だって呼んでるスレッドに返信してるんだろ。それは、現実のコードで問題が頻繁に発生してるってことだよね。" userName="nicoburns" createdAt="2025/07/25 09:35:52" color="#ff33a1">}}




{{<matomeQuote body="安全性ってのは白黒はっきりしてるもんじゃないから、あんたのコメントは意味不明だよ。" userName="Mawr" createdAt="2025/07/24 17:45:11" color="">}}




{{<matomeQuote body="不整合なデータで動くよりは、Segfaultで止まった方がまだマシだろ。" userName="elcritch" createdAt="2025/07/25 07:55:57" color="">}}




{{<matomeQuote body="えっ？Dartは全然流行らなかったし、Carbonも忘れちゃいけない。誰かCarbon試した人いる？ Rustが同じくらいの時期は、みんな触ってたのにさ。Googleは全然プロジェクトを成功させてないし、むしろ邪魔になってるよ。" userName="9rx" createdAt="2025/07/24 19:13:09" color="#ff5733">}}




{{<matomeQuote body="共有アクセスでクラッシュする方が、安全なやり方だよね。" userName="adamwk" createdAt="2025/07/24 18:41:18" color="">}}




{{<matomeQuote body="JavaはRustが言う意味でのメモリ安全じゃないんだよ。" userName="gok" createdAt="2025/07/25 00:01:54" color="#38d3d3">}}




{{<matomeQuote body="それは別のスレッドで説明済みだよ。Dartの政治的背景を知るべきだし、Carbonはまだ構想段階なんだよ。" userName="pjmlp" createdAt="2025/07/24 20:27:30" color="">}}




{{<matomeQuote body="Swiftは今、これを直そうとしてるけど、遅くて大変な移行だね。最近まで安全じゃなかった、とんでもない量のunsafeなコードが世の中にはあるんだから。" userName="junebash" createdAt="2025/07/24 17:37:33" color="#785bff">}}




{{<matomeQuote body="もう一度言うけど、もしバグについての主張をするならいいよ、分かる。でも、素のGo言語コードにメモリ安全性のセキュリティバグがあるって主張するなら、それは全然違うよ。" userName="tptacek" createdAt="2025/07/25 03:26:51" color="#38d3d3">}}




{{<matomeQuote body="主に、それが以前のものよりも驚くほど改善されてたからだよ。前のやつは笑っちゃうくらい脆かったからね。" userName="shadowgovt" createdAt="2025/07/24 17:39:13" color="">}}




{{<matomeQuote body="unsafetyは二進法だって思うな。普通のエンジニアがわざわざコンパイラとかランタイムを騙そうとしなくても、普通にやって壊しちゃったら、それは安全じゃないって言えるね。" userName="kstrauser" createdAt="2025/07/24 17:51:32" color="">}}




{{<matomeQuote body="このコメントはRustコミュニティと他の言語コミュニティの哲学の大きな違いをよく表してるよ。他の言語ではエラーは仕方ないものとされてて、対策を講じたり検出・回復の仕組みを作るんだ。でもRustでは、コードは安全であるべきで、コンパイル時に可能な限り正しさを証明しなきゃいけないって考え。これがRust開発者の真面目な態度につながってるんだけど、現実にはほとんどの人は特定のエラーをそこまで気にしてないんだよね。" userName="blub" createdAt="2025/07/25 10:51:06" color="#ff5733">}}




{{< details summary="もっとコメントを表示（1）">}}

{{<matomeQuote body="これは僕がZigについても感じてることの一つで、まるでスローモーションの衝突事故みたいに見てるよ。彼らはメモリ安全だと主張してるけど（安全な最適化レベルを使えば“十分安全”らしいけどね）、RustのSend/Syncみたいな型がないんだよね。実際には、並行的なZigコードをたくさん書く人がいなかったから、これまであまり問題になってないみたいだけど…今、第一級の非同期サポートを言語に戻そうとしてるから、それが来たら大量の足が撃たれることになるんじゃないかな。" userName="chc4" createdAt="2025/07/24 17:40:54" color="#ff5c5c">}}




{{<matomeQuote body="僕の理解が正しければ、シングルスレッドのZigプログラムでもReleaseSafeでビルドされてもメモリ破損の脆弱性がないとは保証されてないんだよ。例えば、もう存在しないローカル変数へのポインタをデリファレンスするのは、どの最適化モードでも未定義動作になっちゃうんだ。" userName="ameliaquining" createdAt="2025/07/24 18:18:44" color="#38d3d3">}}




{{<matomeQuote body="それはCやC++でも標準的なアドバイスだけど、それでもみんな頻繁にやっちゃって、CWEカテゴリになるくらいなんだよね。CWE-562を調べてみて。https://cwe.mitre.org/data/definitions/562.html" userName="ameliaquining" createdAt="2025/07/25 17:36:53" color="#ff5c5c">}}




{{<matomeQuote body="Zigのメモリ安全性の主張はひどい冗談だよ。Cよりメモリ安全性のバグを避けやすいのは確かだけど、それはC++も同じでしょ？誰もC++をメモリ安全な言語だって言わないよね。" userName="cibyr" createdAt="2025/07/25 02:22:25" color="">}}




{{<matomeQuote body="これは時々話題になるRustの健全性問題に少し似てるね。公平に言って、これは正当な問題で、事故でも簡単に起こせる。Rustの健全性問題は、僕が知る限りほとんど理解不能で、自然に遭遇する可能性は誰かの秘密鍵を当てるくらい低いからね。ただ、Goを何年もプロダクションで使ってるけど、このバグが起きるような状況に出くわしたことは一度もないよ。<br>UberはGoコードのバグについてたくさん話してる。このブログ記事は、Go開発者が実際に直面する実践的な問題、特に各問題の一般的な頻度をまとめた下の表を理解するのに役立つよ。https://www.uber.com/en-US/blog/data-race-patterns-in-go/<br>彼らはこの問題をカバーする特定のカテゴリを持ってないんだ。ほとんどの場合、並行的なmapやsliceへのアクセスは同じslice上で行われるからで、これはtorn readが発生する必要があるからね。なんで実践でそんなに問題にならないかって？うーん、正直言ってわからない。たぶん、みんなこの特定の落とし穴を避けるくらい用心してるんだろうね。まるでアメリカ人の延長コードや電源タップに対するTechnology Connectionsの理論みたいにね[1]。並行的に使われることがわかってる変数を再割り当てするのは、明らかに問題だし、言語にはアトミック、チャネル、ミューテックスロックがあるから、ほとんどの人は並行コンテキストではそれをしないんだ（少なくとも意図してはね）。レースディテクターは間違いなくそれを見つけるだろうね。多少のパフォーマンスヒットを許容するなら、torn readの問題は修正できるはずだよ。修正すべきだと思うけど、Goコードがプロダクションで動いてても僕は心配してない。大した問題になってないからね。<br>[1]: https://www.youtube.com/watch?v=K_q-xnYRugQ" userName="jchw" createdAt="2025/07/24 16:03:02" color="#ff5c5c">}}




{{<matomeQuote body="Goでデータレースを完全に解決するのに数ヶ月かかったよ。Race detectorも何も見つけられなかったし、誰も何が起きてるか分からなかったんだ。最終的にはループカウンターがオーバーフローして、同じことを何十億回も再計算してたんだよね（でも常に同じ結果！）。だから目に見える影響は、リクエストがランダムに100msじゃなくて3分かかるってことだった。僕はプラットフォーム開発者として変なものをデバッグする経験があったから、チームの助けを求められたんだ。この経験から、Goのたくさんのレースに直面したから、僕の偏った視点からは、どこでもRustを使いたいって思うね。でも、それじゃ自分の仕事がなくなるのかな？ ;)" userName="bombela" createdAt="2025/07/24 16:36:39" color="#38d3d3">}}




{{<matomeQuote body="本当のところ、Goでトリッキーな並行処理をしなきゃいけない瞬間、それはあまり魅力的じゃなくなると思うよ。GoはCよりもトリッキーな並行処理に向いてるけど、いくつか欠点もあるね（fat pointerやslice headerがどこにでもあるせいで、Goではtorn readの問題が忍び込みやすいと思う）。<br>Goは簡単な並行処理タスク、例えば共有メモリがほとんどない“shared-nothing”アーキテクチャ、典型的なウェブサーバーなんかには本当に向いてる。sync.Poolでデータベースハンドルみたいなリソースをいくつか共有して、それで終わりさ。Goは“async”コードをfunction coloringなしで同期的に書けるから、パフォーマンスクラスの他の言語と比べてもこのユースケースでは断然いい感じだよ。<br>一方、Rustはfunction coloringや、非同期の問題に対処するための本当に難しいエンジニアリングタスクに苦労するんだ。非同期Rustは年々良くなってるけど、個人的には（少なくとも先月時点では）まだかなりごちゃごちゃしてると思う。でもRustは伝統的な並行処理には絶対的に優れてるね。ミューテックスロックを使うようなものなら、Rustは他の何よりもずっといい。美しいよ。<br>だけど、Rust、標準ライブラリ、そしてそのエコシステムはプログラマーに心配事をたくさん与えるから、Goと同じくらい生産性を出すのに苦労するんだ。その点ではC++を思い出させることもあるけど、そこまで極端にひどくはないね（少なくとも一貫したビルドシステムとパッケージマネージャーはあるから）。それに率直に言って、僕が書くソフトウェアの多くはただの退屈なもので、Goで十分なんだ。時々Rustを試すんだけど、ロマンチックには“未来”に一番近い言語って感じるけど、未来にもGoみたいな言語の居場所があるんじゃないかな。" userName="jchw" createdAt="2025/07/24 16:47:26" color="#ff5733">}}




{{<matomeQuote body="Rustは退屈なコードでも問題ないし、生産性もGoと変わらないって言ってるね。Goみたいな言語はGCが必須な複雑な参照グラフの時くらいしか出番ないよ。基本的にはRustの方が高品質なソリューションになるって。" userName="zozbot234" createdAt="2025/07/24 17:01:46" color="#45d325">}}




{{<matomeQuote body="プログラミング言語で固定幅の数値がデフォルトでオーバーフローしちゃうのは残念だよね。AIの生産性も良いけど、言語レベルでこういう問題を直す方がデカいって。Rustはオーバーフローチェックしないけど、一応方向性は良いって感じ。" userName="norir" createdAt="2025/07/24 17:23:37" color="">}}




{{<matomeQuote body="「Rustは生産性でGoに劣らない」って意見は信じられないな。PythonからGoで生産性が50%も落ちるのに、Rustなんて論外だよ。複雑な並行処理とか、高い性能が必要なプロジェクトならRustもアリかもしれないけど、普段使いには向かないね。" userName="Mawr" createdAt="2025/07/24 17:57:30" color="#38d3d3">}}




{{<matomeQuote body="厄介な並行処理ってわけじゃなくて、単にゴルーチン間でポインタを共有しちゃったミスだよ。関数がパラメータを保持して、それをGoでクロージャとして使ったら、データ競合が起きちゃったって話さ。" userName="bombela" createdAt="2025/07/24 21:51:12" color="#785bff">}}




{{<matomeQuote body="記事の型システム回避を除けば、Rust以外の言語でスレッド使うのは現状と同じだよね。経験者は直接的なミスはしないけど、意図しない変数共有とかでバグは起きる。Goには静的解析ツールがあるし、個々のゴルーチンはメモリ安全だから、本番でのGoの並行処理バグはCよりマシだよ。2016年からGo使ってるけど、こんな単純なバグは稀だし、コードレビューで防ぎたいね。" userName="jchw" createdAt="2025/07/25 01:00:43" color="#ff5733">}}




{{<matomeQuote body="経験豊富なプログラマだって、バグの元凶と現象が離れすぎてると、本番でやらかすまで気づかないもんだよ。" userName="bombela" createdAt="2025/07/25 17:10:20" color="#ff5733">}}




{{<matomeQuote body="生産性が落ちるって言うのはわかるけど、言語のせいじゃなくて慣れの問題じゃない？Pythonは速いけどRubyは遅いんだ。俺はPythonもRustもGoもたくさん書いてきたから、どれも同じくらい生産的だよ。最初は全部遅かったけどね。" userName="sophacles" createdAt="2025/07/25 02:43:10" color="#ff33a1">}}




{{<matomeQuote body="Uberの事例から言うと、Goのレースコンディションってそんなに大したことないんだ。5000万行のGoコードで2000件見つかったけど、1サービスあたり1件くらいでしょ。深刻な障害に繋がることは少ないし、データ破損も稀。大抵は一時的な動作不良とか、サービスが再起動するくらいで済むんだ。だから、俺はGoのデータ競合で寝不足になったりしないよ。管理できる問題さ。" userName="jchw" createdAt="2025/07/25 17:50:40" color="#785bff">}}




{{<matomeQuote body="Rustは高品質なソリューションを出すけど、完璧なソフトは無理だよ。個人的にはRustと形式証明の組み合わせに興味あるね。でも、ほとんどのソフトでは完璧さよりも機能リリースが速い方が大事だから、Goには将来があるんだ。SaaS業界はGoの方が生産性で有利だろうね。" userName="jchw" createdAt="2025/07/24 17:36:05" color="#38d3d3">}}




{{<matomeQuote body="特定できる”いかれた”動作とか定期的なクラッシュって、俺にとってはマジで問題だよ。ミッションクリティカルなサービスじゃ絶対許されないし、根本原因分析が必要なんだ。それに、後からデータ破損とかセキュリティ侵害がないか確認するのも難しいからね。" userName="zozbot234" createdAt="2025/07/25 18:13:31" color="#ff5733">}}




{{<matomeQuote body="RustはGoより書くのが難しいって。ボローチェッカーとかライフタイムとかで気を使うことが多いからね。Goにはそういうのがないって言ってる。Rustがバグを防ぐのは確かだけど、Goのベテランならそのバグを避けるのは簡単で、そのコストはほぼゼロだって反論してるよ。Rustが有利なのは、データ競合のコストが高い場合に限られるってさ。" userName="brabel" createdAt="2025/07/25 07:37:57" color="#785bff">}}




{{<matomeQuote body="プログラミング言語における数値の扱いって、マジで業界の失敗だよね。サイレントオーバーフローとか単位がないとか、型変換で情報が失われるとか。1975年には、もっとちゃんとした数値処理ができるようになると思ってたのに、結局ずっとこのままだってさ。" userName="recursivecaveat" createdAt="2025/07/24 18:23:06" color="">}}




{{<matomeQuote body="ほとんどの人は「ミッションクリティカル」なソフトを扱ったことないって言ってるね。Rustでも全てのクラッシュや正確性の問題を完璧には防げないんだとさ。Ada／SPARKみたいにもっと厳密な言語が必要になるんだって。Ada／SPARKには興味あるけど、かなり奥が深そうで手が出しにくいみたいだよ。" userName="jchw" createdAt="2025/07/25 18:29:57" color="">}}




{{<matomeQuote body="「完璧で正確な数字」なんて、結局1/3とかsqrt(2)みたいなところで限界がくるってさ。実際は、どの程度で妥協するか、つまり「どの毒を選ぶか」って話なんだよ。" userName="tomp" createdAt="2025/07/24 19:33:23" color="">}}




{{<matomeQuote body="生産性のTCOをちゃんと計算するべきだって。PythonやGoは書くのは速いけど、Rustと同じTCOで運用はできないってさ。プロダクションのバグを直すのは、コードを書いた人とは違うことが多いから、PythonやGoの方が生産性高いって錯覚するんだって。Rustは、データ競合のないコードを書く負担を開発段階に移すことで、TCOを削減するって言ってるよ。" userName="dev_l1x_be" createdAt="2025/07/25 07:48:33" color="#45d325">}}




{{<matomeQuote body="SaaS業界では、Goで十分って言ってた人たちもRustを選び始めてるよ。ユーザーがめっちゃ増えて、1日に何十億ってリクエストをさばくようになると、めったに起きないバグでも頻繁に顔を出すようになるんだ。PagerDutyを静かに保つためにも、正確性を重視したプログラミングは大事ってこと。バグを許容するのはタダじゃないし、オフ時間に呼び出されるのはお金もストレスもかかるからね。インシデント中に焦るより、開発時にきっちりコストを払う方がいいってさ。" userName="sophacles" createdAt="2025/07/24 17:51:14" color="#45d325">}}




{{<matomeQuote body="「ミッションクリティカル」ってのは、「このソフトが落ちたり変な動きをすると、結構な金銭的損失が出る」ってのがちゃんとした定義だってさ。Ada／SPARKみたいな特殊な言語じゃなくて、普通のソフトでもそういうのって結構あるんだよね。人の命に関わる「安全クリティカル」とは違って、もっと身近な話だよって言ってる。" userName="zozbot234" createdAt="2025/07/25 18:34:24" color="#45d325">}}




{{<matomeQuote body="Rustはデバッグビルドだと、デフォルトでオーバーフローをチェックしてくれるんだって。" userName="devnullbrain" createdAt="2025/07/24 20:47:10" color="">}}




{{<matomeQuote body="Rustにもループカウンターのオーバーフローは存在するよ。" userName="Thaxll" createdAt="2025/07/24 18:55:06" color="">}}




{{<matomeQuote body="金銭的な話なら簡単だよ。バグでどれだけ損するか、どれくらい起こるか見積もればいい。Goの並行処理バグなんて、1万行に1つくらいで、5万行のコードでも5つくらいだよ。しかも、ほとんど影響ないかもしれないしね。コンピューターやネットワークは不安定だから、たまにリクエストが落ちたり、一部のデータにちょっとしたバグがあっても、ビジネス的に大した問題にならないことが多いって。Goのサービスを扱ってても、そういうのはほとんど心配してないってさ。" userName="jchw" createdAt="2025/07/25 19:42:32" color="">}}




{{<matomeQuote body="リリースビルドでもデフォルトでチェックしてほしいと俺はよく思ってるぜ。でもそれってパフォーマンスにペナルティがあるから、みんな不満なんだろ？<br>これって一般的なプロセッサアーキテクチャ（x86_64、aarch64）には、整数演算でオーバーフロー時にトラップする命令がないってことなのか？もし説明が本当にそれだけなら、かなりガッカリだよな。" userName="jeffparsons" createdAt="2025/07/25 01:32:16" color="">}}




{{<matomeQuote body="RustはGo（とか他のGC言語）より客観的に書くのが難しいって言うけど、ちょっと経験積めば、ほとんどの問題はなくなるぜ。共通のパターンやイディオムを使えば、ライフタイムやメモリ割り当てなんかをGC言語と変わらず意識せずにプログラム書けるんだ。<br>トリッキーなメモリ管理コードを書く時はGC言語じゃできないことだから、そりゃ意識する必要があるけどね。<br>RustはGoで書けるバグを防ぐから、Rustでの先行投資が報われるって主張するなら、俺には証拠があるぜ。Goで書いたものはバグ対応で何度も手直しが必要だけど、俺のRustのプロダクトは数年間も本番でガッツリ動いてて、バグのためにコードを見直したことがないんだ。Goコードで最初のインシデントがあった時点で、Rustで数週間余計にかかったコストなんて元が取れるし、2回目以降はもうお得としか言えないぜ。ビジネス上の損失考えたら、数週間の開発コストなんて屁でもないんだよな。<br>Goの熟練開発者はバグ回避を内部化してるから、防止コストはほぼ無視できるって？それって俺がRust経験についても言ってることと全く同じだぜ。俺はGoでもPythonでもRustでも生産性はほとんど変わらないんだ。<br>Rustの経験が浅い人は「データ競合のコストが高い場合にのみRustが有利」って言うけど、俺はそう思ってるね。彼らはRustを1週間試してやめて、長年使ってきた他の言語と比べてるだけだぜ。" userName="sophacles" createdAt="2025/07/25 15:45:20" color="#ff5733">}}




{{<matomeQuote body="2の平方根は計算可能な実数だ。俺たちがそれを扱わないことを選んでるだけで、不可能じゃないんだよ。単に不便なだけなんだ。俺のRustはこういう数も喜んで扱うぜ。例えば、10の平方根と40の平方根を掛け合わせたら、ごく普通の整数20になるだろ。<br>計算不能な実数はとんでもない問題だ。名前の通り計算できないからな。厳密にはほとんどの実数が計算不能だけど、お前が考えてるやつはどれも計算不能じゃないから大丈夫だぜ。<br>3分の1とか1605分の7みたいな単なる有理数なら、扱わないことを選択してるだけで、手の届かない場所にあるわけじゃないんだ。" userName="tialaramex" createdAt="2025/07/24 23:43:54" color="">}}

{{</details>}}




{{< details summary="もっとコメントを表示（2）">}}

{{<matomeQuote body="Uberの記事でGoプログラムが”Javaマイクロサービスと比較して8倍の並行性を露出する”って言ってるけど、”並行性”って数えられる名詞みたいに使ってるのはどういう意味だよ？" userName="qcnguy" createdAt="2025/07/24 16:41:56" color="">}}




{{<matomeQuote body="”コンピュータやネットワークは信頼できない。リクエストをたまに落とす、あるいは一部のリクエストで奇妙なバグがある”って言うなら、Golangはネットワークインフラの一部として、リクエストをバックエンドの他の部分に渡すだけで、”ロジック”を実装すべきじゃないって意味が暗に含まれてるみたいだな。だってそこで正確性の問題がビジネスに深刻な影響を与える可能性があるからな。色々と考慮すると、これはかなり手厳しい見方じゃないか？" userName="zozbot234" createdAt="2025/07/25 20:29:23" color="">}}




{{<matomeQuote body="”結局ループカウンターがオーバーフローして、同じことを10億回も再計算しちまった（しかもいつも同じ！）。その結果、リクエストがランダムに100msのところが3分かかるようになった”ってのは、複数のgoroutineが同じローカル変数に書き込んでたってことだろ。俺が働いてきたGoのチームでは、そんな構造のコードが普通と見なされたり、しっかりした理由なしにコードレビューを通ったりするなんて、ありえないぜ。" userName="wavemode" createdAt="2025/07/24 20:50:00" color="#ff33a1">}}




{{<matomeQuote body="Rustも生産性を高めるタイプのソフトウェアがあるけど、多くのSaaS店舗が扱うようなものだと、Goの生産性には勝てないだろうって？いやいや、ソフトウェア業界はクソSaaSだらけだよな。<br>Goがパラメトリックなenum（sum types）とOptionをサポートしてくれたらって、つくづく思うぜ。Hoareの億ドル級の過ちをコピーするんじゃなくてさ。<br>数年前、GoとRustの両方を試すためにコードを移植してみたんだ。Rustのコードはenumとmatch式を使えたから30％も小さくなったぜ。Goでは同じことを達成するために、いろんな型とinterface{}を作る必要があって、遅いし、冗長すぎた。Rustの実装はCの2/3のコード量でCと同じくらい速かったし、デバッグも楽勝だった。Goの実装はコード量が多くて、Cと同じくらいだったけど、Cより読みにくいし、ずっと遅かったね。<br>定型的なSaaSやプロトタイプなら、俺はTypeScriptが好きだぜ。ほとんどのことに十分速いし、型システムもすごく表現豊かで邪魔にならないんだ。Goみたいにデプロイが便利じゃないし、特にモバイルではね。標準ライブラリもごちゃごちゃしてる。でも俺の意見だと、はるかに良く設計された言語だと思うぜ。" userName="josephg" createdAt="2025/07/25 00:32:55" color="#ff33a1">}}




{{<matomeQuote body="Rustは6年くらい書いてるぜ。" userName="brabel" createdAt="2025/07/25 17:37:38" color="">}}




{{<matomeQuote body="これは虚偽だぜ。<br>ここで起きてるのは、他の多くの状況でもそうなんだけど、複雑なものを説明するために専門用語が作られたってことだ。この場合、”メモリ安全”は、スタックやヒープのオーバーフロー、use-after-free、型混同といったメモリ破壊の脆弱性を許さないプログラミング言語の特性を説明するものなんだ。その後、この用語の普及に関わってない人が、この用語を第一原理から定義しようとして、専門用語とは違うところにたどり着いたってわけだ。”ゼロトラストネットワーク”でも同じことが起きたな。<br>Goがメモリ破壊の脆弱性を認めないってのは事実だ。どうしてそれが分かるかって言うと、Goは人気言語なのに、純粋なGoプログラムを狙ったメモリ破壊の脆弱性に関するエクスプロイトが実質的にゼロだからだぜ。<br>同じ結論に達するもう一つの方法は、この記事の著者の議論が遠くまで行きすぎてるってことに気づくことだぜ。この著者の定義を使うと、他のほとんどの高級言語（著者はJavaだけは例外にしてるけど、実際はJavaだけだぜ）もメモリ安全じゃないってことになるんだ。<br>RustはGoよりある意味で”安全”なのか？ほぼ間違いなくそうだろうな。純粋関数型言語はもっと安全だぜ。”安全”という一般的な概念はプログラミング言語ではスペクトラムだ。でも”メモリ安全”は違う。これは閾値テストなんだぜ。ある言語がメモリ安全じゃないって主張するなら、POC || GTFOだぜ。（訳注：Proof Of Concept or Get The F**k Outの略）" userName="tptacek" createdAt="2025/07/24 16:04:14" color="#38d3d3">}}




{{<matomeQuote body="データ競合は、それら全てのメモリ破壊を許容するぜ。データ競合を許容して未定義動作（UB）につながるマルチスレッド対応の言語はメモリ安全じゃないんだ。もしGoがデータ競合を許容するなら、それはメモリ安全じゃないってことだ。もしプログラムが言語仕様が認識しない状態（SIGSEGVによる終了など）になりうるなら、それはメモリ安全じゃない。これがメモリ安全の唯一の合理的な定義だぜ。" userName="Sharlin" createdAt="2025/07/24 16:15:09" color="#38d3d3">}}




{{<matomeQuote body="もしそうなら、証拠を示して議論を支持できるはずだよ。" userName="tptacek" createdAt="2025/07/24 16:28:23" color="">}}




{{<matomeQuote body="記事にある、非ポインタを逆参照しないコードが、ランタイムに非ポインタを逆参照させるプログラムのこと？それって証拠に見えるんだけど。" userName="chowells" createdAt="2025/07/24 16:30:26" color="#38d3d3">}}




{{<matomeQuote body="メモリ破損に依存する、実際のGoプログラムに対するエクスプロイトだよ。" userName="tptacek" createdAt="2025/07/24 16:31:37" color="">}}




{{<matomeQuote body="そういうプログラムのエクスプロイトは作れるはずだけど、本当に危険な言語でもデータ競合からの脆弱性は稀で悪用が難しいんだ。Goはメモリ脆弱性から安全だと99%言える（国家のような強い組織がGoプログラムの悪用に本気を出したら不明だけどね）、でもWikipediaの定義によればメモリセーフではないよ。<br>＞ メモリ安全性とは、バッファオーバーフローやダングリングポインタなど、メモリアクセス時のバグや脆弱性から保護されている状態のことさ。" userName="afdbcreid" createdAt="2025/07/24 16:40:45" color="#ff33a1">}}




{{<matomeQuote body="エクスプロイトを作るインセンティブはすごくあるのに、なんで存在しないんだ？" userName="tptacek" createdAt="2025/07/24 16:42:34" color="#785bff">}}




{{<matomeQuote body="君は暗号の人だし、理論的には可能な脆弱性でも実際の攻撃者が使うのは難しいって知ってるだろ？Rowhammerみたいなハードウェア脆弱性もそう。サーバーサイド攻撃は、クライアントサイドと違って、バイナリ入手や攻撃の起動点が難しいから、実際の悪用例が少ないんだ。Goはサーバーサイドで使われることが多いから、この話は重要だよ。<br>GoはC++よりずっと安全だけど、競合状態と特定のコードパターンがあれば悪用は可能だ。マップもスレッドアンセーフって聞くしね。メモリ安全性の定義から言えばGoはメモリセーフじゃない。PoCで証明するのがベストだけど、今は忙しくて時間がないんだ。" userName="comex" createdAt="2025/07/24 17:41:17" color="#ff33a1">}}




{{<matomeQuote body="”言語がメモリアンセーフだと主張するなら、PoC出せ、さもなくば失せろ”って？投稿にPoCがあるじゃん。ファットポインタのティアードリードによるタイプ混同を示してるぞ。スライスのティアードリードによる範囲外書き込みも簡単にできたと思う。保守的な定義でも、これをメモリセーフだと真剣に言えるなんて信じられないな。実プログラムに対するPoCってこと？それが君の基準なの？" userName="jstarks" createdAt="2025/07/24 17:32:15" color="#785bff">}}




{{<matomeQuote body="クライアントサイドのGoもたくさんあるぞ！" userName="tptacek" createdAt="2025/07/24 19:39:21" color="">}}




{{<matomeQuote body="どこに？俺が言った”通常攻撃される消費者OSやクライアントサイドアプリケーションのタイプ”の中にってこと？それは大きなアプリケーションか大きなOSの一部、または同程度の規模じゃないとダメだ。そうでなきゃ、どんな言語でも現実のメモリ破損攻撃の標的にはならないだろうな。少なくとも俺の印象ではね。" userName="comex" createdAt="2025/07/24 20:05:23" color="#ff33a1">}}




{{<matomeQuote body="Goはメモリ破損脆弱性を認めないし、その証拠にGoプログラムを狙ったエクスプロイトが実質ゼロだろ？Goが13年も存在してて”Goはメモリ安全ではない”って今さらってことは、その主張が間違ってるか、誰もそんな重要な問題に気づいてないってこと。だから、13年間誰も深刻な安全性の問題に遭遇しなかった理由を説明する立証責任は、元の投稿者にある。理論的な問題を見せるだけじゃ、実際の問題にはならないよ。" userName="Mawr" createdAt="2025/07/25 16:49:53" color="#38d3d3">}}




{{<matomeQuote body="メモリ破損を引き起こすデータ競合のちゃんとした例が必要だね。それも、攻撃者がメモリを制御できるようになるような。単に「これ実行したらsegfaultした」じゃ足りないよ。Cコードでもそれだけじゃダメなのに！" userName="tptacek" createdAt="2025/07/24 19:34:03" color="#38d3d3">}}




{{<matomeQuote body="この投稿は、Goが“unsafe.Pointer”とか使わずに整数フィールドをポインタとして扱って、メモリにアクセスできちゃう問題を示してるんだ。これは、プログラミング言語の実装がメモリ安全かどうかって話だよ。Fly.ioのセキュリティページみたいに、言語がメモリ安全だって言ってるのに、期待と違う動作をするってこと。Goプロジェクト自体も、メモリ安全性を主張してるか明確じゃないけどね。URL: https://fly.io/docs/security/security-at-fly-io/#application..." userName="codys" createdAt="2025/07/25 02:12:20" color="#ff5733">}}




{{<matomeQuote body="別に目新しい話じゃないよ。Goが並行処理コードで完全にメモリ安全じゃないってのは、専門家の間じゃ前からよく知られてるんだ。以前のSwiftもそうだったしね。OPはそれを平均的な開発者にも分かりやすく説明してくれたってだけさ。" userName="zozbot234" createdAt="2025/07/25 16:57:39" color="">}}




{{<matomeQuote body="Goのissue 34902とかCVE 2020-15586とか見てみてよ。RCEのエクスプロイトがあった証拠は見たことないけど、それが不可能だって証拠もまだないんじゃないかな。URL: https://github.com/golang/go/issues/34902 URL: https://www.cloudfoundry.org/blog/cve-2020-15586/" userName="amluto" createdAt="2025/07/24 16:52:26" color="#38d3d3">}}




{{<matomeQuote body="例なら山ほど思いつくけど、真っ先に頭に浮かぶのはDockerエコシステムかな。" userName="tptacek" createdAt="2025/07/24 20:14:40" color="">}}




{{<matomeQuote body="君がコメントしてるスレッドで、このコメントが言ってることは全部もう議論済みだよ。もしうちのセキュリティページについて何か懸念があるなら、まずはISRG Prossimoプロジェクトに持っていくべきだと思うよ。URL: https://www.memorysafety.org/docs/memory-safety/" userName="tptacek" createdAt="2025/07/25 03:28:01" color="">}}




{{<matomeQuote body="このバグのどういうところが、エクスプロイト可能だと思わせるの？RCE POCを書いてほしいわけじゃないよ。ただ、このバグが攻撃者によって制御可能なコードにどう繋がるのか、その一連のストーリーを教えてほしいんだ。攻撃者は何を制御できて、それをどう使うの？" userName="tptacek" createdAt="2025/07/24 19:32:18" color="#785bff">}}




{{<matomeQuote body="君のセキュリティに関する経験が「メモリ安全」って言葉の解釈に影響してるんじゃない？特に、色々な問題がエクスプロイトに繋がるって要件のことね。メモリ安全の問題は、セキュリティ的な脆弱性以外にも、データ破損、間違った（でも安全ではない）動作、パフォーマンス問題とか、色々な問題を引き起こすんだ。インフォセック界隈はエクスプロイトばかりに焦点を当てがちだけど、他の問題もちゃんと考慮すべきだよ。" userName="sophacles" createdAt="2025/07/24 18:08:12" color="#ff5733">}}




{{<matomeQuote body="現代のアプリケーションのバックエンドがメモリ破損でエクスプロイトされるなんて、いつも起こってるよ。ただ、GoとかPython、Rustで書かれてるから見つけにくいだけ。それでも、CやC++ライブラリが不正なファイルをパースして脆弱になるようなエクスプロイトはたくさん見つかるよ。" userName="amluto" createdAt="2025/07/24 18:03:53" color="#ff33a1">}}




{{<matomeQuote body="誤解を招く用語とフレーミングを使って、これらがセキュリティ問題だって示唆してるけど、それは違うんだよ。「簡単に整数をポインタにキャストして、任意のメモリ破損を引き起こせる」なんて、できないから！著者は、Rustの正当性を示すために、不適切なセキュリティの枠組みを使ってるだけだよ。" userName="tptacek" createdAt="2025/07/25 17:15:17" color="#785bff">}}

{{</details>}}



[記事一覧へ]({{% ref "/posts/" %}})
