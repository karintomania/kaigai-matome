+++
date = '2025-06-01T00:00:00'
months = '2025/06'
draft = false
title = 'Progressive JSONとは？ データストリームと段階表示で快適UIを実現する考え方'
tags = ["プログラミング", "データ処理", "ウェブ開発", "UI/UX", "React"]
featureimage = 'thumbnails/purple4.jpg'
+++

> Progressive JSONとは？ データストリームと段階表示で快適UIを実現する考え方

引用元：[https://news.ycombinator.com/item?id=44147945](https://news.ycombinator.com/item?id=44147945)




{{<matomeQuote body="この記事を文字通り「Progressive JSON」っていうフォーマットを著者のDan Abramovさんが提案してるって受け取ってる人がいるみたいだけど、そうじゃないよ。<br>これはReact Server Components（RSC）のアイデアを説明する投稿に近いね。コンポーネントツリーをJavaScriptオブジェクトとして表現して、この記事に似たフォーマットで（機能も似てるけど、僕の知る限りbundlerとかframework固有かな）ワイヤーでストリームするんだ。<br>これでReactはツリーに（ローディング状態を表す）「穴」を持たせて、初回ロード時にフォールバック状態を表示できるし、サーバーが実際にデータを提供できるようになった後にだけ、ロードされたコンポーネントツリーを表示するんだ（つまり、フォールバックのスピナーやスケルトンをもっと速く、きめ細かく表示できるってこと）。<br>（細かく突っ込むと色々と間違ってるかもしれないけど、大筋は合ってると思うよ）" userName="goranmoomin" createdAt="2025/06/01 02:20:56" color="#ff33a1">}}




{{<matomeQuote body="うん！まぁ、正直言って、書かれてるアイデアを元にみんなが何か別のことをしても全然構わないと思ってるよ。RSCのデータシリアライズについて、あまりReactに特化してるように見えない形で説明したかったんだ。アイデア自体は実はもっと一般的だからね。RSCで僕が見たアイデアが他の技術にもっと広まったら嬉しいな。" userName="danabramov" createdAt="2025/06/01 02:27:12" color="#38d3d3">}}




{{<matomeQuote body="やあ、Danさん！すごく面白い投稿だね。<br>JSON-LDみたいに行ベースで、だからストリームできる、生成やパースがもっと簡単な新しいデータシリアライズフォーマットは、何か役に立つと思う？" userName="tough" createdAt="2025/06/01 04:20:48" color="">}}




{{<matomeQuote body="どうかな！そういう問題に直面してるか、それを解決する手段があるかに依ると思うな。RSCはまさにそのために設計されたんだ。だから僕はその設計の選択肢を説明しようとしたんだよ。もしシリアライザを作ってるなら、そのフォーマットの特性について考える価値はあると思うよ。" userName="danabramov" createdAt="2025/06/01 08:47:41" color="">}}




{{<matomeQuote body="素晴らしいね、ありがとう！問題には直面し続けてるけど、Danさんが言うように、レバー（手段）がないのが実装を難しくしてるんだ。<br>今のところ、LLMを呼び出すのに使ってるJSONツールをvLLMみたいに完全に制御できるものに置き換えるくらいしかできないかな。大手ラボはツール呼び出しごとに20-30％余計なトークンを課金して満足してるだろうから、JSONを置き換えることにはすぐには興味ないだろうね）。<br>それに、すでに標準になってる巨大なものと戦ってる感じもするし、引用符とか波括弧とかにトークンを無駄遣いしないことで20-30％余計なトークンウィンドウを稼げるような、本当に専門的なワークフローでなら居場所があるかもね（お金だけじゃなく）。<br>返信ありがとう！" userName="tough" createdAt="2025/06/01 18:15:07" color="">}}




{{<matomeQuote body="以前Reactを使っていくつかアプリやコンポーネントを作ったことがあるけど、RSCには詳しくないんだ。<br>すぐに頭に浮かぶのは、代わりにユニフォームな再帰ツリーを使うことかな。各ノードが同じフィールドを持ってるんだ。ちょっと考えるとDOMに似てるかもね。各ノードがそのタイプ、ID、名前、値、親ID、順番とかをエンコードするんだ。手前のエンジンがこれで汎用的に適切な場所に配置できる。<br>ここでそれが可能かどうかは分からないけど、ただの思いつきだよ。データ駆動のReact（や他の）アプリで似た構造を使ったことがあるんだ。<br>メモリ上でも効率的にエンコードできるんだよね。フラットでコンパクトな配列に入れられるから。SQL DBにもうまく収まるよ。" userName="dgb23" createdAt="2025/06/01 15:51:00" color="#ff5c5c">}}




{{<matomeQuote body="GraphQLにも似たような概念があるよ。例えば@deferとか@streamとかね。" userName="hn_throwaway_99" createdAt="2025/06/02 12:22:20" color="">}}




{{<matomeQuote body="プログレッシブローディングが嫌いなのって僕だけ？特にコンテンツが飛び跳ねるやつ。<br>そして一番イライラするアンチパターンは、ローディング中に空の状態のUIを見せることなんだよね。" userName="krzat" createdAt="2025/06/01 07:10:54" color="">}}




{{<matomeQuote body="その通り — だから、この記事の「https://overreacted.io/progressive-json/#streaming-data-vs-s...」のセクションで、意図的に設計されたローディング状態を強調してるんだよ。<br>記事からの引用：＞ データがストリームされるにつれて、ページが勝手に飛び跳ねることは実は望んでいません。例えば、投稿のコンテンツなしでページを見せたくないかもしれません。だからReactは保留中のPromiseに対して「穴」を表示しません。代わりに、最も近い宣言的なローディング状態を、＜Suspense＞で示されたものとして表示します。<br>＞ 上の例では、ツリーに＜Suspense＞境界がありません。これは、Reactはデータをストリームとして受け取りますが、ユーザーに「飛び跳ねる」ページを実際には表示しないということです。ページ全体が準備できるまで待ちます。<br>しかし、UIツリーの一部を＜Suspense＞で囲むことで、段階的に表示されるローディング状態を選択できます。これはデータの送信方法を変えません（できるだけ「ストリーミング」ですが）、しかしReactがいつユーザーに表示するかを変えます。<br>[….]＞ つまり、UIが表示される段階は、データがどう到着するかから切り離されているということです。データは利用可能になったらストリームされますが、私たちがユーザーに表示したいのは、意図的に設計されたローディング状態に従ったものだけです。" userName="danabramov" createdAt="2025/06/01 08:21:47" color="#38d3d3">}}




{{<matomeQuote body="SmalltalkのUIはCPUスレッド１つだけで動いてたんだ。ユーザーからのアクションがあるとUI全体が固まったけど、そのポジティブな側面は、それがすごく予測可能でバグがなかったことかな。SmalltalkはOOPだからそれがうまくいくんだね。<br>Reactは関数型プログラミングだから並列化とうまくいくし、実験の余地があるね。<br>＞ 特にコンテンツが飛び跳ねるやつが嫌い<br>これ、Androidの最初の方で覚えてるな。何か検索してクリックしようとしたら、クリックするまでに結果リストが変わって、別のものをクリックしちゃったんだ。一部のウェブサイトの広告でも起こるね、もしかしたら意図的に？<br>＞ ローディング中に空の状態のUIを見せる一番イライラするアンチパターン<br>質の低いソフトだと、検索が始まったり終わったりもしてないのに「検索結果はありません」って表示したりするよね。" userName="dominicrose" createdAt="2025/06/02 08:42:08" color="">}}




{{<matomeQuote body="SmalltalkのUIはシングルスレッドで動いてて、ユーザー操作があると処理中はUI全体が固まってたんだよね…。もしそうなら、プログラマーがGreen Threadsでミスったのかも！Smalltalk-80にはProcess、ProcessorScheduler、Semaphoreっていうマルチプロセスをサポートする3つのクラスがあるって、この本（https://rmod-files.lille.inria.fr/FreeBooks/BlueBook/Blueboo...）のp251に書いてあるよ。" userName="igouy" createdAt="2025/06/02 18:12:19" color="">}}




{{<matomeQuote body="「リモートデータ」パターンっていうのに興味あるかもね（もっといい名前がないんだけど）。この記事（https://www.haskellpreneur.com/articles/slaying-a-ui-antipat...）が参考になるよ。" userName="sdeframond" createdAt="2025/06/01 11:59:00" color="">}}




{{<matomeQuote body="クリックしようとしてる時にリンクとかボタンが動いちゃうよりは全然マシだよね。" userName="withinboredom" createdAt="2025/06/01 09:44:10" color="">}}




{{<matomeQuote body="あるいは、キャッシュとか他の最適化を使ってコンテンツをもっと速く提供する手もあるよ。" userName="ahofmann" createdAt="2025/06/01 08:07:11" color="">}}




{{<matomeQuote body="Emberもこれに似たことやってたけど、Ajaxエンドポイント作るのがめちゃくちゃ大変だったんだ。もうずいぶん前の話で用語は忘れちゃったけど、ファイルの最後に子要素を置いてたんだよね。DAGsを効率化するためだったと思うけど、幻覚かも。<br>でもSAXみたいなストリーミングパーサー使えば、初期データのロード中でも画面描画とかその後の処理を始められるかもね。<br>もちろんシングルスレッドVMだと、直接的なミスとかコード進化で処理順を間違えると、成功を台無しにしちゃうこともあるけど。" userName="hinkley" createdAt="2025/06/01 20:28:31" color="#45d325">}}




{{<matomeQuote body="AIツールの呼び出しでストリーミング部分JSON応答（Progressive JSON）を本番で使ってるよ。RSCsだけじゃなくて、他にも実用的な使い道がたくさんあるって、クライアントとサーバーをじっと見てると分かるんだ。" userName="vinnymac" createdAt="2025/06/01 03:11:29" color="#ff33a1">}}




{{<matomeQuote body="なんでそのアプローチが役に立つのか、もっと詳しく教えてくれる？<br>部外者からすると、そんなに解析に時間がかかるくらい大きなJSONドキュメントを送ってるなら、子リソースを分けてフェッチするか、ページネーションを実装すべきなんじゃないかって思うんだけど。" userName="motorest" createdAt="2025/06/01 06:51:21" color="">}}




{{<matomeQuote body="LLMの生成が遅い時は、Progressive JSONを段階的に表示するのが絶対必要だよ。" userName="Wazako" createdAt="2025/06/01 12:32:58" color="#45d325">}}




{{<matomeQuote body="一つのやり方は、断片が来たらすぐJSON.parseを呼ぶことだよ。引用符や閉じ括弧みたいなJSONの意味的な区切りで分割すれば、有効なオブジェクトを検知してストリーム中に処理を始められるんだ。" userName="danenania" createdAt="2025/06/01 18:11:10" color="#785bff">}}




{{<matomeQuote body="面白いやり方だね！共有してくれてありがとう。" userName="tough" createdAt="2025/06/01 18:16:56" color="">}}




{{<matomeQuote body="元のコメンターじゃないけど、俺もPydantic AIでやったことあるよ（実際はライブラリが勝手にやってくれる）。“Streaming Structured Output”はここを見てね：https://ai.pydantic.dev/output/#streaming-structured-output" userName="richin13" createdAt="2025/06/01 12:42:18" color="#45d325">}}




{{<matomeQuote body="ありがとう、知ってるよ！構造化出力はllama.cppもGBNFとかJSON以外の言語でも素晴らしいサポートがあるね。GoとかRustで作ろうとしてるんだけど、JSONだけよりずっと難しいよ。持ち越すコンテキストとか状態が多いから。" userName="tough" createdAt="2025/06/01 18:13:00" color="#45d325">}}




{{<matomeQuote body="Danの“2 computers”の話とか、RSCとその利点を探る最近の投稿を読んだよ。DanはReactエコシステムで最高の解説者の一人だけど、個人的には、ある技術を売り込んだり説明したりするのにこれほど頑張らなきゃいけないなら、2つの可能性が考えられる。<br>1/ その技術に本当の必要性がない<br>2/ 抽象化が欠陥だらけ<br>俺が知ってるほとんどのフロントエンド開発者がまだRSCを“理解”してないから、#2はある程度当たってる気がするね。Vercelはこれをユーザーに強く推してるし、RSCの採用のほとんどはNext.jsがデフォルトのReactフレームワークになってきたことによるものだよ。Next.jsユーザーの間でさえ、ほとんどの開発者はサーバーコンポーネントの境界を本当には理解してなくて、カーゴカルトになってるみたい。<br>さらに、ReactがViteをReactアプリを作る方法として言及するPRさえマージしようとしない事実と合わせると、RSCの全体的な推進が本当にユーザー/開発者のためなのか、それともベンダーが自分たちのホスティングプラットフォームを推し進めるためなのか、疑問に思えてくるね。S3からCDNでSPAを配信できるなら、それは明らかにVercelや世界中のNetflixみたいな企業にとっては良くないだろう。<br>振り返ってみると、Vercelが初代Reactチームの多くのメンバーを雇ったのは、単なる人材獲得じゃなくて、Reactの未来をコントロールするためだったのかもしれないね。" userName="jatins" createdAt="2025/06/01 05:46:53" color="">}}




{{<matomeQuote body="歴史的な側面や動機については間違ってるけど、今議論する気力はないし、別の投稿のために取っておくよ。（VercelがReactの方向性を決めてるわけじゃない。むしろ、Reactチームが定めた方向性の下で何人年もの作業に資金提供したのが彼らだ）。Viteについての主張だけ訂正させてくれ。作業は進んでるけど、ボールは主にViteチームのコートにあるんだ。DEVでバンドルしないとちゃんと動かないからね（そしてViteチームはそれを分かってて修正するつもりだ）。最新の進行中の作業はここにあるよ：https://github.com/facebook/react/pull/33152。<br>人が“理解”してない件についてだけど、君は一種の循環論法を使ってるね。それを反論するには俺が黙るしかない。でも俺は書くのが好きだし、興味深いトピックについて書きたいんだ！RSCが嫌いだったとしても、他の技術に取り入れられる面白い要素は十分にあると思う。今の時点ではそれが全てだよ。君に何かを納得させたいわけじゃなくて、人々にこれらの問題についても考えてもらって、解決策の中で好きな部分をパクってほしいんだ。ここの人たちはそれを気にしないみたいだしね。" userName="danabramov" createdAt="2025/06/01 08:28:20" color="">}}




{{<matomeQuote body="こういう解説をしてくれてることに感謝してるよ。そうすれば、ある種の解決策（特にそれが不自然だったり複雑だったりする場合）が必要とされる問題が何なのかを理解するために遠回りしなくて済むからね。<br>30年近くウェブUIを作ってきた者として（怖いね…）、概して幸運なことに、使ってるフレームワークが新しい機能やパターンを導入するとき、彼らが何をしようとしてるのか分かるんだ。でも、何をしようとしてるのか分かる唯一の理由は、彼らが解決しようとしている問題にぶつかるのに時間を費やしてきたからだよ。2015年に初めてGraphQLを見たとき、俺はそれを“理解”した。10年後、GraphQLを使ってる人のほとんどは本当には理解してないんだ。なぜなら、強制されたか、新しいキラキラしたもので選んだからさ。Suspenseやserver functionsなども同じだったね。" userName="andrewingram" createdAt="2025/06/01 12:02:35" color="">}}




{{<matomeQuote body="もちろん、君が言うように静的サイトをエクスポートして基本的なCDNでホストすることは今でもできるよ。そして、デフォルトの“dynamic”モードでNext.jsをセルフホストすることもできる。Expressサーバーを動かせればいいだけで、特定のベンダーに縛られることはほとんどないね。<br>少し論争になるのは、stale-while-revalidateベースで動くレンダーパスのためのサーバーレス関数を使って、Next.jsをフル機能モードで動かしたい場合だ。今はVercel以外の誰もそれを適切に実装するのはとても難しい（例はopennextjsプロジェクトを見て）。非公式な“魔法”があるからね。でもありがたいことに、Next.js / Vercelは、この機能を異なるプラットフォームで一貫したAPIで実装できるようにするアダプターを実装すること（そしてドッグフードすること）を提案してるんだ：https://github.com/vercel/next.js/discussions/77740<br>俺はRSCへの推進が君が示唆してるような怪しい理由で全く動機づけられてるとは思わないな。SPAフレームワークが支配的になる前に僕らがウェブサイトを作っていたやり方の良いところがたくさんあったという気づきについての方が大きいと思う。ほとんどのものをサーバーでレンダリングして、クライアントでちょっとしたプログレッシブエンハンスメントを加える、というのは多くのメリットがあるパターンだ。でもSSRでも、まだクライアントに属さない多くのロジックをプッシュすることになるよね。" userName="liamness" createdAt="2025/06/01 11:17:09" color="#ff5733">}}




{{<matomeQuote body="＞ ありがたいことに、Next.js / Vercelは、この機能を異なるプラットフォームで一貫したAPIで実装できるようにするアダプターを実装すること（そしてドッグフードすること）を提案してるんだ：<br>こういう取り組み（Vercelで働いてるNext.jsのメイン開発者が始めたもの）を見ると、VercelチームはReactエコシステムへの影響力を良い管理者として、そして一般的にコミュニティに有益なプレイヤーとして、正直にやろうとしてるんだって納得できるね。もちろん、VCから資金提供を受けてる会社としては自己奉仕が目的だけど、かなり立派にやってると思う。<br>とはいえ、プロダクションでNext.jsをサーバーの一部として動かすつもりは全くないな。太りすぎで複雑すぎるよ。Viteとその仲間みたいなもっとシンプルなものに置き換えるまでは、静的サイトジェネレーターとして使うことにするよ。" userName="lioeters" createdAt="2025/06/01 13:20:11" color="#785bff">}}




{{<matomeQuote body="IMO、技術を売る／説明するのにこんなに苦労するなら、2つの可能性があると思うんだ。1つ目は技術自体に本当は必要がない、2つ目は欠陥のある抽象化だ。<br>もちろん3つ目の可能性もあるよ。解決策がその複雑さを正当化する場合だね。<br>難しい問題には新しい直感が必要な解決策がある。<br>そう簡単に言えるけど、もっと分かりやすくすべきだとも言える。<br>今後どうなるか見守りたいね。" userName="throwingrocks" createdAt="2025/06/01 09:05:01" color="">}}




{{<matomeQuote body="RSCは技術としては面白いけど、実際にはあまり意味がないと思うな。<br>複雑なコンポーネントをレンダーするためにNodeやBunのバックエンドサーバーをたくさん持ちたくないんだ。<br>静的ページとか、GoのAPIサーバーを使ったReact SPAの方がいい。<br>ずっと少ないリソースで似た結果が得られるよ。" userName="metalrain" createdAt="2025/06/01 08:45:32" color="#785bff">}}




{{<matomeQuote body="バックエンド連携に便利だよ。サーバー側でasync/await使えるし、データ読み込みにフックやコールバックいらない。<br>動的な表示も可能だし（権限あるメニューだけ見せるとか）、一部表示しながら他を読み込むこともできる。<br>良いREST APIの方がエレガントで関心分離できてるけど、フロントとバック両方メンテするのは大変だからね。<br>だからこれは新しいPHPみたいだ。ダッシュボードとか、複雑で高トラフィックなwebshopみたいなサイトに良いんじゃない？顧客に早く最高の選択肢を見せたい場合とかね。クロール可能で低性能デバイスでも動くべきだし。" userName="pas" createdAt="2025/06/01 12:03:38" color="#ff33a1">}}




{{< details summary="もっとコメントを表示（1）">}}

{{<matomeQuote body="ページを表示するためにブラウザがAPI呼び出し（しかも相互依存してるやつもある）してる間、ユーザーがスピナーを見つめるのをどう避けるの？" userName="ec109685" createdAt="2025/06/02 07:39:34" color="">}}




{{<matomeQuote body="それは君にとって都合が良いだけだよ。すべてのReactユーザーが君と同じじゃないし。<br>僕にとっては実際にすごく意味があると思うな。" userName="presentation" createdAt="2025/06/02 12:21:52" color="">}}




{{<matomeQuote body="RSCsは静的デプロイやSPAsでも問題なく動くよ。（Nextのサイトは全部SPAsだしね。）" userName="robertoandred" createdAt="2025/06/01 18:46:19" color="">}}




{{<matomeQuote body="ユースケースごとに最適な技術スタックがある。Isomorphic rendering（NextJS, Nuxt, Sveltekitなど）はごく一部のケースにしか合わない。<br>多くの”ソートリーダー”は計算が合ってない。<br>初回訪問時、Nextアプリは個別コンテンツを提供できないから2回往復が必要で遅い。<br>AstroやSolid、Svelteのような速いSPAをCDNから、データをAPIから提供する方が初回は速い。<br>2回目以降はNextも速いけど、CDNからのアプリはキャッシュされててさらに速い！結局個別データは1リクエストだけ。<br>SEOの議論もおかしい。SEOならAstroで静的HTML作ってCDNで十分。クローラーは匿名リクエストの結果を見るから静的コンテンツで良い。<br>99%のユースケースは、従来のサーバーレンダリングMPA（Django, ASP.NET MVC）、速いSPA（Solid, Svelte, Vue）、SEOや初速が大事なら静的サイト（Astro）の方が良いと思うな。" userName="MaxBav" createdAt="2025/06/01 13:57:09" color="#38d3d3">}}




{{<matomeQuote body="RSCsのコード構造を使って、HTML, CSS, JSの小さな塊に分割された静的ページをコンパイルする世界があると思う。<br>基本的には、記事の”$1”プレースホルダーをURIsに置き換えればサーバーは不要。（ほとんどの場合、完全な動的SSRはいらない）<br>大きな欠点は、コンテンツ変更時の高速なビルドや更新のために良いパイプラインが必要なこと。コンパイル済み静的サイトのS3への部分的なストリーミングとかね。（例えば数千記事ある新聞で、CMSで著者が1記事編集したらそれだけ再コンパイルしたい。でもこれにはパイプラインがコンテンツ差分をうまく扱う必要がある）" userName="Garlef" createdAt="2025/06/01 07:46:58" color="#ff5c5c">}}




{{<matomeQuote body="RSCはビルド時に実行できるよ。それがデフォルトだし。<br>だから君が言ってることとそう遠くないよ。" userName="danabramov" createdAt="2025/06/01 08:43:14" color="">}}




{{<matomeQuote body="君の分析はすごく良いと思うし、Vercelみたいな会社がRSCを強く推してる理由にも納得だよ。" userName="kenanfyi" createdAt="2025/06/01 07:03:07" color="">}}




{{<matomeQuote body="話は逸れるけど、Next.jsはかなりすごいのに、Reactを書くときのデフォルトになったのは今でも意外だよ。TypeScriptは一番好きな言語だし、Reactも大好きなんだけど、Next.jsのアプリを書くのは全然楽しくないんだよね。" userName="chamomeal" createdAt="2025/06/02 15:29:31" color="">}}




{{<matomeQuote body="参考までに言うと、僕はNext.js開発者で、うちのチームのみんなはクライアントコンポーネントとサーバーコンポーネントに結構簡単に慣れたよ。ファイルの最初にマジック文字列のコメントを書くより、Haskellみたいなモナドとか（TypeScriptでもできそう！）何か別の方法だったら良かったかなとは思うけど、少なくともうちのチームでは大した問題にはなってないみたい。" userName="presentation" createdAt="2025/06/02 12:21:01" color="">}}




{{<matomeQuote body="パフォーマンスでよく見るのは、数MBのデータを取ってフロントエンドで複雑な処理をしながら、ミリ秒単位のページロード時間を削ろうとする人たち。実際はBFFを書いたりアーキテクチャやAPIを改善する方が生産的だよ。GraphQLやHTTP/2で試したけど、議論の余地はあるけどうまくいかなかったね。web標準が適切に進化しないと根本的な問題は解決できないと思う。新しいフレームワークも同じだよ。" userName="hyfgfh" createdAt="2025/06/01 05:17:17" color="#785bff">}}




{{<matomeQuote body="この記事の最後に説明されているRSCは、本質的にはBFF（APIロジックがコンポーネント化されたもの）だよ。このトピックに関する僕の長い記事はこちら: https://overreacted.io/jsx-over-the-wire/ （最初のセクションの途中にBFFがあるよ）" userName="danabramov" createdAt="2025/06/01 08:25:32" color="#45d325">}}




{{<matomeQuote body="でもそれだと、かなりの複雑さと肥大化、それに運用上の欠点が増えるよね。うまく設計されたAPI（Go、ASP.NET、Javaとか）と、クライアントサイドのグローバルなデータ管理なしで、コンポーネントごとにデータ取得する速いSPA（Solidとか）の方が、シンプルで速いんじゃないかな。CDNでアプリだけじゃなくデータもキャッシュできるしね。" userName="MaxBav" createdAt="2025/06/01 14:05:51" color="#785bff">}}




{{<matomeQuote body="それは「ミリ秒単位のページロード時間を削る」ってのが何を意味するかによるんじゃないかな？<br>最初の描画時間とか視覚的な完了までの時間を最適化するなら、できるだけロジックを使わずにページをレンダリングする必要があるよね。空のスケルトンを送って、後からAPIでユーザーデータをハイドレートするのが、ユーザーが感じるロードの速さには一番だよ。<br>もし最初の入力やインタラクティブになるまでの時間を速くしたいなら、ユーザーデータを使って実際に動くページを作る必要があって、それはバックエンドの方が速いことが多いよ。ネットワーク呼び出しが一番遅い部分だからね。個人的にはほとんどのユーザーは後者の方が好きだと思うけど、アプリによるかな。CRUDみたいなSAASアプリは多分サーバーサイドレンダリングが一番だけど、Figmaみたいなのはもっと静的なページを送って、フロントエンドからユーザーデザインデータを取ってくる方が一番だよ。<br>何でも一つの解決策でOKって考えは間違ってるよ。何を最適化するかは主観的な選択だからね。<br>それに開発体験、チームの構成、Conway’s lawとか、技術選定にすごく影響する色々な要素もあるしね。" userName="onion2k" createdAt="2025/06/01 06:20:29" color="#ff5733">}}




{{<matomeQuote body="＞空のスケルトンを送って、後からAPIでユーザーデータをハイドレートするのが、ユーザーが感じるロードの速さには一番だよ<br>これはよく言われるけど、僕自身の経験は逆なんだよね。ページにスケルトンローダーがたくさん表示されてると、だいたい悪い体験になるなって思う。サイトが遅くてカクカクしたり問題が起きやすそうだからね。サイトでスケルトンローダーが多いほど気分が悪くなるよ。<br>僕の推測では、FCPがGoodhart’s Lawの犠牲になってるんじゃないかな。多くのサイトがFCPを最適化しようとする（役に立たなくても画面に何かをすぐ出すってことね）あまり、UXは最適化してないんだよ。それがレンダリングを遅らせたり、コンテンツを後からロードするためにラウンドトリップを増やしたりすることにつながる。結果として、指標上は改善してるのに、より多くのロードや複雑さでユーザー体験は悪くなってるんだよね。" userName="MrJohz" createdAt="2025/06/01 08:43:32" color="#785bff">}}




{{<matomeQuote body="Progressive JSONって、ブラウザが頑張って実装してきた最適化、例えば戻る/進むボタンの動きとかを壊しちゃうんだよね。<br>RedditとかとSSRのページ比べてみ？全然違うから。" userName="PhilipRoman" createdAt="2025/06/01 13:52:11" color="">}}




{{<matomeQuote body="まあ、失われた機能も頑張れば取り戻せるけどさ、最初にブラウザに任せときゃ良かったじゃんってくらい、追加の作業が必要になるんだよね。" userName="MrJohz" createdAt="2025/06/01 14:51:34" color="">}}




{{<matomeQuote body="企業の95%くらいは、そもそも問題作った開発者に直させるお金をケチって、新しい機能だけをせかす感じだよね。<br>バック/フォワードボタンもまともに動かないSPAが多すぎて、マジでひどいよ。" userName="zelphirkalt" createdAt="2025/06/02 08:47:17" color="#ff33a1">}}




{{<matomeQuote body="＞体験が向上してるって。<br>あれ、たぶん離脱率が改善してるだけだと思うよ。<br>後でヤダなと思っても、何か早く見えれば人が留まる可能性上がるから。" userName="Bjartr" createdAt="2025/06/01 11:40:25" color="">}}




{{<matomeQuote body="＞最初の表示時間とかを最適化するなら...空のスケルトンを送って後でデータ入れるのが最速って。<br>これ、記事の著者が言いたいのは、こういう最適化って、マルチMBのデータって根本原因を見てないってことだと思うんだよね。<br>複雑にしても大元がデカいと、あんま意味なくなくない？" userName="motorest" createdAt="2025/06/01 06:56:55" color="#ff5733">}}




{{<matomeQuote body="＞最初の入力可能時間を早めるなら...バックエンドの方が速いって。<br>いや、それはスケルトンだけが速いんだって。<br>こういう2段階ロードのサイト使ってると、コンテンツが出ない、30秒待つ、ラグい、不安定、ナビ動かない、ボタン押しても反応しないとか。<br>マジ勘弁。凝った装飾いらないから、普通に動くサイトに戻ってくれー。" userName="FridgeSeal" createdAt="2025/06/02 01:22:20" color="#38d3d3">}}




{{<matomeQuote body="30秒は言い過ぎかもね、よっぽど回線遅くない限り。でも、他はわかるわ。<br>あれって2段階じゃなくて、もうn段階で読み込んでる感じだよね。" userName="zelphirkalt" createdAt="2025/06/02 08:56:10" color="">}}




{{<matomeQuote body="この記事読んで、Facebookのページって、なんで一番肝心なコンテンツが一番最後に表示されるのか、やっと理由が分かったよ。" userName="xiphias2" createdAt="2025/06/01 05:40:04" color="">}}




{{<matomeQuote body="Facebookのページ、俺の場合は一番肝心なコンテンツすら表示されないんだけどな…" userName="globalise83" createdAt="2025/06/01 19:53:47" color="">}}




{{<matomeQuote body="RSC（Server Components）のデカい利点って、重いライブラリをバックエンドで使って、その出力だけをフロントに送れることだよ。<br>これでページ表示がマジで速くなる。<br>例えばSyntax Highlighter。文法とかのコードじゃなくて、整形後のHTML/CSSだけ送れる。<br>同じ言語で書けて、ほぼ手間なし。<br>もしフロントでも使いたいなら、Client ComponentにするだけでOK。<br>Goとかで書かれてたらヤバいよね。" userName="presentation" createdAt="2025/06/02 12:23:20" color="#785bff">}}




{{<matomeQuote body="BFFってのは「backend for frontend」の略だよ。<br>各フロントエンドが必要なAPIだけを持つ専用のバックエンドって考え方ね。" userName="continuational" createdAt="2025/06/01 05:41:04" color="">}}




{{<matomeQuote body="組織的に考えると最悪だよ。<br>バックエンドのエンジニアが、フロントエンドの流行とか実績稼ぎ開発に振り回されるんだ。<br>複雑さがフロントエンドからバックエンドに移るけど、それはフロントエンド側での変な選択による自作自演の複雑さだったりする。<br>バックエンドAPIは、ページの表示や操作に必要なデータを提供することに専念すべき。それ以外は最適化であって、必要ないかもしれないんだ。" userName="zelphirkalt" createdAt="2025/06/02 09:11:53" color="#ff33a1">}}




{{<matomeQuote body="俺も同じ疑問だったよ。<br>FEはフロントエンド（UI）の略ね。<br>BFFはBackend For Frontendの略だよ。" userName="aeinbu" createdAt="2025/06/01 09:49:52" color="">}}




{{<matomeQuote body="フロントエンドと、フロントエンドのためのバックエンドのことね。<br>複数のAPIをまとめたり、キャッシュしたり変換したりして、特定のページに特化したAPIを設計するのが一般的だよ。" userName="holoduke" createdAt="2025/06/01 09:44:03" color="">}}




{{<matomeQuote body="別の考え方もあるよ。<br>データストリーミングはJSONが想定してる問題じゃないし、そうするべきじゃない。<br>もしものすごく大きなJSONを送る必要があるなら、「なんでそんな巨大なJSONを送ってるの？」って問い直すべき。<br>大体の場合、それはRESTを無視して、JSONを何でも屋にしようとしてる太ったクライアントのせい。<br>結局、データ送って、メタデータ足して、UI記述のメタデータまで足して、すごくダメなバージョンのRESTを再発明してるだけ。<br>解決策はJSONを変えることじゃなくて、問題の原因となる行為をやめること。多くのページに巨大なSPAフレームワークなんて必要ないんだ。" userName="usrbinbash" createdAt="2025/06/02 08:31:52" color="#ff5733">}}




{{<matomeQuote body="なぜこれが「問題を探してる解決策」なのか説明させて。<br>幅優先も一つのオプションだけど、JSONは様々な構造を持つデータ源だから、幅優先で早くレンダリングできるって保証はないんだ。<br>アプリはJSONの一部が必要だけど、それは単純な深さ優先や幅優先の最初の塊とは違う。<br>だから、JSONにURLやAPIの継続識別子を含めて、呼び出し側がどこをさらに掘り下げるか選べるようにするんだ。段階表示は、複数のリクエストに分けてデータを取ることで実現する。<br>JSONはオブジェクトに逆シリアル化されることが多いから、全体がないと使えない場合がある。だからやっぱり、複数のリクエストで小さいオブジェクトにするのがいい。<br>サーバーからJSONを取ってくるとき、普通は段階的ローディングを考えるほど大きくないはずなんだ。<br>HTMLは歴史的に大きくなりやすいから段階的ローディングが必要だった。それは静的だから大きな塊でロードしてキャッシュもできた。<br>でもJSONとそれを使うJavaScriptは状況に応じて変われる。それを使え。データを必要以上に取ってくるな。必要なものだけ読め。JSONは頻繁に変わるからキャッシュしにくいことも多い。だから大きな塊でロードしないもう一つの理由になる。<br>ちなみに、俺も参照を使った似たエンコーディングを持ってるけど、それは構造共有のためなんだ。俺のデータは木じゃなくてDAGみたいな形だから参照が必要でね。<br>幅優先エンコーディングだけど、段階的デコードは必要なかった。API層で必要なものを必要な時に正確に（またはそれに近く）リクエストすればいいからなんだ。" userName="3cats-in-a-coat" createdAt="2025/06/01 02:04:05" color="#785bff">}}

{{</details>}}




{{< details summary="もっとコメントを表示（2）">}}

{{<matomeQuote body="＞アプリはJSONの一部が必要だけど、それは単純な深さ優先や幅優先の最初のチャンクじゃない。<br>そうなんだよ。<br>記事の終わり近くでRSCにちょっと触れてるよね。<br>RSCではデータがUIそのものだから、一番外側のデータが文字通り一番外側のUIに対応してるんだ。それがうまくいく理由。<br>Progressive JSONみたいにエンコードされるけど、考え方はHTMLに近いかな。クライアント側で独自の「タグ」を持ってて、オブジェクト属性を受け取れる感じ。" userName="danabramov" createdAt="2025/06/01 02:16:34" color="#ff5733">}}




{{<matomeQuote body="＞記事の最後の方でRSCにちょっと触れてる。<br>またRSCかよ、もうやめてくれ。" userName="owebmaster" createdAt="2025/06/01 02:27:56" color="">}}




{{<matomeQuote body="そして、自分の考えをより広い読者に向けて公開する上で大事なのは、読者からのフィードバックをただ切り捨てるんじゃなくて、それを評価することなんだ :)" userName="kiitos" createdAt="2025/06/01 23:03:45" color="">}}




{{<matomeQuote body="これってもう既成事実だよね。彼らはもう全部実装済みなんだ。この段階でフィードバックを求めてるわけじゃなくて、どうやって、そしてなぜそれが動くのかを説明してる感じかな。" userName="yawaramin" createdAt="2025/06/02 04:25:03" color="">}}




{{<matomeQuote body="すごくクールな視点だね、これは一般的なツリー構造データ全般に当てはまるよ。<br>俺はツリーデータを親、タイプ、データそれぞれのベクトルと文字列テーブルを使って表現するのが好きで、そうすると他のものは全部小さな整数で済むんだ。<br>文字列テーブルとタイプ情報を最初のヘッダーとして送れば、その後には親とデータベクトルのチャンクを、まとめてNノードずつストリームで送れるんだ。<br>深さ優先でも幅優先でも、これはベクトルの順序次第で選べるよ。<br>これちょっと試してみないと！<br>ネットワークに負荷がかかるアプリケーションで、よりきびきびしたロード時間のUXを実現する一般的な方法になるかもね。" userName="xelxebar" createdAt="2025/06/01 01:32:54" color="#ff5733">}}




{{<matomeQuote body="テーブルとノードのチャンクを交互に送ることだってできちゃうんだ！<br>そうすれば、親より先に子を見せるとか、任意のグラフ構造を表現するとか、どんな順序でもツリーを表示できるようになるんだよ！<br>いくつか面白い応用につながるかもしれないね。" userName="thethimble" createdAt="2025/06/01 01:55:55" color="#785bff">}}




{{<matomeQuote body="いい点だね！親ベクトルの表現が任意のノード順序を可能にするんだけど、テーブルデータをノードIDのチャンクで分割するのは素晴らしいアイデアだよ。乾杯！" userName="xelxebar" createdAt="2025/06/01 02:58:59" color="">}}




{{<matomeQuote body="既知の深さでツリーを先行順巡回順序で送るなら、ノードIDや親IDなしでツリーを送れるよ！<br>各ノードのレベルだけを送って、スタックを使ってツリー構造を復元できるんだ。" userName="dmkolobov" createdAt="2025/06/01 02:18:55" color="#38d3d3">}}




{{<matomeQuote body="まあ、ここでは幅優先順序を使うのが全体のポイントなんだよね。<br>幅優先探索に深さベクトルの類似物があるとは思わないな。あるのかな？<br>でも、確かに深さベクトルはきれいでコンパクトだよね。<br>ただ、ほとんどの場合は扱いにくいと思うんだ、特に挿入や削除が親ベクトルのO(1)に対してO(n)になるからね。<br>とはいえ、APIの境界では親ベクトルをdfpo順序に正規化することはよくあるよ、明確な順序があるとリーフの兄弟を見つけるみたいな特定の操作がずっと楽になるからね。" userName="xelxebar" createdAt="2025/06/01 02:51:39" color="#ff5733">}}




{{<matomeQuote body="深さベクトルには詳しくないんだけど、深さ優先形式で各項目がその深さを指定するのと似た、幅優先探索の類似物って、各項目がその直下の子の数を指定することになるんじゃないかな？" userName="ummonk" createdAt="2025/06/01 04:04:31" color="">}}




{{<matomeQuote body="うん、確かに限界はあるのは間違いないね。俺はストリーミングの側面が好きだよ。<br>この記事で説明されてる機能はまだ使えると思うんだ。<br>レベルをタグ付けした「穴」マーカーを送るんだ。<br>そして、復元フェーズでこれらのマーカーに遭遇したときに、おそらく穴のバッファリングをしながら追加のリクエストを出すんだよ。<br>これは、一度に送りたいだけツリー構造を送れる、ある種のハイブリッドなDFS/BFSアプローチになるね。" userName="dmkolobov" createdAt="2025/06/01 19:50:59" color="#45d325">}}




{{<matomeQuote body="これ、小さなライブラリ作ってみる価値あるかもね。" userName="x-complexity" createdAt="2025/06/01 01:53:56" color="">}}




{{<matomeQuote body="この考え方以外に、代替案が二つあるよ。一つはJSON Linesでヘッダーとデータを分ける方法。もう一つはサーバーが属性の順序を保証して、大きな配列を最後に送る方法。これらはよくある大きなJSON問題にシンプルに対処できるし、Promiseベースよりずっと簡単だよ。" userName="jerf" createdAt="2025/06/01 14:27:37" color="#ff33a1">}}




{{<matomeQuote body="ぶっちゃけ、ほとんどのアプリにこんな高度なものはいらないでしょ。必要な情報がバラバラなら、複数回API呼べばいいんだし。今のやり方で十分だよ。" userName="Velorivox" createdAt="2025/06/01 01:41:40" color="">}}




{{<matomeQuote body="誤解しないでほしいんだけど、アプリで手動実装しろって言ってるわけじゃないんだ。これはRSCのワイヤープロトコルがどう動くかを説明してるだけ。理解の助けになったり、アイデアを組み合わせるのに役立てばいいなと思って書いたんだ。" userName="danabramov" createdAt="2025/06/01 02:33:16" color="#ff5c5c">}}




{{<matomeQuote body="前のコメントは別のコメントへの返信だったんだけど、消してトップに移動させたら文脈がなくなって、記事全体に対して皮肉っぽく聞こえちゃったね。それは意図してなかったよ。ごめんね。" userName="Velorivox" createdAt="2025/06/01 02:39:41" color="">}}




{{<matomeQuote body="僕が作ってるCSTML（ストリーミング形式のデータフォーマット）で、この記事のアイデアを何か取り入れられないか考えてるんだ。" userName="conartist6" createdAt="2025/06/01 02:39:30" color="">}}




{{<matomeQuote body="複数回API呼び出しなんて嫌だね。記事のJSON例はOOP+ORM風で良くないな。コメントをID参照にする構造にするか、protobufsみたいな型付きプロトコルを使うといいかも。protobufsなら、ページの取得とコメントの取得を分けてもスッキリできるかもしれないね。" userName="neRok" createdAt="2025/06/01 09:52:47" color="#ff5733">}}




{{<matomeQuote body="“たまたま良いオフザシェルフのオプション”があるのは全然悪くない（意図しないオーバーエンジニアリング的な意味で）。でも、既存のオプションに“fancy”な機能を追加するのは問題ありだね。それは複雑なエンジニアリング問題で、リーキーな抽象化になって結局使う人を困らせるから。" userName="xtajv" createdAt="2025/06/01 05:36:34" color="#ff33a1">}}




{{<matomeQuote body="あなたのコメントは“良い結果”にフォーカスしてるけど、トレードオフの現実を見てないね。オーバーエンジニアリングは常に問題を引き起こすよ。システムは理解しにくく、メンテナンスもトラブルシューティングも大変になる。例えば、JSON配列の要素を勝手に並べ替えるツールとか、非自明な形で壊れることがあるんだ。" userName="motorest" createdAt="2025/06/01 07:07:01" color="#785bff">}}

{{</details>}}



[記事一覧へ]({{% ref "/posts/" %}})
